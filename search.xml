<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>ssm知识整理</title>
      <link href="/ssm%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86.html"/>
      <url>/ssm%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="resultType和resultMap的区别是什么？"><a href="#resultType和resultMap的区别是什么？" class="headerlink" title="resultType和resultMap的区别是什么？"></a>resultType和resultMap的区别是什么？</h2><p> MyBatis中在查询进行select映射的时候，返回类型可以用resultType，也可以用resultMap，resultType是直接表示返回类型的(对应着我们的model对象中的实体)，而resultMap则是对外部ResultMap的引用(提前定义了db和model之间的隐射key–&gt;value关系)，但是resultType跟resultMap不能同时存在。</p><h2 id="在MyBatis进行查询映射时，其实查询出来的每一个属性都是放在一个对应的Map里面的，其中键是属性名，值则是其对应的值。"><a href="#在MyBatis进行查询映射时，其实查询出来的每一个属性都是放在一个对应的Map里面的，其中键是属性名，值则是其对应的值。" class="headerlink" title="在MyBatis进行查询映射时，其实查询出来的每一个属性都是放在一个对应的Map里面的，其中键是属性名，值则是其对应的值。"></a>在MyBatis进行查询映射时，其实查询出来的每一个属性都是放在一个对应的Map里面的，其中键是属性名，值则是其对应的值。</h2><p>  ①当提供的返回类型属性是resultType时，MyBatis会将Map里面的键值对取出赋给resultType所指定的对象对应的属性。所以其实MyBatis的每一个查询映射的返回类型都是ResultMap，只是当提供的返回类型属性是resultType的时候，MyBatis对自动的给把对应的值赋给resultType所指定对象的属性。<br>  ②当提供的返回类型是resultMap时，因为Map不能很好表示领域模型，就需要自己再进一步的把它转化为对应的对象，这常常在复杂查询中很有作用。</p><h2 id="MyBatis传参的几种方式？"><a href="#MyBatis传参的几种方式？" class="headerlink" title="MyBatis传参的几种方式？"></a>MyBatis传参的几种方式？</h2><p>1、  按照序列入参<br>2、  第二种：基本数据类型（parameterType=”xxx”）(接口方法声明参数中可使用注解@param(“xx”),一个参数时可以不用加@param，多个参数是就要用@param了。)<br>3、  JAVA实体类<br>4、  Map</p><h2 id="mapper元素的namespace属性的作用是什么？"><a href="#mapper元素的namespace属性的作用是什么？" class="headerlink" title="mapper元素的namespace属性的作用是什么？"></a>mapper元素的namespace属性的作用是什么？</h2><p>在mybatis中，映射文件中的namespace是用于绑定Dao接口的，即面向接口编程。<br>当你的namespace绑定接口后，你可以不用写接口实现类，mybatis会通过该绑定自动帮你找到对应要执行的SQL语句</p><h2 id="谈谈你对association和collection元素的理解"><a href="#谈谈你对association和collection元素的理解" class="headerlink" title="谈谈你对association和collection元素的理解"></a>谈谈你对association和collection元素的理解</h2><p>Association映射到javabean的某个复杂数据类型，比如javabean类，即javabean内部嵌套一个复杂数据类型属性这种情况属于复杂类型的关联，但association仅处理一对一的关联关系<br>Collection和association的作用差不多，只是映射的属性是个集合列表，是javabean内部嵌套的一个复杂数据类型（集合）属性</p><h2 id="实现动态SQL的主要元素有哪些？"><a href="#实现动态SQL的主要元素有哪些？" class="headerlink" title="实现动态SQL的主要元素有哪些？"></a>实现动态SQL的主要元素有哪些？</h2><p>If:简单的条件查询<br>Choose：相当于java中的switch语句通常和when和otherwise搭配<br>Where：简化SQL语句中的where条件判断<br>Set：解决动态更新语句<br>Trim：可以去除灵活的关键字<br>Foreach：迭代一个集合通常与in连用</p><h2 id="什么是数据持久化？"><a href="#什么是数据持久化？" class="headerlink" title="什么是数据持久化？"></a>什么是数据持久化？</h2><p>是程序数据在瞬时状态和持久状态间转换的过程</p><h2 id="简述SqlSessionFactoryBuild"><a href="#简述SqlSessionFactoryBuild" class="headerlink" title="简述SqlSessionFactoryBuild"></a>简述SqlSessionFactoryBuild</h2><p>负责构建SqlSessionFactory，并提供多个build方法的重载</p><h2 id="SqlSessionFactoryBuilder-SqlSessionFactory、SqlSession的生命周期和作用域"><a href="#SqlSessionFactoryBuilder-SqlSessionFactory、SqlSession的生命周期和作用域" class="headerlink" title="SqlSessionFactoryBuilder SqlSessionFactory、SqlSession的生命周期和作用域"></a>SqlSessionFactoryBuilder SqlSessionFactory、SqlSession的生命周期和作用域</h2><p>SqlSessionFactorBuildr用过即丢，最佳范围存在方法体内，也就是局部变量而已。<br>SqlSessionFactory对象一旦创建，就会在整个应用运行期间始终存在它的生命周期和应用同存在<br>SqlSession对应一次数据库会话</p><h2 id="Spring两大核心技术？"><a href="#Spring两大核心技术？" class="headerlink" title="Spring两大核心技术？"></a>Spring两大核心技术？</h2><p>SpringIOC(控制反转/依赖注入)<br>SpringAOP(面向切面编程)</p><h2 id="如何理解SpringIOC？"><a href="#如何理解SpringIOC？" class="headerlink" title="如何理解SpringIOC？"></a>如何理解SpringIOC？</h2><p>SpringIOC即控制反转/依赖注入,是面向对象编程中的一种设计理念,用来降低程序之间的耦合度</p><h2 id="如何理解SpringAOP"><a href="#如何理解SpringAOP" class="headerlink" title="如何理解SpringAOP ?"></a>如何理解SpringAOP ?</h2><p>SpringAop即面向切面编程，是面向对象编程的扩展，一般适用于具有横切逻辑的场合，如控制事物，事物管理、性能检测，SpringAOP简单来说就是在不改变原有代码的情况下增加新功能</p><h2 id="Spring有哪些优点？"><a href="#Spring有哪些优点？" class="headerlink" title="Spring有哪些优点？"></a>Spring有哪些优点？</h2><p>低侵入式设计<br>独立于各种应用服务器<br>依赖注入特性将组件关系透明化，降低耦合度<br>通用任务集中处理<br>与第三方框架的良好整和</p><h2 id="如何通过属性文件配置数据源？"><a href="#如何通过属性文件配置数据源？" class="headerlink" title="如何通过属性文件配置数据源？"></a>如何通过属性文件配置数据源？</h2><p>使用Spring提供的PropertyPlaceholderConfigurer类加载属性文件，在Spring配置文件中采用${ ……}的方式引用属性文件中的键值对</p><h2 id="如何加载JNDI数据源？"><a href="#如何加载JNDI数据源？" class="headerlink" title="如何加载JNDI数据源？"></a>如何加载JNDI数据源？</h2><p>Spring提供引用JNDI资源的JndiObjectFactoryBean类来调用</p><h2 id="简述Bean的作用域有几种？"><a href="#简述Bean的作用域有几种？" class="headerlink" title="简述Bean的作用域有几种？"></a>简述Bean的作用域有几种？</h2><p>1、singleton，单例模式，bean的实例只有一个<br>2、protopyte，每次容器获取bean时，都会创建一个新的实例<br>3、request，用于web应用环境，针对每次的http请求都会创建一个实例<br>4、session，同一个会话共享一个实例，不同的会话使用不同的实例<br>5、global，仅在Porplet的web环境中使用，同一个全局会话共享一个实例。对于非Porplet环境等同于session</p><h2 id="简述自动装配都有几种类型？"><a href="#简述自动装配都有几种类型？" class="headerlink" title="简述自动装配都有几种类型？"></a>简述自动装配都有几种类型？</h2><p>ByName  byType   constructor</p><h2 id="列举获取映射接口实例，实现数据操作的几中方式："><a href="#列举获取映射接口实例，实现数据操作的几中方式：" class="headerlink" title="列举获取映射接口实例，实现数据操作的几中方式："></a>列举获取映射接口实例，实现数据操作的几中方式：</h2><p>1、使用MapperFactoryBean注入映射器<br>2、使用MapperScannerConfigurer注入映射器</p><h2 id="简述声明事务配置的步骤："><a href="#简述声明事务配置的步骤：" class="headerlink" title="简述声明事务配置的步骤："></a>简述声明事务配置的步骤：</h2><p>  配置步骤<br> 导入tx和aop命名空间<br> 定义事务管理器Bean，并为其注入数据源Bean<br> 通过<a href="tx:advice">tx:advice</a>配置事务增强，绑定事务管理器并针对不同方法定义事务规则<br> 配置切面，将事务增强与方法切入点组</p><h2 id="什么是SpringMVC设计模式"><a href="#什么是SpringMVC设计模式" class="headerlink" title="什么是SpringMVC设计模式"></a>什么是SpringMVC设计模式</h2><p>数据访问接口：Dao层<br>处理业务逻辑层：Service层<br>数据实体层：Pojo<br>负责访问前端请求和处理：Servlet<br>负责前段页面展示：jsp<br>M:Model即数据模型—java<br>V:view即视图—jsp<br>C：controllor即控制器—Servlet</p><h2 id="简述SpringMVC的请求流程"><a href="#简述SpringMVC的请求流程" class="headerlink" title="简述SpringMVC的请求流程:"></a>简述SpringMVC的请求流程:</h2><p>当用户发送URL请求时,web.xml中的DispatcherServlet会截获请求，根据HandlerMappering找到对应的Controller来处理请求，Controller处理完成后，返回ModelAndView对象，该对象告诉DispatcherServlet需要通过哪个视图来进行数据模型展示，最后Dispatcher Servlet根据视图解析器把Controller返回的逻辑视图转换成view返回给用户界面</p><h2 id="什么是单例模式？"><a href="#什么是单例模式？" class="headerlink" title="什么是单例模式？"></a>什么是单例模式？</h2><p>系统运行期间，只有一个实例<br>具体来说有一下三个关键点：<br>1、一个类只有一个实例<br>2、它必须自行创建这个实例<br>3、它必须自行向整个系统提供这个实例</p><h2 id="SpringMVC如何处理多文件上传？"><a href="#SpringMVC如何处理多文件上传？" class="headerlink" title="SpringMVC如何处理多文件上传？"></a>SpringMVC如何处理多文件上传？</h2><p>1、表单页面加上file标签<br>2、单独入参，控制器处理</p><h2 id="SpringMVC中服务器端的数据如何实现验证的？"><a href="#SpringMVC中服务器端的数据如何实现验证的？" class="headerlink" title="SpringMVC中服务器端的数据如何实现验证的？"></a>SpringMVC中服务器端的数据如何实现验证的？</h2><p>1、利用Spring自带的验证框架<br>2、利用JSR303实现(java为bean数据合法性检验所提供得标准框架，SpringMVC支持JSR303标准得校验框架 JSR303通过在bean属性上标注类似于0)</p><h2 id="简述REST风格"><a href="#简述REST风格" class="headerlink" title="简述REST风格"></a>简述REST风格</h2><p>表述性状态转移，是一种软件架构风格，即使用URL表示资源时，每个资源都用一个独一无二的URL来表示，并使用HTTP方法白送和i操作，即准确的描述服务器对资源的处理动作（GET、POST、PUT、DELETE），并实现资源得增删改查</p><h2 id="PathVariable得用法："><a href="#PathVariable得用法：" class="headerlink" title="@PathVariable得用法："></a>@PathVariable得用法：</h2><p>接受REST风格URL中得参数</p><h2 id="ResponseBody注解的用法？"><a href="#ResponseBody注解的用法？" class="headerlink" title="@ResponseBody注解的用法？"></a>@ResponseBody注解的用法？</h2><p>该注解的作用是将标注该注解的处理方法的返回结果直接写入HTTP ResponseBody中，一般情况下该注解都会在异常处理数据时使用，被其标注的处理方法返回的数据将会输出到响应流中，客户端获取并显示数据</p><h2 id="SpringMVC中输出json数据时，对于日期格式应该如何处理？"><a href="#SpringMVC中输出json数据时，对于日期格式应该如何处理？" class="headerlink" title="SpringMVC中输出json数据时，对于日期格式应该如何处理？"></a>SpringMVC中输出json数据时，对于日期格式应该如何处理？</h2><p>1、注解方式：@JSONField(format= “yyyy-MM-dd”)<br>2、配置FastJson的消息转换器-FastJsonHttpMessageConverter<br>设置features属性：指定输出时的日期转换器为WriteDateUseDateFormat</p><h2 id="ContentNegotiatingViewResolver-视图解析器的应用理解？"><a href="#ContentNegotiatingViewResolver-视图解析器的应用理解？" class="headerlink" title="ContentNegotiatingViewResolver 视图解析器的应用理解？"></a>ContentNegotiatingViewResolver 视图解析器的应用理解？</h2><p>可以根据请求所要求的MIME类型决定由哪个视图解析器负责处理，它允许以同样的内容数据来呈现不同的View</p><h2 id="简述SSM框架整合的步骤？"><a href="#简述SSM框架整合的步骤？" class="headerlink" title="简述SSM框架整合的步骤？"></a>简述SSM框架整合的步骤？</h2><p>1、建项目导jar包<br>2、配置web.xml中的SpringMVC的核心控制器DispatcherServlet<br>3、配置applicationContext-Mybatis.xml Spring配置文件 database.properties  log4j.propertise  mybatis-config.xml  Springmvc-servlet.xml<br>4、事务管理配置SqlSessionFactoryBean MapperScannerConfiguer<br>5、对象数据模型pojo<br>6、数据访问接口Dao<br>7、系统服务接口 sevices<br>8、前端控制层controller<br>9、Tools工具类<br>10、前端页面jsp和静态资源statics</p><h2 id="面向过程编程，面向对象编程和面向切面编程理解"><a href="#面向过程编程，面向对象编程和面向切面编程理解" class="headerlink" title="面向过程编程，面向对象编程和面向切面编程理解"></a>面向过程编程，面向对象编程和面向切面编程理解</h2><p>面向过程(ProcedureOriented)是一种以过程为中心的编程思想。这些都是以什么正在发生为主要目标进行编程，不同于面向对象的是谁在受影响。与面向对象明显的不同就是封装、继承、类。<br>面向对象编程（ObjectOriented Programming，OOP，面向对象程序设计）是一种计算机编程架构。OOP 的一条基本原则是计算机程序是由单个能够起到子程序作用的单元或对象组合而成。OOP 达到了软件工程的三个主要目标：重用性、灵活性和扩展性。为了实现整体运算，每个对象都能够接收信息、处理数据和向其它对象发送信息。<br>面向切面编程（AspectOriented Programming(AOP)），是一个比较热门的话题。AOP主要实现的目的是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。</p><h2 id="怎么理解SpringAOP？"><a href="#怎么理解SpringAOP？" class="headerlink" title="怎么理解SpringAOP？"></a>怎么理解SpringAOP？</h2><p>SpringAOP是一种通过预编译和运行期间动态实现代理的方式实现了不修改代码的情况下给程序动态添加新功能的技术。</p><h2 id="SpringAOP增强处理类型有哪些？"><a href="#SpringAOP增强处理类型有哪些？" class="headerlink" title="SpringAOP增强处理类型有哪些？"></a>SpringAOP增强处理类型有哪些？</h2><p>前置增强   (org.springframework.aop.BeforeAdvice)   表示在目标方法执行前来实施增强<br>后置增强   (org.springframework.aop.AfterReturningAdvice)   表示在目标方法执行后来实施增强<br>环绕增强   (org.aopalliance.intercept.MethodInterceptor)   表示在目标方法执行前后同时实施增强<br>异常抛出增强   (org.springframework.aop.ThrowsAdvice)   表示在目标方法抛出异常后来实施增强<br>引介增强   (org.springframework.aop.introductioninterceptor)   表示在目标类中添加一些新的方法和属性</p><h2 id="IoC-主要的实现形式有两种"><a href="#IoC-主要的实现形式有两种" class="headerlink" title="IoC 主要的实现形式有两种 :"></a>IoC 主要的实现形式有两种 :</h2><p>依赖查找：容器提供回调接口和上下文环境给组件。 EJB 和 Apache Avalon 都是使用这种方式。<br>依赖注入：组件不做定位查询，只是提供普通的 Java 方法让容器去决定依赖关系。容器全权负责组件的装配，它会把符合依赖关系的对象通过 JavaBean 属性或者构造子传递给需要的对象。通过 JavaBean 属性注射依赖关系的做法称为设值方法注入（ Setter Injection ）；将依赖关系作为构造子参数传入的做法称为构造子注入（ Constructor Injection ）。</p><h2 id="AOP在Spring中的实现"><a href="#AOP在Spring中的实现" class="headerlink" title="AOP在Spring中的实现"></a>AOP在Spring中的实现</h2><p>基于AOP，业界存在各种各样的AOP实现，比如，JBoss AOP、Spring AOP、ASP ectJ、 Aspect Werkz等。各自实现的功能也不一样。AOP实现的强弱在很大程度上取决于连接点模型。目前，Spring只支持方法级的连接点。这和一些其他AOP框架不一样，如AspectJ和JBoss，它们还提供了属性接入点，这样可以防止你创建特别细致的通知，如对更新对象属性值进行拦截。然而，由于 Spring关注于提供一个实现J2EE 服务的框架，所以方法拦截可以满足大部分要求，而且Spring的观点是属性拦截破坏了封装，让Advice触发在属性值改变而不是方法调用上无疑是破坏了这个概念。</p><p>1、添加jar包<br>2、编写前置增强、后置增强等<br>3、编写spring配置文件applicantionContent.xml<br>4、编写代码，获取增强处理的对象</p><h2 id="Spring的AOP框架的关键点如下："><a href="#Spring的AOP框架的关键点如下：" class="headerlink" title="Spring的AOP框架的关键点如下："></a>Spring的AOP框架的关键点如下：</h2><p>（1）Spring实现了AOP联盟接口。在SpringAOP中，存在如下几种通知（Advice）类型<br>Before通知：在目标方法被调用前调用，涉及接口org.springFramework .aop.MethodBeforeAdvice;<br>After通知：在目标方法被调用后调用，涉及接口为org.springframework.aop.AfterReturningAdvice;<br>Throws通知：目标方法抛出异常时调用，涉及接口org.springframework.aop.MethodBeforeAdvice;<br>Around通知：拦截对目标对象方法调用，涉及接口为org.aopalliance.intercept.MethodInterceptor。<br>（2）用Java编写Spring通知，并在Spring的配置文件中，定义在什么地方应用通知的切入点。<br>（3）Spring的运行时通知对象。代理Bean只有在第一次被应用系统需要的时候才被创建。如果你使用的是ApplicationContext，代理对象在BeanFactory载入所有Bean的时候被创建。Spring有两种代理创建方式。如果目标对象实现了一个或多个接口暴露的方法，Spring将使用JDK 的 java.lang.reflect.Proxy类创建代理。这个类让Spring动态产生一个新的类，它实现所需的接口，织入了通知，并且代理对目标对象的所有请求。如果目标对象没有实现任何接口，Spring使用CGLIB库生成目标对象的子类。在创建这个子类的时候，Spring将通知织入，并且将对目标对象的调用委托给这个子类。此时，需要将Spring发行包lib/cglib目录下的JAR文件发布到应用系统中。</p>]]></content>
      
      
      <categories>
          
          <category> ssm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件测试</title>
      <link href="/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95.html"/>
      <url>/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="软件测试的分类"><a href="#软件测试的分类" class="headerlink" title="软件测试的分类"></a>软件测试的分类</h2><p>1、按测试阶段划分：单元、集成、系统、验收（Alpha、Beta、正式）<br>2、按测试技术划分：黑盒：看不到程序的逻辑与走向，在测试过程中只关注输入输出，也叫数据驱动测试<br> 白盒：基于软件内部设计和程序实现的测试方法。不仅关注输入输出的结果，还关注程序是如何处理的。<br> 灰盒：介于白盒和黑盒之间的一种测试，例如接口测试。<br>3、按被测试对象是否运行划分：静态、动态<br>4、按不同的测试手段划分：手动、自动<br>5、按测试包含的内容划分：<br> 功能测试：测试软件功能是否符合需求。<br> 界面测试：UI测试，测试系统用户界面是否合理，整体风格是否一致，界面文字是否正确，图片美观等等。<br> 性能测试：为获取或验证系统性能指标而进行的测试，会在不同负载情况下进行。<br> 安全性测试：测试该系统防止非法入侵的能力。<br> 负载测试：通过改变系统负载方式、增加负载等来发现系统中存在的性能问题。体现一种方法和一种技术。<br> 兼容性测试：测试该系统与其他软硬件兼容能力（app，c/s架构软件、b/s架构软件）。<br> 压力测试（强度测试）：主要为了确定系统稳定性<br> 1、高负载下长时间  的稳定性压力测试；<br> 2、极限负载情况下导致系统崩溃的破坏性压力测试。<br> 恢复测试：检查系统的容错能力。<br> 易用测试：软件测试是否易用，主观性较强。<br>6、其他测试：<br> 冒烟测试：对象是每一个新编译的需要正式测试的软件版本，确认基本功能正常，可继续后续正式测试工作。<br> 回归测试：指错误被修正后或软件功能、环境发生变化后进行的重新测试，确认修改部分不会对其他功能造成影响。<br> 探索性测试</p><h2 id="软件质量"><a href="#软件质量" class="headerlink" title="软件质量"></a>软件质量</h2><pre><code>软件质量包括正确性，可靠性，可读性，可移植性和健壮性，主要含义是软件的可靠性</code></pre><h2 id="软件可靠性"><a href="#软件可靠性" class="headerlink" title="软件可靠性"></a>软件可靠性</h2><pre><code>特定环境下，在给定时间内，无障碍运行的概率</code></pre><h2 id="度量"><a href="#度量" class="headerlink" title="度量"></a>度量</h2><pre><code>软件中初始故障的数量软件经过测试后，通过查错，改错，在软件中剩余故障的数量平均无故障时间故障间隔的时间长度故障发生率经过预测下次故障的发生时间</code></pre><h2 id="软件故障"><a href="#软件故障" class="headerlink" title="软件故障"></a>软件故障</h2><p>定义<br>    从内部看，软件故障是软件产品开发或维护过程中存在的错误，毛病等各种问题<br>    从外部看，软件故障是系统所需要实现的某种功能的失效或违背<br>计算机系统或程序存在任何一种破坏正常运行能力的问题，错误，或者隐藏的功能缺陷等<br>软件故障导致软件产品在某种程度上不能满足用户的需求<br>硬件故障<br>  物理性能恶化<br>软件故障<br>  设计阶段人为因素造成的<br>操作故障<br>  操作人员和维护人员的错误<br>环境故障<br>  电源，外界干扰，地震，火灾，病毒等各种外界因素引起的故障<br>错误<br>  人是会犯错的。过失是人犯下的，是人做一件错事或认为产生的一个不正确的结果<br>故障<br>  故障时错误的结果<br>失效<br>  故障引起的结果</p><h2 id="软件测试与软件可靠性"><a href="#软件测试与软件可靠性" class="headerlink" title="软件测试与软件可靠性"></a>软件测试与软件可靠性</h2><pre><code>软件中都会有故障存在可以减少故障的引入，但是不可能完全杜绝软件中的故障</code></pre><h2 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h2><pre><code>软件需求分析，设计说明和编码的最终复审是软件质量保证的关键步骤</code></pre><p> 是为了发现故障而执行程序的过程<br>定义：</p><ol><li>是否满足规定的需求</li><li>是否有差别<br>测试是为了发现故障而执行程序的过程<br>谁来执行<br>测试什么<br>什么时候测试<br>怎样进行测试<br>测试停止的标准<br>成功采用了具体的测试用例设计方法<br>每一类覆盖的覆盖率<br>故障检测率<br>检测出故障的具体数量或消耗的具体时间<h2 id="软件生存周期"><a href="#软件生存周期" class="headerlink" title="软件生存周期"></a>软件生存周期</h2>制定计划<br>需求分析<br>设计<br>程序编码<br>测试<br>运行维护</li></ol><h1 id="测试原则"><a href="#测试原则" class="headerlink" title="测试原则"></a>测试原则</h1><h2 id="黑盒测试与白盒测试"><a href="#黑盒测试与白盒测试" class="headerlink" title="黑盒测试与白盒测试"></a>黑盒测试与白盒测试</h2><h3 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h3><p> 等价类划分<br> 边界值分析<br> 决策表驱动</p><h3 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h3><p> 逻辑覆盖<br> 数据流测试<br> 域测试<br> 符号测试<br> 路径分析<br> 程序变异<br> 程序插装技术</p><h3 id="软件测试过程"><a href="#软件测试过程" class="headerlink" title="软件测试过程"></a>软件测试过程</h3><p>软件开发是自顶向下，软件测试自底向上</p><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>又称模块测试，针对程序模块来进行正确性检验的测试工作<br> 模块接口测试<br> 局部数据结构测试<br> 路径测试<br> 错误处理测试<br> 边界测试</p><h2 id="静态测试与动态测试"><a href="#静态测试与动态测试" class="headerlink" title="静态测试与动态测试"></a>静态测试与动态测试</h2><h3 id="静态测试"><a href="#静态测试" class="headerlink" title="静态测试"></a>静态测试</h3><p>不利用计算机运行被测试的程序，通过其他手段达到检测的目的</p><h3 id="动态测试"><a href="#动态测试" class="headerlink" title="动态测试"></a>动态测试</h3><p>通过运行和使用被测程序，发现软件故障，达到检测目的</p><h3 id="回归测试"><a href="#回归测试" class="headerlink" title="回归测试"></a>回归测试</h3><p>对程序进行测试已确定是否因修复故障而引入了新的故障</p><h3 id="α-alphaα测试"><a href="#α-alphaα测试" class="headerlink" title="α\alphaα测试"></a>α\alphaα测试</h3><p>由一个用户在开发环境下进行的测试<br>目的是平价产品的功能，可使用性，可靠性，性能和支持</p><h3 id="β-betaβ测试"><a href="#β-betaβ测试" class="headerlink" title="β\betaβ测试"></a>β\betaβ测试</h3><p>软件的多个用户在一个或多个用户的实际使用环境下进行的测试。开发者通常不在测试现场<br>α\alphaα测试达到一定的可靠程度时才能进行β\betaβ测试，它处在整个测试的最后阶段</p><h1 id="测试与调试"><a href="#测试与调试" class="headerlink" title="测试与调试"></a>测试与调试</h1><p>调试不属于测试<br>成功的测试发现错误从而引起调试的进行</p><h2 id="测试生命周期"><a href="#测试生命周期" class="headerlink" title="测试生命周期"></a>测试生命周期</h2><p> 测试计划<br> 测试设计<br> 测试开发<br> 测试执行<br> 测试评估</p><h2 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h2><h3 id="测试评估"><a href="#测试评估" class="headerlink" title="测试评估"></a>测试评估</h3><p> 测试覆盖测试<br> 软件故障评估<br> 测试有效性评估</p><h3 id="软件质量评估"><a href="#软件质量评估" class="headerlink" title="软件质量评估"></a>软件质量评估</h3><p>检查和评价当前软件开发过程,并设法达到防止软件故障出现</p><h3 id="软件过程成熟度"><a href="#软件过程成熟度" class="headerlink" title="软件过程成熟度"></a>软件过程成熟度</h3><ol><li>初始度</li><li>可重复级</li><li>定义明确</li><li>定量管理级</li><li>优化级</li></ol><h1 id="结构性测试"><a href="#结构性测试" class="headerlink" title="结构性测试"></a>结构性测试</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p> 基于被测试程序的源代码,而不是软件规格说明<br> 更容易发现软件测试故障,常用于单元测试</p><h2 id="结构性测试-1"><a href="#结构性测试-1" class="headerlink" title="结构性测试"></a>结构性测试</h2><p>白盒测试又称结构测试或者基于程序的测试.<br> 该方法将被测对象看做一个打开的盒子,允许内部人员检查其内部结构.测试人员根据程序内部结构特性,设计,选择测试用例,检查程序的每条路径是否都按照预定的要求正确执行.</p><h3 id="常见的白盒测试方法有"><a href="#常见的白盒测试方法有" class="headerlink" title="常见的白盒测试方法有:"></a>常见的白盒测试方法有:</h3><p> 逻辑覆盖<br> 数据流测试<br> 域测试<br> 符号测试<br> 路径分析<br> 程序变异<br> 程序插装<br>逻辑覆盖<br>使用最广泛<br> 要求对被测试程序逻辑结构有清楚的了解,要能掌握程序的所有细节<br> 要求对被测试程序的结构做到一定程度的覆盖<br> 分为:</p><h3 id="语义覆盖"><a href="#语义覆盖" class="headerlink" title="语义覆盖"></a>语义覆盖</h3><p>是比较弱的测试覆盖准则</p><h3 id="判定覆盖"><a href="#判定覆盖" class="headerlink" title="判定覆盖"></a>判定覆盖</h3><p>又称之为分支覆盖,使得每个判断的取真分支和取假分支至少执行一次,即判断的真假值均要被检测</p><h3 id="条件覆盖"><a href="#条件覆盖" class="headerlink" title="条件覆盖"></a>条件覆盖</h3><p>每个判断的每个条件的可能取值至少被执行一次</p><h3 id="判定-条件覆盖"><a href="#判定-条件覆盖" class="headerlink" title="判定-条件覆盖"></a>判定-条件覆盖</h3><p>判断中的每个条件的所有可能取值至少执行一次,同时每个判断的所有可能判断结果也至少被执行一次</p><h3 id="路径覆盖"><a href="#路径覆盖" class="headerlink" title="路径覆盖"></a>路径覆盖</h3><p>程序控制图</p><h3 id="重要性"><a href="#重要性" class="headerlink" title="重要性"></a>重要性</h3><p>明确地描述测试用例和测试用例所执行的程序部分之间的关系.<br>McCabe的基本路径法</p><h2 id="测试观点"><a href="#测试观点" class="headerlink" title="测试观点"></a>测试观点</h2><p>强连通图的圈数就是图中线性独立环路的数目</p><ol><li>选择一条基线路径,一般选择有较多判断结点的路径</li><li>回溯基线路径<h2 id="符号测试"><a href="#符号测试" class="headerlink" title="符号测试"></a>符号测试</h2><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2>允许程序的输入不仅可以是具体的数值数据,而且还可以包括符号值.<br>执行过程中以符号计算代替了普通执行中的数值计算,所得到的结果自然是符号公式或符号谓词<br>普通测试执行的事算数运算,符号测试执行的是代数计算<h3 id="程序插装"><a href="#程序插装" class="headerlink" title="程序插装"></a>程序插装</h3>借助于往被测试程序中插入操作来实现测试目的的方法<br>考虑的方面<br>探测哪些信息<br>在程序的什么部位设置探测点<br>需要设置多少个探测点<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3></li><li>覆盖分析</li><li>监控和断言</li><li>查找数据流异常<h2 id="指导方针"><a href="#指导方针" class="headerlink" title="指导方针"></a>指导方针</h2><h3 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h3>具有高圈复杂度的程序需要更充分的测试<br>一般选择V(G)=10<br>如果单元具有更高的复杂度,可以简化单元或计划更充分的测试<br>简化单元的最好方法是解决非结构化的问题<h3 id="覆盖指标"><a href="#覆盖指标" class="headerlink" title="覆盖指标"></a>覆盖指标</h3></li><li>作为一种强制执行的标准</li><li>作为一种机制,指导要求更严格部分的代码有选择地进行测试<h3 id="数据流测试"><a href="#数据流测试" class="headerlink" title="数据流测试"></a>数据流测试</h3>数据流是指关注定义点和使用(或引用)点的一种结构测试方法,它和数据流图没有什么联系.<br>实际上很多数据流测试支持者和研究人员将这种测试方法看作是一种路径测试.<br>通过分析变量的定义和使用,以查找如引用未定义变量等程序错误,也可以用来查找对以前未曾使用的变量的再次赋值等数据流异常的情况<br>早期数据流分析常常集中于现在叫定义/引用异常的缺陷:<br>变量被定义但是从来没有被使用<br>所使用的变量没有被定义<br>变量在使用之前被定义了两次<br>这些异常可以通过程序的索引表发现,可以通过所谓的静态分析发现<br>将程序中的变量出现分为定义和引用<br>语句K执行时改变了程序变量V的值,则称K定义了变量V<br>若语句k执行时引用了变量V的值,则称K引用了变量V<h3 id="定义-使用测试"><a href="#定义-使用测试" class="headerlink" title="定义/使用测试"></a>定义/使用测试</h3>假设V是程序P中的变量的集合,程序P控制流程图用G(P)表示,其中结点代表语句或语句片段,边代表结点序列.G(P)有一个单入口节点和一个单出口节点,并且不允许有某个结点到自身的边<br>变量V的定义结点,记作DEF(v,n)<br>结点n∈\in∈ G(P)是变量v∈\in∈V定义的结点,当且仅当变量V的值由对应结点n的语句或语句片段所定义.<br>变量v的使用结点n记作USE(v,n)<br>结点n∈\in∈ G(P)是变量v∈\in∈V的使用结点,当且仅当变量v的值在对应结点n的语句或语句片段中被引用.<br>谓词使用,记作P-use<br>USE(v,n)是一个谓词使用,当且仅当n是谓词语句,否则,USE(v,n)是计算使用,记作C-use.<br>定义/使用路径,记作du-path<br>如果对某个变量v∈\in∈V,存在一个定义,使用结点对,即DEF(v,m)和USE(v,n),使得变量v在结点m处被定义,在结点n处被使用,则称为一条定义/使用路径,结点m称为该定义使用路径的开始结点,而结点n则称为该定义/使用路径的结束结点.<br>定义清晰路径(defination-clear path),记作dc-path<br>如果一个变量v∈\in∈V,存在一个定义,使用结点对,即DEF(v,m)和USE(v,n),使得变量v在结点m处被定义,在结点n处被使用,并且从m到n的结点序列中没有其他结点对对变量v进行过定义,则从m到n的结点序列称为一条定义清晰路径,结点m称为该定义/使用路径的开始结点,而结点n则称为该定义/使用路径的结束结点.<br>定义/使用路径和定义清晰路径描述了变量从被定义到被引用点数据流向.<br>不是定义清晰的定义/使用路径,很可能是潜在问题的所在.所以应该特别关注定义/使用路径<h3 id="定义-使用路径覆盖测试"><a href="#定义-使用路径覆盖测试" class="headerlink" title="定义/使用路径覆盖测试"></a>定义/使用路径覆盖测试</h3>数据流覆盖测试指标<br>P是被测程序,G(P)是其控制流图,T是G(P)的路径集合,并假设定义/使用路径都是可执行路径<br>所有定义/使用路径覆盖准则<br>集合T满足程序P的所有定义/使用路径覆盖准则,当且仅当对所有的变量v∈\in∈V,T包含了从v的每个定义结点到v所有使用结点的定义清晰路径.<br>所有定义覆盖准则<br>集合T满足程序P所有定义覆盖准则,当且仅当对所有的变量v∈\in∈V,T包含了从变量v的每个定义结点到v的一个使用结点的定义清晰路径.<br>所有使用覆盖准则<br>集合T满足程序P的所有使用覆盖准则,当且仅当对所有的变量v∈\in∈V,T包含了从v的每个定义结点到v的所有使用结点的定义清晰路径<br>所有谓词使用/部分计算使用覆盖准则<br>集合T满足程序P的所有谓词使用/部分计算使用覆盖准则,当且仅当对所有的变量v∈\in∈V,T包含了从v的每个定义结点到v的所有谓词使用结点的定义清晰路径,并且如果v的一个定义没有谓词使用结点,则定义清晰路径至少包含一个计算使用<br>所有计算使用/部分谓词使用覆盖准则<br>集合T满足程序P的所有计算使用/部分谓词使用覆盖准则,当且仅当对所有的变量v∈\in∈V,T包含了从每个定义结点v的所有计算使用结点的定义清晰路径,并且如果v的一个定义没有使用计算节点,则定义清晰路径至少包含一个谓词使用.</li></ol><h2 id="测试和质量的关系"><a href="#测试和质量的关系" class="headerlink" title="测试和质量的关系"></a>测试和质量的关系</h2><p>修复软件缺陷的代价：<br>假设在需求分析阶段修复软件缺陷的代价为“单位1”。<br>设计阶段：3～6倍。<br>编程阶段：10倍。<br>内部测试阶段：20～40倍。<br>外部测试阶段：30～70倍。<br>产品发布后：40～1000倍。<br>修正错误的代价不是随时间线性增长，而几乎是呈指数增长的。</p><h2 id="软件测试结束的标准："><a href="#软件测试结束的标准：" class="headerlink" title="软件测试结束的标准："></a>软件测试结束的标准：</h2><p>用例全部测试；<br>覆盖率达到标准；<br>缺陷率达到标准；<br>其他指标达到标准。</p><h2 id="软件测试的工作范围"><a href="#软件测试的工作范围" class="headerlink" title="软件测试的工作范围"></a>软件测试的工作范围</h2><p>1、软件测试工作的组织与管理：制定测试策略、测试计划，确认所采用的测试方法与规范，控制测试进度，管理测试资源。<br>2、测试工作的实施：编制符合标准的测试文档，搭建测试环境，开发测试脚本、与开发组织协作实现各阶段的测试活动。</p><h2 id="软件质量与软件缺陷"><a href="#软件质量与软件缺陷" class="headerlink" title="软件质量与软件缺陷"></a>软件质量与软件缺陷</h2><p>软件质量：<br>软件产品满足使用要求的程度。</p><h3 id="白盒测试黑盒测试"><a href="#白盒测试黑盒测试" class="headerlink" title="白盒测试黑盒测试"></a>白盒测试黑盒测试</h3><p>白盒测试也称结构测试或逻辑驱动测试，它是按照程序内部的结构测试程序，通过测试来检测产品内部动作是否按照设计规格说明书的规定正常进行，检验程序中的每条通路是否都能按预定要求正确工作。</p><p>黑盒测试也称功能测试，它是通过测试来检测每个功能是否都能正常使用。在测试中，把程序看作一个不能打开的黑盒子，在完全不考虑程序内部结构和内部特性的情况下，在程序接口进行测试，它只检查程序功能是否按照需求规格说明书的规定正常使用，程序是否能适当地接收输入数据而产生正确的输出信息。黑盒测试着眼于程序外部结构，不考虑内部逻辑结构，主要针对软件界面和软件功能进行测试。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><p>测试用例：<br>为某个特殊目标而编制的一组测试输入、执行条件以及预期结果，以便测试某个程序路径或核实是否满足某个特定需求。指对一项特定的软件产品进行测试任务的描述，体现测试方案、方法、技术和策略。内容包括测试目标、测试环境、输入数据、测试步骤、预期结果、测试脚本等，并形成文档。</p><h3 id="设计测试用例的原因："><a href="#设计测试用例的原因：" class="headerlink" title="设计测试用例的原因："></a>设计测试用例的原因：</h3><p>测试用例构成了设计和制定测试过程的基础。<br>测试的“深度”与测试用例的数量成比例。由于每个测试用例反映不同的场景、条件或经由产品的事件流，因而，随着测试用例数量的增加，对产品质量和测试流程也就越有信心。判断测试是否完全的一个主要评测方法是基于需求的覆盖，而这又是以确定、实施和/或执行的测试用例的数量为依据的。<br>测试工作量与测试用例的数量成比例。根据全面且细化的测试用例，可以更准确地估计测试周期各连续阶段的时间安排。<br>测试设计和开发的类型以及所需的资源主要都受控于测试用例。<br>测试用例通常根据它们所关联关系的测试类型或测试需求来分类，而且将随类型和需求进行相应地改变。最佳方案是为每个测试需求至少编制两个测试用例：一个测试用例用于证明该需求已经满足，通常称作正面测试用例；另一个测试用例反映某个无法接受、反常或意外的条件或数据，用于论证只有在所需条件下才能够满足该需求，这个测试用例称作负面测试用例。<br>测试用例是软件测试的核心。</p><p>4.1 W模型<br>4.2 五大流派<br>1、分析学派：<br>分析学派认为软件测试是严格的技术性的，这一派在学术界有很多支持者。<br>2、标准学派：<br>标准学派认为软件测试是用于衡量进度的一种方式，强调成本度量和可重复的标准。<br>3、质量学派：<br>质量学派强调过程，软件测试人员像警察一样审判开发人员，又像守门员一样保证质量。<br>4、上下文驱动学派：<br>上下文驱动学派强调软件测试人的作用，寻找利益相关的BUG。<br>5、敏捷学派：<br>敏捷学派使用软件测试来验证开发是否完成，强调自动化。</p><h1 id="单元测试-1"><a href="#单元测试-1" class="headerlink" title="单元测试"></a>单元测试</h1><p>单元测试是对软件基本组成单元（如函数、类的方法等）进行的测试。<br>单元测试是对软件基本组成单元进行的测试。</p><h2 id="单元测试的时机："><a href="#单元测试的时机：" class="headerlink" title="单元测试的时机："></a>单元测试的时机：</h2><p>一般在代码完成后由开发人员完成，QA（质量保证）人员辅助。</p><p>单元测试相关概念：模块, 组件, 单元。<br>单元测试的测试人员：程序人员和开发人员。</p><p>单元测试的测试依据：详细设计说明书、概要设计说明书。<br>单元测试测试的不仅仅是代码，还有：接口测试、局部数据结构测试、独立路径测试、独立路径测试、边界条件测试、错误处理测试、功能测试、性能测试、内存使用测试等。</p><h2 id="单元测试的主要目标："><a href="#单元测试的主要目标：" class="headerlink" title="单元测试的主要目标："></a>单元测试的主要目标：</h2><p>测试单元模块是否被正确编码，具体表现为：<br>1、信息能否正确地流入和流出单元；<br>2、在单元工作过程中，其内部数据能否保持其完整性，包括内部数据的形式、内容及相互关系不发生错误，也包括全局变量在单元中的处理和影响。<br>3、在为限制数据加工而设置的边界处，能否正确工作。<br>4、单元的运行能否做到满足特定的逻辑覆盖。<br>5、单元中发生了错误，其中的出错处理措施是否有效。</p><h2 id="驱动程序和桩程序"><a href="#驱动程序和桩程序" class="headerlink" title="驱动程序和桩程序"></a>驱动程序和桩程序</h2><h3 id="驱动程序："><a href="#驱动程序：" class="headerlink" title="驱动程序："></a>驱动程序：</h3><p>对底层或子层模块进行测试所编写的，调用这些模块的程序。</p><h3 id="桩程序："><a href="#桩程序：" class="headerlink" title="桩程序："></a>桩程序：</h3><p>对顶层或上层模块进行测试时所编写的，替代下层模块的程序。</p><h2 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h2><p>集成测试是将软件集成起来，对模块之间的接口进行测试。 集成测试又叫子系统测试、组装测试、部件测试等。</p><p>1、模块内的集成，主要是测试模块内各个接口间的交互集成关系；<br>2、子系统内的集成，测试子系统内各个模块间的交互关系；<br>3、系统内的集成，测试系统内各个子系统和模块间的集成关系。</p><p>集成测试的测试人员：有经验的测试人员和开发者共同进行测试。</p><h2 id="非渐增式测试模式："><a href="#非渐增式测试模式：" class="headerlink" title="非渐增式测试模式："></a>非渐增式测试模式：</h2><p>先分别测试每个模块，再把所有模块按设计要求放在一起结合成所要的程序，如大棒模式。</p><h2 id="渐增式测试模式："><a href="#渐增式测试模式：" class="headerlink" title="渐增式测试模式："></a>渐增式测试模式：</h2><p>把下一个要测试的模块同已经测试好的模块结合进来进行测试，测试完后再把下一个应该测试的模块结合起来测试。</p><p>渐增式测试又可以根据每次添加模块的路线分为自顶向下测试、自底向上测试和混合测试（三明治集成方法）等方式。</p><h2 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h2><p>系统测试（特征测试）：<br>检验系统所有元素之间协作是否合适，整个系统的性能和功能是否达到要求。</p><p>系统测试的测试内容：功能测试，非功能测试与回归测试。</p><h3 id="非功能性测试（特征测试）包含的内容："><a href="#非功能性测试（特征测试）包含的内容：" class="headerlink" title="非功能性测试（特征测试）包含的内容："></a>非功能性测试（特征测试）包含的内容：</h3><p>性能测试，压力测试，容量测试，安全性测试，可靠性测试，容错性测试。</p><h3 id="系统测试的测试依据："><a href="#系统测试的测试依据：" class="headerlink" title="系统测试的测试依据："></a>系统测试的测试依据：</h3><p>需求说明书，概要设计说明书，详细设计说明书，最重要的是需求说明书。</p><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>性能测试（performance test）就是为了发现系统性能问题或获取系统性能相关指标而进行的测试。一般在真实环境、特定负载条件下，通过工具模拟实际软件系统的运行及其操作，同时监控性能各项指标，最后对测试结果进行分析来确定系统的性能状况。</p><h2 id="验收测试："><a href="#验收测试：" class="headerlink" title="验收测试："></a>验收测试：</h2><p>检查软件是否符合合同要求，包括需求规格说明、设计规格说明和用户手册等。</p><p>验收测试的测试人员：用户和测试部门共同完成。</p><p>验收测试的测试依据 ：<br>国家规范，行业标准，合同条款，用户确认的SRS。</p><h2 id="α，β测试"><a href="#α，β测试" class="headerlink" title="α，β测试"></a>α，β测试</h2><p>α测试是指软件开发公司组织内部人员模拟各类用户行对即将面市软件产品（称为α版本）进行测试，试图发现错误并修正。<br>经过α测试调整的软件产品称为β版本。紧随其后的β测试是指软件开发公司组织各方面的典型用户在日常工作中实际使用β版本，并要求用户报告异常情况、提出批评意见。然后软件开发公司再对β版本进行改错和完善。</p><h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><p>自动化测试是相对手工测试而存在的一个概念，由手工逐个地运行测试用例的操作过程被测试工具自动执行的过程所代替。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>win10快捷键</title>
      <link href="/win10%E5%BF%AB%E6%8D%B7%E9%94%AE.html"/>
      <url>/win10%E5%BF%AB%E6%8D%B7%E9%94%AE.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="复制、粘贴和其他常规键盘快捷方式"><a href="#复制、粘贴和其他常规键盘快捷方式" class="headerlink" title="复制、粘贴和其他常规键盘快捷方式"></a>复制、粘贴和其他常规键盘快捷方式</h1><p>Ctrl + X  -&gt;剪切选定项<br>Ctrl + C（或 Ctrl + Insert） -&gt; 复制选定项<br>Ctrl + V（或 Shift + Insert） -&gt; 粘贴选定项<br>Ctrl + Z -&gt; 撤消操作<br>Alt + Tab -&gt; 在打开的应用之间切换<br>Alt + F4 -&gt; 关闭活动项，或者退出活动应用<br>Windows 徽标键 + L -&gt; 锁定电脑<br>Windows 徽标键 + D -&gt; 显示和隐藏桌面</p><p>F2 -&gt; 重命名选定项<br>F3 -&gt; 在文件资源管理器中搜索文件或文件夹<br>F4 -&gt; 在文件资源管理器中显示地址栏列表<br>F5 -&gt; 刷新活动窗口<br>F6 -&gt; 在窗口中或桌面上循环浏览屏幕元素<br>F10 -&gt; 激活活动应用中的菜单栏<br>Alt + F8 -&gt; 在登录屏幕上显示密码<br>Alt + Esc -&gt; 以项目打开的顺序循环切换项目<br>Alt + 带下划线的字母 -&gt; 执行该字母对应的命令<br>Alt + Enter -&gt; 显示选定项的属性<br>Alt + 空格键 -&gt; 为活动窗口打开快捷菜单<br>Alt + 向左键 -&gt; 后退<br>Alt + 向右键 -&gt; 前进<br>Alt + Page Up -&gt; 向上移动一个屏幕<br>Alt + Page Down -&gt; 向下移动一个屏幕</p><p>Ctrl + F4 -&gt; 关闭活动文档（在全屏模式和允许你同时打开多个文档的应用中）<br>Ctrl + A -&gt; 选择文档或窗口中的所有项目<br>Ctrl + D（或 Delete） -&gt; 删除选定项并将其移动到“回收站”<br>Ctrl + R（或 F5） -&gt; 刷新活动窗口<br>Ctrl + Y -&gt; 重做操作<br>Ctrl + 向右键 -&gt; 将光标移动到下一个字词的起始处<br>Ctrl + 向左键 -&gt; 将光标移动到上一个字词的起始处<br>Ctrl + 向下键 -&gt; 将光标移动到下一个段落的起始处<br>Ctrl + 向上键 -&gt; 将光标移动到上一个段落的起始处<br>Ctrl + Alt + Tab -&gt; 使用箭头键在所有打开的应用之间切换<br>Ctrl + Alt + Shift + 箭头键 -&gt; 当分组或磁贴在“开始”菜单中获得焦点时，请将其按指定方向移动<br>Ctrl + 箭头键（用来移动到某个项目）+ 空格键 -&gt; 在窗口中或桌面上选择多个单独的项目<br>Ctrl + Shift 加某个箭头键 -&gt; 选择文本块</p><p>Ctrl + Esc -&gt; 打开“开始”屏幕<br>Ctrl + Shift + Esc -&gt; 打开任务管理器<br>Ctrl + Shift -&gt; 在提供了多个键盘布局时切换键盘布局<br>Ctrl + 空格键 -&gt; 打开或关闭中文输入法编辑器 (IME)<br>Shift + F10 -&gt; 显示选定项的快捷菜单<br>Shift 加任意箭头键 -&gt; 在窗口中或桌面上选择多个项目，或者在文档中选择文本<br>Shift + Delete -&gt; 无需先将选定项移动到“回收站”，直接将其删除<br>向右键 -&gt; 打开右侧的下一个菜单，或者打开子菜单<br>向左键 -&gt; 打开左侧的下一个菜单，或者关闭子菜单<br>Esc -&gt; 停止或退出当前任务</p><h1 id="Windows-徽标键键盘快捷方式"><a href="#Windows-徽标键键盘快捷方式" class="headerlink" title="Windows 徽标键键盘快捷方式"></a>Windows 徽标键键盘快捷方式</h1><p>Windows 徽标键 -&gt; 打开或关闭“开始”菜单<br>Windows 徽标键 + A -&gt; 打开“操作中心”<br>Windows 徽标键 + B -&gt; 将焦点设置到通知区域<br>Windows 徽标键 + D -&gt; 显示和隐藏桌面<br>Windows 徽标键 + Alt + D -&gt; 显示和隐藏桌面上的日期和时间<br>Windows 徽标键 + E -&gt; 打开“文件资源管理器”<br>Windows 徽标键 + F -&gt; 打开“反馈中心”<br>Windows 徽标键 + G -&gt; 打开游戏栏（当游戏处于打开状态时）<br>Windows 徽标键 + H -&gt; 打开“共享”超级按钮<br>Windows 徽标键 + I -&gt; 打开“设置”</p><p>Windows 徽标键 + J -&gt;  将焦点设置到 Windows 提示（如果可用）。出现 Windows   提示时，将焦点移到该提示。 再次按这些键盘快捷方式，将焦点移到定位 Windows 提示的屏幕上的元素。<br>Windows 徽标键 + K -&gt; 打开“连接”快速操作<br>Windows 徽标键 + L -&gt; 锁定电脑或切换帐户<br>Windows 徽标键 + M -&gt; 最小化所有窗口<br>Windows 徽标键 + O -&gt; 锁定设备方向<br>Windows 徽标键 + P -&gt; 选择演示显示模式<br>Windows 徽标键 + R -&gt; 打开“运行”对话框<br>Windows 徽标键 + S -&gt; 打开搜素<br>Windows 徽标键 + T -&gt; 在任务栏上循环切换应用<br>Windows 徽标键 + U -&gt; 打开“轻松使用设置中心”<br>Windows 徽标键 + V -&gt; 循环切换通知<br>Windows 徽标键 + Shift + V -&gt; 以相反的顺序循环切换通知<br>Windows 徽标键 + X -&gt; 打开“快速链接”菜单<br>Windows 徽标键 + Z -&gt; 显示在以全屏模式呈现的应用中可用的命令<br>Windows 徽标键 + 逗号 (,) -&gt; 临时快速查看桌面</p><p>Windows 徽标键 + Pause -&gt; 显示“系统属性”对话框<br>Windows 徽标键 + Ctrl + F -&gt; 搜索电脑（如果你位于网络中）<br>Windows 徽标键 + Shift + M -&gt; 将最小化的窗口还原到桌面<br>Windows 徽标键 + 数字 -&gt; 打开桌面，并启动固定到任务栏的位于该数字所表示位置的应用。如果该应用已在运行，则切换到该应用。<br>Windows 徽标键 + Shift + 数字 -&gt; 打开桌面，并启动固定到任务栏的位于该数字所表示位置的应用的新实例<br>Windows 徽标键 + Ctrl + 数字 -&gt; 打开桌面，并切换到固定到任务栏的位于该数字所表示位置的应用的最后一个活动窗口<br>Windows 徽标键 + Alt + 数字 -&gt; 打开桌面，并打开固定到任务栏的位于该数字所表示位置的应用的跳转列表<br>Windows 徽标键 + Ctrl + Shift + 数字 -&gt; 打开桌面，并以管理员身份打开位于任务栏上给定位置的应用的新实例<br>Windows 徽标键 + Tab -&gt; 打开“任务视图”</p><p>Windows 徽标键 + 向上键 -&gt; 最大化窗口<br>Windows 徽标键 + 向下键 -&gt; 从屏幕中删除当前应用或最小化桌面窗口<br>Windows 徽标键 + 向左键 -&gt; 将应用或桌面窗口最大化到屏幕左侧<br>Windows 徽标键 + 向右键 -&gt; 将应用或桌面窗口最大化到屏幕右侧<br>Windows 徽标键 + Home -&gt; 最小化除活动桌面窗口以外的所有窗口（在第二道笔划时还原所有窗口）<br>Windows 徽标键 + Shift + 向上键 -&gt; 将桌面窗口拉伸到屏幕的顶部和底部<br>Windows 徽标键 + Shift + 向下键 -&gt; 在垂直方向上还原/最小化活动桌面窗口，同时保持宽度不变<br>Windows 徽标键 + Shift + 向左键或向右键 -&gt; 将桌面中的应用或窗口从一个监视器移动到另一个监视器<br>Windows 徽标键 + 空格键 -&gt; 切换输入语言和键盘布局<br>Windows 徽标键 + Ctrl + 空格键 -&gt; 更改为以前选择的输入<br>Windows 徽标键 + Enter -&gt; 打开“讲述人”<br>Windows 徽标键 + 正斜杠 (/) -&gt; 启动 IME 重新转换<br>Windows 徽标键 + 加号 (+) 或减号 (-) -&gt; 使用“放大镜”放大或缩小<br>Windows 徽标键 + Esc -&gt; 退出“放大镜”</p><h1 id="命令提示符键盘快捷方式"><a href="#命令提示符键盘快捷方式" class="headerlink" title="命令提示符键盘快捷方式"></a>命令提示符键盘快捷方式</h1><p>Ctrl + C（或 Ctrl + Insert） -&gt; 复制选定文本<br>Ctrl + V（或 Shift + Insert） -&gt; 粘贴选定文本<br>Ctrl + M -&gt; 进入标记模式<br>Alt + 选择键 -&gt; 在阻止模式中开始选择<br>箭头键 -&gt; 按指定方向移动光标<br>Page Up -&gt; 将光标向上移动一页<br>Page Down -&gt; 将光标向下移动一页<br>Ctrl + Home（标记模式） -&gt; 将光标移动到缓冲区的起始处<br>Ctrl + End（标记模式） -&gt; 将光标移动到缓冲区的末尾<br>Ctrl + 向上键 -&gt; 在输出历史记录中向上移动一行<br>Ctrl + 向下键 -&gt; 在输出历史记录中向下移动一行<br>Ctrl + Home（历史记录导航） -&gt; 如果命令行为空，则将视口移动到缓冲区顶部。否则，删除命令行中光标左侧的所有字符。<br>Ctrl + End（历史记录导航） -&gt; 如果命令行为空，则将视口移动到命令行。否则，删除命令行中光标右侧的所有字符。</p><h1 id="对话框键盘快捷方式"><a href="#对话框键盘快捷方式" class="headerlink" title="对话框键盘快捷方式"></a>对话框键盘快捷方式</h1><p>F4 -&gt; 显示活动列表中的项目<br>Ctrl + Tab -&gt; 在选项卡上向前移动<br>Ctrl + Shift + Tab -&gt; 在选项卡上向后移动<br>Ctrl + 数字（数字 1 到 9） -&gt; 移动到第 n 个选项卡<br>Tab -&gt; 在选项上向前移动<br>Shift + Tab -&gt; 在选项上向后移动<br>Alt + 带下划线的字母 -&gt; 执行与该字母一起使用的命令（或选择相应的选项）<br>空格键 -&gt; 如果活动选项是复选框，则选中或清除该复选框<br>Backspace -&gt; 如果在“另存为”或“打开”对话框中选中某个文件夹，则打开上一级文件夹<br>箭头键 -&gt; 如果活动选项是一组选项按钮，则选择某个按钮</p><h1 id="文件资源管理器键盘快捷方式"><a href="#文件资源管理器键盘快捷方式" class="headerlink" title="文件资源管理器键盘快捷方式"></a>文件资源管理器键盘快捷方式</h1><p>Alt + D -&gt; 选择地址栏<br>Ctrl + E -&gt; 选择搜索框<br>Ctrl + F -&gt; 选择搜索框<br>Ctrl + N -&gt; 打开新窗口<br>Ctrl + W -&gt; 关闭活动窗口<br>Ctrl + 鼠标滚轮 -&gt; 更改文件和文件夹图标的大小及外观<br>Ctrl + Shift + E -&gt; 显示选定文件夹上的所有文件夹<br>Ctrl + Shift + N -&gt; 创建一个新文件夹<br>Num Lock + 星号 (*) -&gt; 显示选定文件夹下的所有子文件夹<br>Num Lock + 加号 (+) -&gt; 显示选定文件夹的内容<br>Num Lock + 减号 (-) -&gt; 折叠选定文件夹</p><p>Alt + P -&gt; 显示预览面板<br>Alt + Enter -&gt; 打开选定项的“属性”对话框<br>Alt + 向右键 -&gt; 查看下一个文件夹<br>Alt + 向上键 -&gt; 查看上一级文件夹<br>Alt + 向左键 -&gt; 查看上一个文件夹<br>Backspace -&gt; 查看上一个文件夹<br>向右键 -&gt; 显示当前选项（如果它处于折叠状态），或者选择第一个子文件夹<br>向左键 -&gt; 折叠当前选项（如果它处于展开状态），或者选择其父文件夹<br>End -&gt; 显示活动窗口的底端<br>Home -&gt; 显示活动窗口的顶端<br>F11 -&gt; 最大化或最小化活动窗口</p><h1 id="虚拟桌面键盘快捷方式"><a href="#虚拟桌面键盘快捷方式" class="headerlink" title="虚拟桌面键盘快捷方式"></a>虚拟桌面键盘快捷方式</h1><p>Windows 徽标键 + Tab -&gt; 打开任务视图<br>Windows 徽标键 + Ctrl + D -&gt; 添加虚拟桌面<br>Windows 徽标键 + Ctrl + 向右键 -&gt; 在你于右侧创建的虚拟桌面之间进行切换<br>Windows 徽标键 + Ctrl + 向左键 -&gt; 在你于左侧创建的虚拟桌面之间进行切换<br>Windows 徽标键 + Ctrl + F4 -&gt; 关闭你正在使用的虚拟桌面</p><h1 id="任务栏键盘快捷方式"><a href="#任务栏键盘快捷方式" class="headerlink" title="任务栏键盘快捷方式"></a>任务栏键盘快捷方式</h1><p>Shift + 单击某个任务栏按钮 -&gt; 打开某个应用，或快速打开应用的另一个实例<br>Ctrl + Shift + 单击某个任务栏按钮 -&gt; 以管理员身份打开应用<br>Shift + 右键单击某个任务栏按钮 -&gt; 显示该应用的窗口菜单<br>Shift + 右键单击某个已分组的任务栏按钮 -&gt; 显示该组的窗口菜单<br>Ctrl + 单击某个已分组的任务栏按钮 -&gt; 循环切换该组的窗口</p><h1 id="设置键盘快捷方式"><a href="#设置键盘快捷方式" class="headerlink" title="设置键盘快捷方式"></a>设置键盘快捷方式</h1><p>Windows 徽标键 + I -&gt; 打开设置<br>Windows 徽标键 +Backspace -&gt; 回退到“设置”主页<br>Windows 徽标键 +Q -&gt; 搜索<br>Windows   10 应用中的键盘快捷方式<br>在许多应用（如照片、Groove   和地图）中，当你将鼠标指针悬停在某个按钮上时，工具提示中就会显示快捷方式。在其他应用（如画图、写字板和 Office）中，按 Alt 键或 F10 即可显示标记了键盘快捷方式的命令。如果菜单中某个字母有下划线，请同时按下 Alt 键和带有下划线的键，而不是选择该菜单项。例如，按 Ctrl + N 可在“画图”中创建新图片。<br>温馨提示：<br>借助触摸键盘，按下 Ctrl 键即可看到一些快捷方式。<br>以下是   Windows 10 中内置的某些 Microsoft 应用中常见的键盘快捷方式。这包括 Microsoft   Edge、计算器、游戏栏、Groove、地图、画图、照片、音乐和电视以及写字板。</p><h1 id="Microsoft-Edge-键盘快捷方式"><a href="#Microsoft-Edge-键盘快捷方式" class="headerlink" title="Microsoft Edge 键盘快捷方式"></a>Microsoft Edge 键盘快捷方式</h1><p>Ctrl + D -&gt; 将当前站点添加到收藏夹或阅读列表<br>Ctrl + I -&gt; 打开“收藏夹”窗格<br>Ctrl + J -&gt; 打开“下载”窗格<br>Ctrl + H -&gt; 打开“历史记录”窗格<br>Ctrl + P -&gt; 打印当前页面<br>Ctrl + F -&gt; 在页面上查找<br>Ctrl + Shift + R -&gt; 进入阅读视图<br>Ctrl + T -&gt; 打开一个新选项卡<br>Ctrl + Shift + T -&gt; 重新打开最近关闭的选项卡<br>Ctrl + W 或 Ctrl + F4 -&gt; 关闭活动选项卡<br>Ctrl + K -&gt; 复制选项卡<br>Ctrl + N -&gt; 打开新窗口</p><p>Ctrl + Shift + P -&gt; 打开新的   InPrivate 浏览窗口<br>Ctrl + Tab -&gt; 切换到下一个选项卡<br>Ctrl + Shift + Tab -&gt; 切换到上一个选项卡<br>Ctrl + 1、2、3，依此类推 -&gt; 切换到特定选项卡号<br>Ctrl + 9 -&gt; 切换到最后一个选项卡<br>Ctrl + 加号 (+) -&gt; 放大 (25%)<br>Ctrl + 减号 (-) -&gt; 缩小 (25%)<br>Ctrl + 0 -&gt; 重置缩放级别<br>Backspace 或 Alt + 向左键 -&gt; 返回<br>Alt + 向右键 -&gt; 前进<br>F5 或 Ctrl + R -&gt; 刷新页面<br>Esc -&gt; 停止加载页面</p><p>Ctrl + L 或 F4 或 Alt + D -&gt; 选中地址栏<br>Ctrl + Shift + L -&gt; 在新选项卡中打开地址栏查询<br>Ctrl + E -&gt; 在地址栏中打开搜索查询<br>Ctrl + Enter -&gt; 在地址栏中将“www.”添加到所键入文本的开头，将“.com”添加到所键入文本的末尾<br>Ctrl + 单击 -&gt; 在新选项卡中打开链接<br>Ctrl + Shift + 单击 -&gt; 在新选项卡中打开链接并切换到该选项卡<br>Alt + Shift + 单击 -&gt; 在新窗口中打开链接<br>Ctrl + Shift + M -&gt;  开始创建   Web 笔记<br>Ctrl + Alt + M -&gt;  将所选内容复制到   Web 笔记中<br>F12 -&gt; 打开 F12   开发人员工具<br>Ctrl + U -&gt;  查看源<br>F6 -&gt;  在网页内容和地址栏之间切换焦点<br>F7 -&gt;  为活动选项卡打开“插入光标浏览”<br>Ctrl + Shift + Delete -&gt;  显示用于清除浏览数据的控件</p><h1 id="“计算器”键盘快捷方式"><a href="#“计算器”键盘快捷方式" class="headerlink" title="“计算器”键盘快捷方式"></a>“计算器”键盘快捷方式</h1><p>Alt + 1 -&gt; 切换到“标准型”模式<br>Alt + 2 -&gt; 切换到“科学型”模式<br>Alt + 3 -&gt; 切换到“程序员”模式<br>Ctrl + M -&gt; 存储在内存中<br>Ctrl + P -&gt; 添加到内存<br>Ctrl + Q -&gt; 从内存中减去<br>Ctrl + R -&gt; 从内存中重新调用<br>Ctrl + L -&gt; 清除内存<br>F9 -&gt; 选择 ±<br>R -&gt; 选择 1/x<br>@ -&gt; 求平方根<br>Delete -&gt; 选择 CE<br>Ctrl + H -&gt; 打开或关闭计算历史记录<br>向上键 -&gt; 在“历史记录”列表中上移<br>向下键 -&gt; 在“历史记录”列表中下移<br>Ctrl + Shift + D -&gt; 清除历史记录<br>F3 -&gt; 在“科学型”模式下选择 DEG<br>F4 -&gt; 在“科学型”模式下选择 RAD<br>F5 -&gt; 在“科学型”模式下选择 GRAD<br>Ctrl + G -&gt; 在“科学型”模式下选择 10x<br>Ctrl + O -&gt; 在“科学型”模式下选择 cosh<br>Ctrl + S -&gt; 在“科学型”模式下选择 sinh<br>Ctrl + T -&gt; 在“科学型”模式下选择 tanh<br>Shift + S -&gt; 在“科学型”模式下选择 sin-1<br>Shift + O -&gt; 在“科学型”模式下选择 cos-1<br>Shift + T -&gt; 在“科学型”模式下选择“tan-1”<br>Ctrl + Y -&gt; 在“科学型”模式下选择 y√x<br>D -&gt; 在“科学型”模式下选择 Mod<br>L -&gt; 在“科学型”模式下选择 log<br>M -&gt; 在“科学型”模式下选择 dms<br>N -&gt; 在“科学型”模式下选择 ln<br>Ctrl + N -&gt; 在“科学型”模式下选择 ex<br>O -&gt; 在“科学型”模式下选择 cos<br>P -&gt; 在“科学型”模式下选择 Pi<br>Q -&gt; 在“科学型”模式下选择 x2<br>S -&gt; 在“科学型”模式下选择 sin<br>T -&gt; 在“科学型”模式下选择 tan<br>V -&gt; 在“科学型”模式下选择 F-E<br>X -&gt; 在“科学型”模式下选择 Exp<br>    Y, ^ -&gt; 在“科学型”模式下选择 xy</p><h1 id="gt-在“科学型”模式下选择-x3"><a href="#gt-在“科学型”模式下选择-x3" class="headerlink" title="-&gt; 在“科学型”模式下选择 x3"></a>-&gt; 在“科学型”模式下选择 x3</h1><p>; -&gt; 在“科学型”模式下选择 Int<br>! -&gt; 在“科学型”模式下选择 n!<br>F2 -&gt; 在“程序员”模式下选择 DWORD<br>F3 -&gt; 在“程序员”模式下选择 WORD<br>F4 -&gt; 在“程序员”模式下选择 BYTE<br>F5 -&gt; 在“程序员”模式下选择 HEX<br>F6 -&gt; 在“程序员”模式下选择 DEC<br>F7 -&gt; 在“程序员”模式下选择 OCT<br>F8 -&gt; 在“程序员”模式下选择 BIN<br>F12 -&gt; 在“程序员”模式下选择 QWORD<br>A-F -&gt; 在“程序员”模式下选择 A-F<br>J -&gt; 在“程序员”模式下选择 RoL<br>K -&gt; 在“程序员”模式下选择 RoR<br>&lt; -&gt; 在“程序员”模式下选择 Lsh</p><blockquote><p>-&gt; 在“程序员”模式下选择 Rsh<br>% -&gt; 在“程序员”模式下选择 Mod<br>| -&gt; 在“程序员”模式下选择 Or<br>^ -&gt; 在“程序员”模式下选择 Xor<br>~ -&gt; 在“程序员”模式下选择 Not<br>&amp; -&gt; 在“程序员”模式下选择 And<br>空格键 -&gt; 在“程序员”模式下切换位值</p></blockquote><h1 id="游戏栏键盘快捷方式"><a href="#游戏栏键盘快捷方式" class="headerlink" title="游戏栏键盘快捷方式"></a>游戏栏键盘快捷方式</h1><p>Windows 徽标键 + G打开游戏栏（当游戏处于打开状态时）<br>Windows 徽标键 + Alt + G录制最后 30 秒<br>Windows 徽标键 + Alt + R开始或停止录制<br>Windows 徽标键 + Alt + Print Screen获取你的游戏的屏幕截图<br>Windows 徽标键 + Alt + T显示/隐藏录制计时器</p><h1 id="Groove-键盘快捷方式"><a href="#Groove-键盘快捷方式" class="headerlink" title="Groove 键盘快捷方式"></a>Groove 键盘快捷方式</h1><p> Ctrl + P 播放或暂停<br> Ctrl + F 跳到下一曲<br> Ctrl + B 重新播放当前歌曲/跳到上一曲<br> F9 调高音量<br> F8 调低音量<br> F7 静音<br> Ctrl + Enter 选择项目并进入选择模式<br> Ctrl + A 全选<br> Delete 删除选定项<br> Ctrl + Shift + P 播放选定项<br> Ctrl + T 打开或关闭“重复播放”<br> Ctrl + H 打开或关闭“无序播放”<br> Ctrl + Q 搜索</p><h1 id="“地图”键盘快捷方式"><a href="#“地图”键盘快捷方式" class="headerlink" title="“地图”键盘快捷方式"></a>“地图”键盘快捷方式</h1><p>Ctrl + 加号或减号键（+ 或 -）放大或缩小<br>Ctrl + 向左键或向右键旋转<br> Ctrl + 向上键或向下键倾斜</p><ul><li>或 – 键在 3D 城市视图中放大或缩小<br>Page Up 或 Page Down在 3D 城市视图中推远或拉近<br>Ctrl + Y在鸟瞰图和道路视图之间切换地图视图<br>Ctrl + Home在你的当前位置上居中放置地图<br>Ctrl + D获取路线<br>Ctrl + F搜索<br>Ctrl + M最小化活动选项卡<br>Ctrl + P打印<br>Ctrl + T显示或隐藏路况<br>Backspace返回<br>Ctrl + H共享<br>Ctrl + L将焦点移动到地图<br>Ctrl + W关闭活动选项卡<br>Ctrl + Tab转到下一个选项卡<br>Ctrl + Shift + Tab转到上一个选项卡<br>Ctrl + S显示或隐藏街道<br>Ctrl + C复制到剪贴板</li></ul><h1 id="“电影和电视”键盘快捷方式"><a href="#“电影和电视”键盘快捷方式" class="headerlink" title="“电影和电视”键盘快捷方式"></a>“电影和电视”键盘快捷方式</h1><p>Alt + Enter全屏播放<br> Esc退出全屏<br> Enter选择焦点中的内容<br>空格键或Ctrl + P播放或暂停（当视频处于焦点中时）<br>Alt + 向左键或Windows 徽标键 + Backspace返回<br>Ctrl + T打开或关闭“重复播放”<br>F7静音<br>F8调低音量<br>F9调高音量</p><h1 id="“画图”键盘快捷方式"><a href="#“画图”键盘快捷方式" class="headerlink" title="“画图”键盘快捷方式"></a>“画图”键盘快捷方式</h1><p>F11以全屏模式查看图片<br>F12将此图片另存为新文件<br>Ctrl + A选择整个图片<br>Ctrl + B将所选文本改为粗体<br>Ctrl + C将选择内容复制到剪贴板<br>Ctrl + E打开“属性”对话框<br>Ctrl + G显示或隐藏网格线<br>Ctrl + I将所选文本改为斜体<br>Ctrl + N创建新图片<br>Ctrl + O打开现有图片<br>Ctrl + P打印图片<br>Ctrl + R显示或隐藏标尺<br>Ctrl + S将更改保存到图片<br>Ctrl + U为所选文本添加下划线<br>Ctrl + V从剪贴板粘贴选择内容<br>Ctrl + W打开“调整大小和扭曲”对话框<br>Ctrl + X剪切选择内容<br>Ctrl + Y恢复更改<br>Ctrl + Z撤销更改<br>Ctrl + 加号 (+)将画笔、直线或形状轮廓的宽度增加一个像素<br>Ctrl + 减号 (-)将画笔、直线或形状轮廓的宽度减少一个像素<br>Ctrl + Page Up放大<br>Ctrl + Page Down缩小<br>Alt + F4关闭图片及其“画图”窗口<br>向右键将选择内容或活动形状向右移动一个像素<br>向左键将选择内容或活动形状向左移动一个像素<br>向下键将选择内容或活动形状向下移动一个像素<br>向上键将选择内容或活动形状向上移动一个像素<br>Shift + F10显示上下文菜单</p><h1 id="“照片”键盘快捷方式"><a href="#“照片”键盘快捷方式" class="headerlink" title="“照片”键盘快捷方式"></a>“照片”键盘快捷方式</h1><p>空格键（在“集锦”中）选择项目并进入选择模式<br>Enter（从选择模式）在处于选择模式下时选择项目<br>空格键（查看照片）显示或隐藏命令<br>空格键（查看视频）播放或暂停视频<br>箭头键（在集锦中）向上、向下、向左或向右滚动<br>左箭头或右箭头键（位于单个项目或幻灯片放映上）显示下一个或上一个项目<br>箭头键（位于缩放的照片上）在照片内移动<br>Ctrl + 加号或减号（+ 或 -）放大或缩小（查看照片时）<br>Ctrl + 0重置照片的缩放<br>Esc返回到上一个屏幕<br>Ctrl + S保存<br>Ctrl + P打印<br>Ctrl + C复制<br>Ctrl + R（查看或编辑）旋转照片<br>E（查看照片）增强照片效果<br>Ctrl + Z（编辑）撤销更改<br>Ctrl + Y（编辑）恢复更改<br>Ctrl + /（编辑）查看原件<br>Shift + 箭头键调整裁剪或选择性对焦区域的大小<br>Ctrl + 箭头键移动裁剪或选择性对焦区域<br>F5（查看项目）开始幻灯片放映<br>Alt + Enter查看文件信息<br>Ctrl + L设置为锁屏界面<br>Ctrl + N（在“相册”视图中） 创建新相册<br>Ctrl + R（在“相册”视图中） 删除相册<br>Ctrl + D 将选定项添加到相册<br>Ctrl + U 从相册中删除选定项</p><h1 id="“写字板”键盘快捷方式"><a href="#“写字板”键盘快捷方式" class="headerlink" title="“写字板”键盘快捷方式"></a>“写字板”键盘快捷方式</h1><p>F3在“查找”对话框中搜索文本的下一个实例<br>F12将此文档另存为新文件<br>Ctrl + 1设置单倍行距<br>Ctrl + 2设置双倍行距<br>Ctrl + 5将行距设置为 1.5<br>Ctrl + A全选<br>Ctrl + B将所选文本改为粗体<br>Ctrl + C将选择内容复制到剪贴板<br>Ctrl + D插入 Microsoft 绘图<br>Ctrl + E向中心对齐文本<br>Ctrl + F在文档中搜索文本<br>Ctrl + H在文档中替换文本<br>Ctrl + I将所选文本改为斜体<br>Ctrl + J两端对齐文本<br>Ctrl + L向左对齐文本<br>Ctrl + N创建新文档<br>Ctrl + O打开现有文档<br>Ctrl + P打印文档<br>Ctrl + R向右对齐文本<br>Ctrl + S将更改保存到文档<br>Ctrl + U为所选文本添加下划线<br>Ctrl + V从剪贴板粘贴选择内容<br>Ctrl + X剪切选择内容<br>Ctrl + Y恢复更改<br>Ctrl + Z撤销更改<br>Ctrl + 等于号 (=)使所选文本成为下标<br>Ctrl + Shift + 等于号 (=)使所选文本成为上标<br>Ctrl + Shift + 大于号 (&gt;)增加字体大小<br>Ctrl + Shift + 小于号 (&lt;)减小字体大小<br>Ctrl + Shift + A将字符更改为全部使用大写字母<br>Ctrl + Shift + L更改项目符号样式<br>Ctrl + 向左键将光标向左移动一个字<br>Ctrl + 向右键将光标向右移动一个字<br>Ctrl + 向上键将光标移动到上一行<br>Ctrl + 向下键将光标移动到下一行<br>Ctrl + Home移动到文档的开头<br>Ctrl + End移动到文档的末尾<br>Ctrl + Page Up向上移动一个页面<br>Ctrl + Page Down向下移动一个页面<br>Ctrl + Delete删除下一个字<br>Alt + F4关闭“写字板”<br>Shift + F10显示上下文菜单<br>Windows 10 用于辅助功能的 Windows 键盘快捷方式<br>辅助功能快捷方式可帮助你将电脑与键盘或辅助设备结合使用。下面是 Windows 10 中辅助技术的键盘快捷方式列表，包括“放大镜”、“高对比度”等。</p><h1 id="“放大镜”键盘快捷方式"><a href="#“放大镜”键盘快捷方式" class="headerlink" title="“放大镜”键盘快捷方式"></a>“放大镜”键盘快捷方式</h1><p>Windows 徽标键 + 加号 (+) 或减号 (-)放大或缩小<br>Ctrl + Alt + 空格键以全屏模式预览桌面<br>Ctrl + ALT + D切换到停靠模式<br>Ctrl + ALT + F切换到全屏模式<br>Ctrl + ALT + I反色<br>Ctrl + ALT + L切换到镜头模式<br>Ctrl + ALT + R调整镜头大小<br>Ctrl + Alt + 箭头键按箭头键的方向平移<br>Windows 徽标键 + Esc退出“放大镜”</p><h1 id="其他辅助功能键盘快捷方式"><a href="#其他辅助功能键盘快捷方式" class="headerlink" title="其他辅助功能键盘快捷方式"></a>其他辅助功能键盘快捷方式</h1><p>按右 Shift 八秒钟打开和关闭筛选键<br>左 Alt + 左 Shift + Print Screen打开或关闭高对比度<br>左 Alt + 左 Shift + Num Lock打开或关闭鼠标键<br>按 Shift 五次打开或关闭粘滞键<br>按 Num Lock 五秒钟打开或关闭切换键<br>Windows 徽标键 + U打开“轻松使用设置中心”</p>]]></content>
      
      
      <categories>
          
          <category> 快捷键 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>白盒测试</title>
      <link href="/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95.html"/>
      <url>/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="什么是白盒测试"><a href="#什么是白盒测试" class="headerlink" title="什么是白盒测试"></a>什么是白盒测试</h1><p>定义：按照程序内部结构，逻辑驱动测试程序<br>目的：检测产品内部动作是否按照设计说明书的规范进行，检验程序的每条路径是否都能按照预定要求进行工作<br>对象：源程序<br>用代码内部的分支，路径，条件，使程序设计的控制结构导出测试用例</p><h1 id="白盒测试方法分类"><a href="#白盒测试方法分类" class="headerlink" title="白盒测试方法分类"></a>白盒测试方法分类</h1><p>①、静态测试<br>②、动态测试</p><h1 id="白盒测试的原则"><a href="#白盒测试的原则" class="headerlink" title="白盒测试的原则"></a>白盒测试的原则</h1><p>①、保证一个模块中所有路径至少被测试一次<br>②、所有逻辑值都要测试真和假两种情况<br>③、检查程序内部的数据结构是否有效<br>④、检查上下边界及可操作范围内运行所有循环</p><h1 id="白盒测试的类别"><a href="#白盒测试的类别" class="headerlink" title="白盒测试的类别"></a>白盒测试的类别</h1><p>①、软件共用问题的测试<br>②、语言测试<br>③、sql语句测试<br>④、数据类型测试<br>⑤、界面测试<br>⑥、数值队形测试<br>⑦、业务对象测试<br>⑧、数据管理对象测试</p><h1 id="白盒测试依据"><a href="#白盒测试依据" class="headerlink" title="白盒测试依据"></a>白盒测试依据</h1><p>①、软件需求报告<br>②、软件需求规格说明<br>③、程序设计文档<br>④、软件界面设计<br>⑤、编码规范<br>⑥、开发命名标准</p><h1 id="白盒测试流程"><a href="#白盒测试流程" class="headerlink" title="白盒测试流程"></a>白盒测试流程</h1><p>①、界面对象测试流程<br>界面对象（UI）→业务对象（BO）→数据管理对象（DMO）→DBserver端<br>②、业务对象测试流程<br>DBserver端→数据管理对象（DMO）→业务对象（BO）→界面对象（UI）</p><h1 id="白盒测试方法"><a href="#白盒测试方法" class="headerlink" title="白盒测试方法"></a>白盒测试方法</h1><p>①、尽量先用自动化工具来进行静态解析<br>②、建议先从静态测试开始（静态结构分析、代码走查、静态质量度量），然后进行动态测试（如覆盖率测试）<br>③、以静态分析结果作为依据，再使用代码检查和动态测试方法对静态分析结果进行进一步确认，提高测试效率及准确性<br>④、覆盖率测试是白盒测试的重要手段，在测试报告中可作为量化指标的依据，对于软件的重点模块，应使用多种覆盖率标准衡量代码的覆盖率</p><h1 id="代码检查"><a href="#代码检查" class="headerlink" title="代码检查"></a>代码检查</h1><p>概述：主要检查代码和流图设计的一致性、代码结构的合理性、代码编写的标准性、可读性、代码的逻辑表达的正确性等方面。包括变量检查、命名和类型审查、程序逻辑审查、<br>程序语法检查和程序结构检查等内容。</p><h2 id="目的："><a href="#目的：" class="headerlink" title="目的："></a>目的：</h2><p>①、检查代码是否按照某种标准或规范编写的代码<br>②、检查代码以发现程序缺陷<br>③、通过检查代码容易发现程序产生的错误<br>④、通过检查代码来发现代码是不是流程图要求的；<br>⑤、通过检查代码来发现有没有遗漏的项目；<br>⑥、要代码易于移植，代码经常需要在不同的硬件中运行，或者使用不同的编译器编译；<br>⑦、要代码易于阅读、理解和维护。</p><h2 id="方式："><a href="#方式：" class="headerlink" title="方式："></a>方式：</h2><p>①、桌面检查<br>②、走查<br>③、代码审查</p><h2 id="项目："><a href="#项目：" class="headerlink" title="项目："></a>项目：</h2><p>①、目录文件组织<br>②、检查函数<br>③、数据类型及变量<br>④、检查条件判断语句<br>⑤、检查循环体制<br>⑥、检查代码注释<br>⑦、桌面检查</p><h1 id="静态结构分析"><a href="#静态结构分析" class="headerlink" title="静态结构分析"></a>静态结构分析</h1><p>定义：主要以图形的方式表现程序的内部结构（例如函数调用关系图、函数内部控制流图）；通过应用程序各函数之间的调用关系展示了系统的结构，列出所有函数，用连线表示调用关系和作用。<br>主要分析：<br>①、可以检查函数的调用关系是否正确<br>②、是否存在孤立的函数而没有被调用<br>③、明确函数被调用的频繁度，对调用频繁的函数可以重点检查</p><h1 id="SQL语句测试"><a href="#SQL语句测试" class="headerlink" title="SQL语句测试"></a>SQL语句测试</h1><p>主要检查以下两点：<br>①、语句检查<br>②、类型转换</p><h1 id="代码检查的分析与评价"><a href="#代码检查的分析与评价" class="headerlink" title="代码检查的分析与评价"></a>代码检查的分析与评价</h1><p>主要注意以下两点：<br>①、能力（陈述经代码检查证实了的本软件的能力）<br>②、缺陷和限制</p><h1 id="白盒测试常用技术（7种）"><a href="#白盒测试常用技术（7种）" class="headerlink" title="白盒测试常用技术（7种）"></a>白盒测试常用技术（7种）</h1><h2 id="逻辑覆盖法"><a href="#逻辑覆盖法" class="headerlink" title="逻辑覆盖法"></a>逻辑覆盖法</h2><h3 id="测试覆盖率"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a>测试覆盖率</h3><p>用于确定测试所执行到的覆盖项的百分比；覆盖项指作为测试基础的一个入口或属性，比如语句、分支、条件等<br>测试覆盖率可表示出测试的充分性，在测试分析报告中可作为量化指标的依据，测试覆盖率越高效果越好。但覆盖率不是目标，只是一种手段。<br>测试覆盖率包括功能覆盖和结构覆盖：</p><h3 id="逻辑覆盖"><a href="#逻辑覆盖" class="headerlink" title="逻辑覆盖"></a>逻辑覆盖</h3><p>根据覆盖目标的不同和覆盖源程序语句的详尽程度，逻辑覆盖又可分为语句覆盖 、判定覆盖、条件覆盖、条件判定组合覆盖、多条件覆盖、修改条件判定覆盖、组合覆盖和路径覆盖。</p><h3 id="面向对象的覆盖"><a href="#面向对象的覆盖" class="headerlink" title="面向对象的覆盖"></a>面向对象的覆盖</h3><p>面向对象的覆盖主要讨论继承上下文覆盖和基于状态的上下文覆盖。</p><h3 id="测试覆盖准则"><a href="#测试覆盖准则" class="headerlink" title="测试覆盖准则"></a>测试覆盖准则</h3><p>测试覆盖准则主要讨论（ESTCA）错误敏感测试用例分析和(LCSAJ)线性代码序列与跳转。<br>（1）ESTCA覆盖准则<br>（2）现行代码序列与跳转LCSAJ线性代码序列与条状LCSAJ是指一组顺序执行的代码，以控制流跳转为结束点。可产生4层覆盖</p><h2 id="插桩技术"><a href="#插桩技术" class="headerlink" title="插桩技术"></a>插桩技术</h2><p>插桩测试是一个被广泛应用的测试方法。插桩测试就是向源程序中插入语句然后执行程序，通过打印语句，获得动态信息（我们最为关心的信息）</p><h2 id="基本路径测试法"><a href="#基本路径测试法" class="headerlink" title="基本路径测试法"></a>基本路径测试法</h2><p>基本路径测试法是在程序控制流图的基础上，通过分析控制构造的环路复杂性，导出基本可执行路径集合，从而设计测试用例的方法。设计出的测试用例要保证在测试中程序的<br>每个可执行语句至少执行一次。重点内容如下：<br>程序的控制流图：描述程序控制流的一种图示方法。<br>程序环形复杂度：McCabe复杂性度量。从程序的环路复杂性可导出程序基本路径集合中的独立路径条数，这是确定程序中每个可执行语句至少执行一次所必须的测试用例数目的上界。</p><h2 id="程序控制流图"><a href="#程序控制流图" class="headerlink" title="程序控制流图"></a>程序控制流图</h2><p>程序控制流图（可简称流图）是对程序流程图进行简化后得到的，它突出表示程序控<br>制流的结构。程序控制流图是描述程序控制流的一种方式。控制流图图形符号；<br>图形符号：圆圈代表一个结点， 表示一个或多个无分支的语句或源程序语句；<br>程序控制流边和点圈定的部分叫做区域。当对区域计数时，图形外的一个部分也应记为一个区域；<br>判断语句中的条件为复合条件时，即条件表达式由一个或多个逻辑运算符连接的逻辑表达式（a and b），则需要改变复合条件的判断为一系列只有单个条件的嵌套的判断。<br>基本路径测试方法是在控制流图的基础上，通过分析控制结构的环形复杂度，导出执行路径的基本集，再从该基本集设计测试用例。基本路径测试方法包括以下4个步骤：<br>3.1.1画出程序的控制流图。<br>3.1.2计算程序的环形复杂度，导出程序基本路径集中的独立路径条数，这是确定程序中每个可执行语句至少执行一次所必须的测试用例数目的上界。<br>3.1.3导出基本路径集，确定程序的独立路径。<br>3.1.4根据③中的独立路径，设计测试用例的输入数据和预期输出。<br>•    程序环路复杂性计算方法（三种）：<br>•    (1)流图中区域的数量对应于环形复杂度<br>•    (2)给定流图G的环形复杂度V(G),定义为V(G)=E-N+2, E是流图中边的数量，N是流图中节点的数量。<br>•    (3)  V(G)=P+1, P是流图G中的判定节点数。</p><h2 id="域测试法"><a href="#域测试法" class="headerlink" title="域测试法"></a>域测试法</h2><p>域测试是一种基于程序结构的测试方法，基于对程序输入空间（域）的分析，选择测试点进行测试。主要为：<br>4.1域错误：程序的控制流存在错误，对于某一特定的输入可能执行的是一条错误路径，这种错误称为路径错误，也叫做域错误；<br>4.2 计算型错误：对于特定输入执行的路径正确，但赋值语句的错误导致输出结果错误，称为计算型错误；<br>4.3丢失路径错误：由于程序中的某处少了一个判定谓词而引起的丢失路径错误</p><h2 id="符号测试"><a href="#符号测试" class="headerlink" title="符号测试"></a>符号测试</h2><p>符号测试基本思想是允许程序的输入不仅仅是具体的数值数据，而且包括符号值，符号值可以是基本的符号变量值，也可以是符号变量值的表达式<br>5.1符号测试执行的是代数运算，可以作为普通测试的一个扩充；<br>5.2符号测试可以看作是程序测试和程序验证的一个折衷办法；<br>5.3 符号测试程序中仅有有限的几条执行路径；</p><h2 id="Z路径覆盖法"><a href="#Z路径覆盖法" class="headerlink" title="Z路径覆盖法"></a>Z路径覆盖法</h2><p>分析程序中的路径是指检验程序从入口开始，执行过程中经历的各个语句，直到出口。<br>Z路径覆盖对循环机制进行简化，减少路径的数量，使得覆盖所有路径成为可能，简化循环意义下的路径覆盖称为Z路径覆盖；<br>循环简化：限制循环次数，只考虑循环一次或零次情况；<br>循环简化的目的是限制循环的次数，无论循环的形式和循环体实际执行的次数，简化后的循环测试只考虑执行循环体一次和零次（不执行）两种情况，即考虑执行时进入循环体<br>一次和跳过循环体这两种情况。</p><h2 id="程序变异测试法"><a href="#程序变异测试法" class="headerlink" title="程序变异测试法"></a>程序变异测试法</h2><p>程序变异是一种错误驱动测试。错误驱动测试是指该方法是针对某类特定程序错误的，要想找出程序中所有的错误几乎是不可能的，解决办法是将错误的搜索范围尽可能地缩小，<br>以利于专门测试某类错误是否存在。</p><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/05/02/PSB2qlRMjD8AY9H.png"  alt="白盒测试.png"></p><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/05/02/Vi1gpQTLqShwzRu.png"  alt="白盒测试1.png"><br>1或0（默认表达方式，Default）<br>  1代表真   0代表假<br>Y或N<br>  Y=Yes代表真  N=No代表假<br>T或F<br>  T=True代表真  F=False代表假<br>4种原因与结果的关系<br><img src="/" class="lazyload" data-src="https://i.loli.net/2020/05/02/lEu31pqiJzXsVnd.png"  alt="白盒测试2.png"></p><p>4种原因与原因的约束<br><img src="/" class="lazyload" data-src="https://i.loli.net/2020/05/02/Vi1gpQTLqShwzRu.png"  alt="白盒测试1.png"></p><p>E约束（排他性约束、Exclusive）：C1和C2中最多有一个可能为1，即C1和C2不能同时为1</p><p>I约束（包含性约束, Inclusive）：： C1、C2、C3中至少有一个必须是1，即： C1、C2、C3不能同时为0</p><p>O约束（唯一性约束, Only）：C1和C2必须有一个且仅有一个为1</p><p>R约束（必要性约束, Request）：： C1是1时，C2必须是1</p><p>M约束（强制约束，Masking）：：唯一的针对结果的约束；若结果E1是1，则结果E2强制为0<br>判定表法Decision Table Method：<br>判定表是分析和表达多种输入条件下系统执行不同动作的工具，它可以把复杂的逻辑关系和多种条件组合的情况表达得既准确又明确。<br>   一般情况下，我们在画出因果图后写出判定表，两者绑定使用。但是无论是因果图法也好，判定表法也好，它们两者都是可以单独使用的。<br>   根据个人喜好，熟练了以后，可以考虑直接使用判定表法，省去画图步骤（Normally）。<br>因果图+判定表的经验结论</p><h2 id="判定表法的优点："><a href="#判定表法的优点：" class="headerlink" title="判定表法的优点："></a>判定表法的优点：</h2><p>1、充分考虑了输入条件间的组合，对组合情况覆盖充分；<br>2、最终每个用例覆盖多种输入情况，有利于提高测试效率；<br>3、设计过程中，对输入条件间的约束关系做了考虑，避免了无效用例，用例的有效性高；<br>4、能同时得出每个测试项的预期输出。</p><h2 id="判定表法的缺点："><a href="#判定表法的缺点：" class="headerlink" title="判定表法的缺点："></a>判定表法的缺点：</h2><p>1、当被测试特性输入较多时，会造成判定表规格过于庞大；<br>2、输入之间的约束条件不能有效区分输入是否确实需要进行组合测试，会造成不需要组合测试的输入做了组合，从而产生用例冗余。</p><h2 id="场景法"><a href="#场景法" class="headerlink" title="场景法"></a>场景法</h2><p>软件几乎都是用事件触发来控制流程的，事件触发时的情景便形成了场景，而同一事件不同的触发顺序和处理结果就形成事件流<br>现在的场景法就是测试用例设计脑图，人称XMind</p><h2 id="错误推测法"><a href="#错误推测法" class="headerlink" title="错误推测法"></a>错误推测法</h2><p>任何有意义的错误推测都值得单独写一条测试用例，一般情况下，推测开发需求中没有明确指明的，错误推测法很随意，就是个头脑风暴</p><p>语句覆盖（每一可执行语句至少执行一次。即执行判定为真的语句）</p><p>判定覆盖（程序中每个判断的取真分支和取假分支至少经历一次。即全真和全假的情况都执行一次）</p><p>条件覆盖（每个判断的每个条件的可能取值至少执行一次。即至少执行一次判断为真的情况，但不要求将所有判定为真的情况都写出来）<br>条件覆盖不一定包含判定覆盖。条件覆盖只能保证每个条件至少有一次为真，而不考虑所有的判定结果</p><p>判定/条件覆盖（判断中每个条件的所有可能取值至少执行一次，同时每个判定的可能结果也至少出现一次。即全真和全假两种情况）</p><p>条件组合覆盖（每个判断的所有可能的条件取值组合至少执行一次。）</p><p>路径覆盖（覆盖程序中所有可能的路径）</p>]]></content>
      
      
      <categories>
          
          <category> 白盒测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 白盒测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黑盒测试</title>
      <link href="/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95.html"/>
      <url>/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>黑盒测试又叫功能测试、数据驱动测试或基于需求规格说明书的功能测试。该类测试注重于测试软件的功能性需求。<br>采用这种测试方法，完全不考虑程序内部的逻辑结构和内部特性，只依据程序的《需求规格说明书》，检查程序的功能是否符合它的功能说明。测试工程师无需了解程序代码的内部构造，完全模拟软件产品的最终用户使用该软件，检查软件产品是否达到了用户的需求。黑盒测试方法能更好、更真实地从用户角度来考察被测系统的功能性需求实现情况。</p><h1 id="黑盒测试的目的"><a href="#黑盒测试的目的" class="headerlink" title="黑盒测试的目的"></a>黑盒测试的目的</h1><p>①、是否有不正确或者遗漏的功能<br>②、界面是否有误<br>③、接口上，输入输出是否正确<br>④、是否有数据结构错误或者外部数据库访问错误<br>⑤、性能是否满足要求<br>⑥、初始化或者终止性错误</p><h1 id="黑盒测试的优点"><a href="#黑盒测试的优点" class="headerlink" title="黑盒测试的优点"></a>黑盒测试的优点</h1><p>①、最大程度满足用户需求<br>②、相同动作可重复执行，枯燥部分可由机器完成<br>③、根据测试用例针对性的寻找问题，定位更准确，容易生成测试数据<br>④、测试直接和程序/系统要完成的操作相关联</p><h1 id="黑盒测试的缺点"><a href="#黑盒测试的缺点" class="headerlink" title="黑盒测试的缺点"></a>黑盒测试的缺点</h1><p>①、代码得不到测试<br>②、如果规格设计错误，很难发现<br>③、测试不能充分进行<br>④、结果取决于测试用例的设计</p><h1 id="设计用例的策略"><a href="#设计用例的策略" class="headerlink" title="设计用例的策略"></a>设计用例的策略</h1><p>①、首先进行等价类划分，包括输入和输出条件，减少工作量提高效率<br>②、边界值分析，发现错误的能力最强<br>③、错误推断法，补充用例（这个凭经验）<br>④、对照需求和业务场景逻辑，检查用例<br>⑤、如果需求说明含有输入条件，设计开始就用到因果图和判定表驱动法<br>⑥、参数配置类的软件，要用正交实验法<br>⑦、功能图法，不同时期条件的有效性来设计数据<br>⑧、业务流清晰的系统，采用场景法</p><h1 id="黑盒测试的原则"><a href="#黑盒测试的原则" class="headerlink" title="黑盒测试的原则"></a>黑盒测试的原则</h1><p>1、根据需求和规格要求，明确产品要求的正确性<br>2、针对性的找问题，正确定位<br>3、根据需求重要性确定测试等级和重点，减少缺陷<br>4、接口处，输入是否能正确接收，输出是否正确<br>5、站在用户角度思考，测试</p><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>黑盒测试方法着重测试软件的功能需求，是在程序接口上进行的测试，主要是为了发现以下错误。<br>(1)是否有功能错误，是否有功能遗漏。<br>(2)是否能够正确地接收输入数据并产生正确的输出结果。<br>(3)是否有数据结构错误或外部信息访问错误。<br>(4)是否有程序初始化和终止方面的错误。</p><h1 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h1><p>从理论上讲，黑盒测试只有采用穷举输入测试，把所有可能的输入都作为测试情况考虑，才能查出程序中所有的错误。实际上测试情况有无穷多个，人们不仅要测试所有合法的输入，而且还要对那些不合法但可能的输入进行测试。这样看来，完全测试是不可能的，所以我们要进行有针对性的测试，通过制定测试案例指导测试的实施，保证软件测试有组织、按步骤，以及有计划地进行。黑盒测试行为必须能够加以量化，才能真正保证软件质量，而测试用例就是将测试行为具体量化的方法之一。具体的黑盒测试用例设计方法包括等价类划分法、边界值分析法、错误推测法、因果图法、判定表驱动法、正交试验设计法、功能图法、场景法等。<br>等价类划分的办法是把程序的输入域划分成若干部分（子集），然后从每个部分中选取少数代表性数据作为测试用例。每一类的代表性数据在测试中的作用等价于这一类中的其他值。该方法是一种重要的，常用的黑盒测试用例设计方法。</p><h2 id="划分等价类"><a href="#划分等价类" class="headerlink" title="划分等价类"></a>划分等价类</h2><p>等价类是指某个输入域的子集合。在该子集合中，各个输入数据对于揭露程序中的错误都是等效的，并合理地假定：测试某等价类的代表值就等于对这一类其它值的测试.因此，可以把全部输入数据合理划分为若干等价类，在每一个等价类中取一个数据作为测试的输入条件，就可以用少量代表性的测试数据.取得较好的测试结果.等价类划分可有两种不同的情况：有效等价类和无效等价类。<br>有效等价类：是指对于程序的规格说明来说是合理的，有意义的输入数据构成的集合.利用有效等价类可检验程序是否实现了规格说明中所规定的功能和性能。<br>无效等价类：与有效等价类的定义恰巧相反。<br>设计测试用例时，要同时考虑这两种等价类.因为，软件不仅要能接收合理的数据，也要能经受意外的考验.这样的测试才能确保软件具有更高的可靠性。<br>划分等价类的方法：下面给出六条确定等价类的原则。<br>①在输入条件规定了取值范围或值的个数的情况下，则可以确立一个有效等价类和两个无效等价类。<br>②在输入条件规定了输入值的集合或者规定了“必须如何”的条件的情况下，可确立一个有效等价类和一个无效等价类。<br>③在输入条件是一个布尔量的情况下，可确定一个有效等价类和一个无效等价类。<br>④在规定了输入数据的一组值（假定n个），并且程序要对每一个输入值分别处理的情况下，可确立n个有效等价类和一个无效等价类。<br>⑤在规定了输入数据必须遵守的规则的情况下，可确立一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则）。<br>⑥在确知已划分的等价类中各元素在程序处理中的方式不同的情况下，则应再将该等价类进一步的划分为更小的等价类。</p><h2 id="边界值分析法"><a href="#边界值分析法" class="headerlink" title="边界值分析法"></a>边界值分析法</h2><p>边界值分析是通过选择等价类边界的测试用例。边界值分析法不仅重视输入条件边界，而且也必须考虑输出域边界。它是对等价类划分方法的补充。<br>（1）边界值分析方法的考虑：<br>长期的测试工作经验告诉我们，大量的错误是发生在输入或输出范围的边界上，而不是发生在输入输出范围的内部.因此针对各种边界情况设计测试用例，可以查出更多的错误。<br>使用边界值分析方法设计测试用例，首先应确定边界情况.通常输入和输出等价类的边界，就是应着重测试的边界情况.应当选取正好等于，刚刚大于或刚刚小于边界的值作为测试数据，而不是选取等价类中的典型值或任意值作为测试数据。<br>（2）基于边界值分析方法选择测试用例的原则：<br>1）如果输入条件规定了值的范围，则应取刚达到这个范围的边界的值，以及刚刚超越这个范围边界的值作为测试输入数据。<br>2）如果输入条件规定了值的个数，则用最大个数，最小个数，比最小个数少一，比最大个数多一的数作为测试数据。<br>3）根据规格说明的每个输出条件，使用前面的原则1）。<br>4）根据规格说明的每个输出条件，应用前面的原则2）。<br>5）如果程序的规格说明给出的输入域或输出域是有序集合，则应选取集合的第一个元素和最后一个元素作为测试用例。<br>6）如果程序中使用了一个内部数据结构，则应当选择这个内部数据结构的边界上的值作为测试用例。<br>7）分析规格说明，找出其它可能的边界条件。</p><h2 id="错误推测法"><a href="#错误推测法" class="headerlink" title="错误推测法"></a>错误推测法</h2><p>错误推测法是基于经验和直觉推测程序中所有可能存在的各种错误，从而有针对性的设计测试用例的方法。<br>错误推测方法的基本思想： 列举出程序中所有可能有的错误和容易发生错误的特殊情况，根据他们选择测试用例。 例如，在单元测试时曾列出的许多在模块中常见的错误。以前产品测试中曾经发现的错误等，这些就是经验的总结。还有，输入数据和输出数据为0的情况。 输入表格为空格或输入表格只有一行. 这些都是容易发生错误的情况。可选择这些情况下的例子作为测试用例。</p><h2 id="因果图法"><a href="#因果图法" class="headerlink" title="因果图法"></a>因果图法</h2><p>前面介绍的等价类划分方法和边界值分析方法，都是着重考虑输入条件，但未考虑输入条件之间的联系，相互组合等。 考虑输入条件之间的相互组合，可能会产生一些新的情况。但要检查输入条件的组合不是一件容易的事情，即使把所有输入条件划分成等价类，他们之间的组合情况也相当多。因此必须考虑采用一种适合于描述对于多种条件的组合，相应产生多个动作的形式来考虑设计测试用例，这就需要利用因果图（逻辑模型）。<br>因果图方法最终生成的就是判定表。它适合于检查程序输入条件的各种组合情况。<br>生成测试用例：<br>(1) 分析软件规格说明描述中，哪些是原因（即输入条件或输入条件的等价类），哪些是结果（即输出条件），并给每个原因和结果赋予一个标识符。<br>(2) 分析软件规格说明描述中的语义。找出原因与结果之间，原因与原因之间对应的关系. 根据这些关系，画出因果图。<br>(3) 由于语法或环境限制，有些原因与原因之间，原因与结果之间的组合情况不可能出现. 为表明这些特殊情况，在因果图上用一些记号标明约束或限制条件。<br>(4) 把因果图转换为判定表。<br>(5) 把判定表的每一列拿出来作为依据，设计测试用例。<br>从因果图生成的测试用例（局部，组合关系下的）包括了所有输入数据的取TRUE与取FALSE的情况，构成的测试用例数目达到最少，且测试用例数目随输入数据数目的增加而线性地增加。<br>前面因果图方法中已经用到了判定表。判定表（Decision Table）是分析和表达多逻辑条件下执行不同操作的情况下的工具.在程序设计发展的初期，判定表就已被当作编写程序的辅助工具了.由于它可以把复杂的逻辑关系和多种条件组合的情况表达得既具体又明确。 [2] </p><h2 id="判定表组成法"><a href="#判定表组成法" class="headerlink" title="判定表组成法"></a>判定表组成法</h2><p>条件桩（Condition Stub）：列出了问题的所有条件.通常认为列出的条件的次序无关紧要。<br>动作桩（Action Stub）：列出了问题规定可能采取的操作.这些操作的排列顺序没有约束。<br>条件项（Condition Entry）：列出针对它左列条件的取值.在所有可能情况下的真假值。 [2]<br>动作项（Action Entry）：列出在条件项的各种取值情况下应该采取的动作。 [2]<br>规则：任何一个条件组合的特定取值及其相应要执行的操作.在判定表中贯穿条件项和动作项的一列就是一条规则.显然，判定表中列出多少组条件取值，也就有多少条规则，既条件项和动作项有多少列。<br>判定表的建立步骤：<br>①确定规则的个数。假如有n个条件.每个条件有两个取值（0，1），故有2n种规则。<br>②列出所有的条件桩和动作桩。<br>③填入条件项。<br>④填入动作项.等到初始判定表。<br>⑤简化.合并相似规则（相同动作）。<br>B. Beizer 指出了适合使用判定表设计测试用例的条件：<br>①规格说明以判定表形式给出，或很容易转换成判定表。<br>②条件的排列顺序不会也不影响执行哪些操作。<br>③规则的排列顺序不会也不影响执行哪些操作。<br>④每当某一规则的条件已经满足，并确定要执行的操作后，不必检验别的规则。<br>⑤如果某一规则得到满足要执行多个操作，这些操作的执行顺序无关紧要。</p><h2 id="正交试验设计"><a href="#正交试验设计" class="headerlink" title="正交试验设计"></a>正交试验设计</h2><p>就是使用已经造好了的正交表格来安排试验并进行数据分析的一种方法，目的是用最少的测试用例达到最高的测试覆盖率。</p><h2 id="场景法"><a href="#场景法" class="headerlink" title="场景法"></a>场景法</h2><p>软件几乎都是用事件触发来控制流程的，事件触发的情景<br> <img src="/" class="lazyload" data-src="https://i.loli.net/2020/05/01/jUcub3dlCFTpRZs.jpg"  alt="黑盒测试.jpg"><br>便形成了场景，而同一事件不同的触发顺序和处理结果就形成事件流。这种在软件设计方面的思想也可以引入到软件测试中，可以比较生动地描绘出事件触发时的情景，有利于测试设计者设计测试用例，同时使测试用例更容易理解和执行。<br>基本流和备选流：如下图所示，图中经过用例的每条路径都用基本流和备选流来表示，直黑线表示基本流，是经过用例的最简单的路径。备选流用不同的色彩表示，一个备选流可能从基本流开始，在某个特定条件下执行，然后重新加入基本流中（如备选流1和3）；也可能起源于另一个备选流（如备选流2），或者终止用例而不再重新加入到某个流（如备选流2和4）。</p><h2 id="功能图法"><a href="#功能图法" class="headerlink" title="功能图法"></a>功能图法</h2><p>用功能图（流程图）形象的表达操作流（状态迁移图+布尔函数组成）<br>需要依靠判定表因果图表示逻辑，是黑盒+白盒混合用例的设计方法</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>1）准备工作<br>    用Java语言编写一个求一元二次方程的求解程序program1，一元二次方程的系数取整数。<br>    画出程序program1的控制流图<br>2）实验内容与步骤<br> 第一步：确定测试策略。在本例中，对被测程序的功能有明确的要求，即：<br>    （1）判断是否组成一元二次方程；<br>    （2）求解两个相等实根；<br>    （3）求解两个不相等实根；<br>    （4）求解虚根；<br>Public static float Function(int a,int b,int c){</p><p>}<br>写出源程序，并画出控制流图。<br>第二步：首先用黑盒法设计测试用例，然后用白盒法验证其覆盖性，必要时再进行补充。根据本例的实际情况，可用等价分类法划分输入的等价类，然后用错误推测法作补充。<br>等价分类法：有效等价类、无效等价类<br><img src="/" class="lazyload" data-src="https://i.loli.net/2020/05/01/d3BvEhwp2eZYk4g.png"  alt="Annotation 2020-05-01 232304.png"></p><p>测试用例<br><img src="/" class="lazyload" data-src="https://i.loli.net/2020/05/01/d1BlDLI2GJR3Qjw.png"  alt="Annotation 2020-05-01 232504.png"></p><p>第三步：用白盒法验证第二步产生的测试用例的充分性，看是否满足对被测程序图的完全覆盖。<br><img src="/" class="lazyload" data-src="https://i.loli.net/2020/05/01/Igt89Q3bEASeKHm.png"  alt="Annotation 2020-05-01 232621.png"></p><p>最后，结出结论。</p><h3 id="程序："><a href="#程序：" class="headerlink" title="程序："></a>程序：</h3><p>//求解一元二次方程 ax^2+bx+c=0 的实根和复根， Test类是主类<br>import java.lang.Math;           //math头文件<br>import java.util.Scanner;        //scanner头文件<br>class OnceBasicQuadraticEquation //求解一元二次方程 ax^2+bx+c 的实根和复根的类，其中 getRoot()方法求根和显 示根<br>{<br>private double a; //方程的二次项系数<br>private double b; //方程的一次项系数<br>private static double c; //方程的常数项 //以上三个成员变量分别是方程的系数<br>OnceBasicQuadraticEquation() //无参构造方法<br>{<br>a = 0;<br>b = 0;<br>c = 0;<br>}<br>OnceBasicQuadraticEquation(double a,double b,double c) //有参构造方法<br>{<br>this.a = a;<br>this.b = b;<br>this.c = c;<br>}<br>public void setA(double a)<br>{<br>this.a = a;<br>}<br>public double getA()<br>{<br>return a;<br>}<br>public void setB(double b)<br>{<br>this.b = b;<br>}<br>public double getB()<br>{<br>return b;<br>}<br>public void setC(double c)<br>{<br>this.c = c;<br>}<br>public double getC()<br>{<br>return c;<br>} //以上六个方法分别对应三个系数的置取方法<br>public double getDlt() //计算判别式 Δ=b^2-4ac 的值<br>{<br>double result = Math.pow(b,2) - 4 * a * c;<br>return result;<br>}<br>private double getRightRoot() //求解右侧较大实根的方法<br>{<br>double rightRoot = 0;<br>rightRoot = (-b + Math.sqrt(getDlt())) / (2 * a);<br>return rightRoot;<br>}<br>private double getLeftRoot() //求解左侧较小实根的方法<br>{<br>double leftRoot = 0;<br>leftRoot = (- b - Math.sqrt(getDlt())) / (2 * a);<br>return leftRoot;<br>}<br>public void getRoot() //求解并显示实根或复根的方法<br>{<br>if(a==0)<br>{<br>if(b==0)<br>{<br>if(c==0)<br>{<br>System.out.println(“ 一元二次方程： “ + getA() + “x^2+”+ getB() + “x+” + getC() + “\t 有无穷多解。 “);<br>//a、b、c 全为零时，定义方程有无穷多解。</p><p>}<br>else<br>{<br>//二次项和一次项系数为零，但常数项不为零，方程变为不等式，无解。<br>    System.out.println(“ 一元二次方程： “ + getA() + “x^2+” + getB() + “x+” + getC() + “\t 无解。 “);<br>}<br>}<br>else<br>{<br>//二次项系数为零，一次项系数不为零，方程是一次方程，有唯一解。<br>double result = 0;<br>result = -getC() / getB();<br>System.out.println(“ 一元二次方程： “ + getA() + “x^2+” + getB() + “x+” + getC() + “\t 有唯一解： “ + result);<br>}<br>} else //二次项系数不为零，方程有两个实根或复根。<br>    {<br>    if(getDlt()==0) //判别式 Δ=b^2-4ac=0，方程有两个相等实根。<br>{<br>double result = 0;<br>result = -getB() / (2 * getA());<br>System.out.println(“ 一元二次方程： “ + getA() + “x^2+” + getB() + “x+” + getC() + “\t 有唯一解： “ + result);<br>}<br>    else if(getDlt()&gt;0) //判别式 Δ=b^2-4ac&gt;0 ，方程有两个相异实根。<br>        {<br>        System.out.println(“ 一元二次方程： “ + getA() + “x^2+” + getB() + “x+” + getC() + “\t 有两个实根： “ + getLeftRoot() + “ 和” + getRightRoot());<br>} else //判别式 Δ=b^2-4ac&lt;0 ，方程有两个复根。<br>    {<br>//double imaginaryNumber1 = 0;<br>double imaginaryNumber = 0;<br>double realNumber = 0;<br>imaginaryNumber = Math.sqrt(-getDlt()) / (2 * a);<br>realNumber = -getB() / (2 * a); System.out.println(“ 一元二次方程： “ + getA() + “x^2+” + getB() + “x+” + getC() + “\t 有两个复根： “ + realNumber + “ ±” + imaginaryNumber + “i”);<br>}<br>}<br>}<br>}<br>public class Test<br>{<br>public static void main(String [] args)<br>{<br>    double a,b,c;<br>    System.out.println(“请输入参数a b c :”);<br>    Scanner sc = new Scanner(System.in);<br>        a = sc.nextInt();<br>    b = sc.nextInt();<br>    c = sc.nextInt();</p><p>OnceBasicQuadraticEquation e1 = new OnceBasicQuadraticEquation(a,b,c);<br>e1.getRoot();<br>}<br>}</p><p>流程图：</p>]]></content>
      
      
      <categories>
          
          <category> 黑盒测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 黑盒测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>proxy</title>
      <link href="/proxy.html"/>
      <url>/proxy.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="代理相关"><a href="#代理相关" class="headerlink" title="代理相关"></a>代理相关</h1><ul><li><a href="#%e4%bb%a3%e7%90%86%e7%9b%b8%e5%85%b3">代理相关</a><ul><li><a href="#yarn-%e7%9a%84%e4%bb%a3%e7%90%86">yarn 的代理</a></li><li><a href="#git-%e7%9a%84%e4%bb%a3%e7%90%86">Git 的代理</a><ul><li><a href="#http-%e4%bb%a3%e7%90%86">HTTP 代理</a></li></ul></li><li><a href="#ssh-%e7%9a%84%e4%bb%a3%e7%90%86">SSH 的代理</a><ul><li><a href="#http-%e4%bb%a3%e7%90%86-1">HTTP 代理</a></li></ul></li><li><a href="#%e9%85%8d%e7%bd%ae%e5%ae%8c%e6%88%90">配置完成</a></li><li><a href="#%e5%8f%96%e6%b6%88%e4%bb%a3%e7%90%86">取消代理</a></li></ul></li></ul><h2 id="yarn-的代理"><a href="#yarn-的代理" class="headerlink" title="yarn 的代理"></a>yarn 的代理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn config <span class="built_in">set</span> proxy http://127.0.0.1:7890</span><br><span class="line">yarn config <span class="built_in">set</span> https-proxy http://127.0.0.1:7890</span><br></pre></td></tr></table></figure><blockquote><p>解释：实际上修改的是 <code>~/.yarnrc</code> 文件</p></blockquote><h2 id="Git-的代理"><a href="#Git-的代理" class="headerlink" title="Git 的代理"></a>Git 的代理</h2><h3 id="HTTP-代理"><a href="#HTTP-代理" class="headerlink" title="HTTP 代理"></a>HTTP 代理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.https://github.com.proxy http://127.0.0.1:7890</span><br></pre></td></tr></table></figure><blockquote><p>解释：实际上修改的是 <code>~/.gitconfig</code> 文件</p></blockquote><h2 id="SSH-的代理"><a href="#SSH-的代理" class="headerlink" title="SSH 的代理"></a>SSH 的代理</h2><h3 id="HTTP-代理-1"><a href="#HTTP-代理-1" class="headerlink" title="HTTP 代理"></a>HTTP 代理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.ssh/config</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">    User git</span><br><span class="line">    ProxyCommand connect -H 127.0.0.1:7890 %h %p</span><br></pre></td></tr></table></figure><h2 id="配置完成"><a href="#配置完成" class="headerlink" title="配置完成"></a>配置完成</h2><p><strong>注意：要重启终端</strong></p><h2 id="取消代理"><a href="#取消代理" class="headerlink" title="取消代理"></a>取消代理</h2><p>当你没使用代理软件的时候如果直接使用 yarn、Git、ssh 会报错，所以最好的做法就是使用这些工具的时候<del>翻墙</del>，如果不翻墙的时候就把修改的文件内容注释掉即可（我没想错的话就是在相应行的开头加上 <code>#</code> 这个符号）</p>]]></content>
      
      
      <categories>
          
          <category> 代理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo命令总结</title>
      <link href="/hexo-commands.html"/>
      <url>/hexo-commands.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><img src="/" class="lazyload" data-src="hexo-commands/1.png"  alt="图片测试"></p><p>Test again</p><hr><pre><code>参数            描述        默认值layout            布局    title            标题    date          建立日期          文件建立日期updated      更新日期        文件更新日期comments   开启文章的评论功能      truetags       标签（不适用于分页）    categories    分类（不适用于分页）    permalink    覆盖文章网址</code></pre><a id="more"></a><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a><a href="https://guardianss.github.io/2019/04/17/hexo%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#Quick-Start" title="Quick Start"></a>Quick Start</h2><h3 id="version—–显示-Hexo-版本"><a href="#version—–显示-Hexo-版本" class="headerlink" title="version—–显示 Hexo 版本"></a><a href="https://guardianss.github.io/2019/04/17/hexo%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#version%E2%80%94%E2%80%93%E6%98%BE%E7%A4%BA-Hexo-%E7%89%88%E6%9C%AC" title="version—–显示 Hexo 版本"></a>version—–显示 Hexo 版本</h3><pre><code>$ hexo version</code></pre><h3 id="安全模式——在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行"><a href="#安全模式——在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行" class="headerlink" title="安全模式——在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行"></a><a href="https://guardianss.github.io/2019/04/17/hexo%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#%E5%AE%89%E5%85%A8%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%9C%A8%E5%AE%89%E5%85%A8%E6%A8%A1%E5%BC%8F%E4%B8%8B%EF%BC%8C%E4%B8%8D%E4%BC%9A%E8%BD%BD%E5%85%A5%E6%8F%92%E4%BB%B6%E5%92%8C%E8%84%9A%E6%9C%AC%E3%80%82%E5%BD%93%E6%82%A8%E5%9C%A8%E5%AE%89%E8%A3%85%E6%96%B0%E6%8F%92%E4%BB%B6%E9%81%AD%E9%81%87%E9%97%AE%E9%A2%98%E6%97%B6%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%B0%9D%E8%AF%95%E4%BB%A5%E5%AE%89%E5%85%A8%E6%A8%A1%E5%BC%8F%E9%87%8D%E6%96%B0%E6%89%A7%E8%A1%8C" title="安全模式——在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行"></a>安全模式——在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行</h3><pre><code>$ hexo --safe</code></pre><h3 id="Create-a-new-post———-创建新文章"><a href="#Create-a-new-post———-创建新文章" class="headerlink" title="Create a new post———-创建新文章"></a><a href="https://guardianss.github.io/2019/04/17/hexo%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#Create-a-new-post%E2%80%94%E2%80%94%E2%80%94-%E5%88%9B%E5%BB%BA%E6%96%B0%E6%96%87%E7%AB%A0" title="Create a new post———-创建新文章"></a>Create a new post———-创建新文章</h3><pre><code>$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server——————–运行服务器"><a href="#Run-server——————–运行服务器" class="headerlink" title="Run server——————–运行服务器"></a><a href="https://guardianss.github.io/2019/04/17/hexo%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#Run-server%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%93%E8%BF%90%E8%A1%8C%E6%9C%8D%E5%8A%A1%E5%99%A8" title="Run server——————–运行服务器"></a>Run server——————–运行服务器</h3><pre><code>$ hexo server 选项             描述 -p, --port    重设端口 -s, --static    只使用静态文件 -l, --log    启动日记记录，使用覆盖记录格式</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files———生成静态文件"><a href="#Generate-static-files———生成静态文件" class="headerlink" title="Generate static files———生成静态文件"></a><a href="https://guardianss.github.io/2019/04/17/hexo%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#Generate-static-files%E2%80%94%E2%80%94%E2%80%94%E7%94%9F%E6%88%90%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6" title="Generate static files———生成静态文件"></a>Generate static files———生成静态文件</h3><pre><code>$ hexo generate可以简写为  $ hexo g$ hexo -d-d, --deploy    文件生成后立即部署网站$ hexo -w-w, --watch    监视文件变动</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="clean——清除缓存文件-db-json-和已生成的静态文件-public-。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令"><a href="#clean——清除缓存文件-db-json-和已生成的静态文件-public-。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令" class="headerlink" title="clean——清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令"></a><a href="https://guardianss.github.io/2019/04/17/hexo%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#clean%E2%80%94%E2%80%94%E6%B8%85%E9%99%A4%E7%BC%93%E5%AD%98%E6%96%87%E4%BB%B6-db-json-%E5%92%8C%E5%B7%B2%E7%94%9F%E6%88%90%E7%9A%84%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6-public-%E3%80%82%E5%9C%A8%E6%9F%90%E4%BA%9B%E6%83%85%E5%86%B5%EF%BC%88%E5%B0%A4%E5%85%B6%E6%98%AF%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98%E5%90%8E%EF%BC%89%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%8F%91%E7%8E%B0%E6%82%A8%E5%AF%B9%E7%AB%99%E7%82%B9%E7%9A%84%E6%9B%B4%E6%94%B9%E6%97%A0%E8%AE%BA%E5%A6%82%E4%BD%95%E4%B9%9F%E4%B8%8D%E7%94%9F%E6%95%88%EF%BC%8C%E6%82%A8%E5%8F%AF%E8%83%BD%E9%9C%80%E8%A6%81%E8%BF%90%E8%A1%8C%E8%AF%A5%E5%91%BD%E4%BB%A4" title="clean——清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令"></a>clean——清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令</h3><pre><code>$ hexo clean</code></pre><h3 id="Deploy-to-remote-sites——-部署到远程站点"><a href="#Deploy-to-remote-sites——-部署到远程站点" class="headerlink" title="Deploy to remote sites——-部署到远程站点"></a><a href="https://guardianss.github.io/2019/04/17/hexo%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#Deploy-to-remote-sites%E2%80%94%E2%80%94-%E9%83%A8%E7%BD%B2%E5%88%B0%E8%BF%9C%E7%A8%8B%E7%AB%99%E7%82%B9" title="Deploy to remote sites——-部署到远程站点"></a>Deploy to remote sites——-部署到远程站点</h3><pre><code>$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><h3 id="init————-新建一个网站"><a href="#init————-新建一个网站" class="headerlink" title="init————-新建一个网站"></a><a href="https://guardianss.github.io/2019/04/17/hexo%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#init%E2%80%94%E2%80%94%E2%80%94%E2%80%94-%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BD%91%E7%AB%99" title="init————-新建一个网站"></a>init————-新建一个网站</h3><pre><code>$ hexo init [folder]</code></pre><h3 id="list—–列出网站资料"><a href="#list—–列出网站资料" class="headerlink" title="list—–列出网站资料"></a><a href="https://guardianss.github.io/2019/04/17/hexo%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#list%E2%80%94%E2%80%93%E5%88%97%E5%87%BA%E7%BD%91%E7%AB%99%E8%B5%84%E6%96%99" title="list—–列出网站资料"></a>list—–列出网站资料</h3><pre><code>$ hexo list &lt;type&gt;</code></pre><h3 id="publish—————–发表草稿"><a href="#publish—————–发表草稿" class="headerlink" title="publish—————–发表草稿"></a><a href="https://guardianss.github.io/2019/04/17/hexo%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#publish%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%93%E5%8F%91%E8%A1%A8%E8%8D%89%E7%A8%BF" title="publish—————–发表草稿"></a>publish—————–发表草稿</h3><pre><code>$ hexo publish [layout] &lt;filename&gt;</code></pre><h3 id="自定义配置文件的路径—–自定义配置文件的路径，执行后将不再使用-config-yml"><a href="#自定义配置文件的路径—–自定义配置文件的路径，执行后将不再使用-config-yml" class="headerlink" title="自定义配置文件的路径—–自定义配置文件的路径，执行后将不再使用 _config.yml"></a><a href="https://guardianss.github.io/2019/04/17/hexo%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E8%B7%AF%E5%BE%84%E2%80%94%E2%80%93%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E8%B7%AF%E5%BE%84%EF%BC%8C%E6%89%A7%E8%A1%8C%E5%90%8E%E5%B0%86%E4%B8%8D%E5%86%8D%E4%BD%BF%E7%94%A8-config-yml" title="自定义配置文件的路径—–自定义配置文件的路径，执行后将不再使用 _config.yml"></a>自定义配置文件的路径—–自定义配置文件的路径，执行后将不再使用 _config.yml</h3><pre><code>$ hexo --config custom.yml</code></pre><h3 id="migrate——–从其他博客系统-迁移内容"><a href="#migrate——–从其他博客系统-迁移内容" class="headerlink" title="migrate——–从其他博客系统 迁移内容"></a><a href="https://guardianss.github.io/2019/04/17/hexo%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#migrate%E2%80%94%E2%80%94%E2%80%93%E4%BB%8E%E5%85%B6%E4%BB%96%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F-%E8%BF%81%E7%A7%BB%E5%86%85%E5%AE%B9" title="migrate——–从其他博客系统 迁移内容"></a>migrate——–从其他博客系统 迁移内容</h3><pre><code>$ hexo migrate &lt;type&gt;</code></pre><h3 id="分类和标签—–只有文章支持分类和标签，您可以在-Front-matter-中设置。在其他系统中，分类和标签听起来很接近，但是在-Hexo-中两者有着明显的差别：分类具有顺序性和层次性，也就是说-Foo-Bar-不等于-Bar-Foo；而标签没有顺序和层次。"><a href="#分类和标签—–只有文章支持分类和标签，您可以在-Front-matter-中设置。在其他系统中，分类和标签听起来很接近，但是在-Hexo-中两者有着明显的差别：分类具有顺序性和层次性，也就是说-Foo-Bar-不等于-Bar-Foo；而标签没有顺序和层次。" class="headerlink" title="分类和标签—–只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。"></a><a href="https://guardianss.github.io/2019/04/17/hexo%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#%E5%88%86%E7%B1%BB%E5%92%8C%E6%A0%87%E7%AD%BE%E2%80%94%E2%80%93%E5%8F%AA%E6%9C%89%E6%96%87%E7%AB%A0%E6%94%AF%E6%8C%81%E5%88%86%E7%B1%BB%E5%92%8C%E6%A0%87%E7%AD%BE%EF%BC%8C%E6%82%A8%E5%8F%AF%E4%BB%A5%E5%9C%A8-Front-matter-%E4%B8%AD%E8%AE%BE%E7%BD%AE%E3%80%82%E5%9C%A8%E5%85%B6%E4%BB%96%E7%B3%BB%E7%BB%9F%E4%B8%AD%EF%BC%8C%E5%88%86%E7%B1%BB%E5%92%8C%E6%A0%87%E7%AD%BE%E5%90%AC%E8%B5%B7%E6%9D%A5%E5%BE%88%E6%8E%A5%E8%BF%91%EF%BC%8C%E4%BD%86%E6%98%AF%E5%9C%A8-Hexo-%E4%B8%AD%E4%B8%A4%E8%80%85%E6%9C%89%E7%9D%80%E6%98%8E%E6%98%BE%E7%9A%84%E5%B7%AE%E5%88%AB%EF%BC%9A%E5%88%86%E7%B1%BB%E5%85%B7%E6%9C%89%E9%A1%BA%E5%BA%8F%E6%80%A7%E5%92%8C%E5%B1%82%E6%AC%A1%E6%80%A7%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4-Foo-Bar-%E4%B8%8D%E7%AD%89%E4%BA%8E-Bar-Foo%EF%BC%9B%E8%80%8C%E6%A0%87%E7%AD%BE%E6%B2%A1%E6%9C%89%E9%A1%BA%E5%BA%8F%E5%92%8C%E5%B1%82%E6%AC%A1%E3%80%82" title="分类和标签—–只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。"></a>分类和标签—–只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。</h3><pre><code>categories:- Diarytags:- PS3- Games</code></pre><h3 id="引用块—–在文章中插入引言，可包含作者、来源和标题"><a href="#引用块—–在文章中插入引言，可包含作者、来源和标题" class="headerlink" title="引用块—–在文章中插入引言，可包含作者、来源和标题"></a><a href="https://guardianss.github.io/2019/04/17/hexo%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#%E5%BC%95%E7%94%A8%E5%9D%97%E2%80%94%E2%80%93%E5%9C%A8%E6%96%87%E7%AB%A0%E4%B8%AD%E6%8F%92%E5%85%A5%E5%BC%95%E8%A8%80%EF%BC%8C%E5%8F%AF%E5%8C%85%E5%90%AB%E4%BD%9C%E8%80%85%E3%80%81%E6%9D%A5%E6%BA%90%E5%92%8C%E6%A0%87%E9%A2%98" title="引用块—–在文章中插入引言，可包含作者、来源和标题"></a>引用块—–在文章中插入引言，可包含作者、来源和标题</h3><pre><code>{% blockquote [author[, source]] [link] [source_link_title] %}    content    {% endblockquote %}</code></pre><h3 id="插入链接"><a href="#插入链接" class="headerlink" title="插入链接"></a><a href="https://guardianss.github.io/2019/04/17/hexo%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#%E6%8F%92%E5%85%A5%E9%93%BE%E6%8E%A5" title="插入链接"></a>插入链接</h3><pre><code>&lt;%- link_to(path, [text], [options]) %&gt;  参数                 描述    默认值  external    在新视窗打开链接    false  class            Class            名称      id                  ID    </code></pre><h3 id="插入电子邮箱链接。"><a href="#插入电子邮箱链接。" class="headerlink" title="插入电子邮箱链接。"></a><a href="https://guardianss.github.io/2019/04/17/hexo%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#%E6%8F%92%E5%85%A5%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1%E9%93%BE%E6%8E%A5%E3%80%82" title="插入电子邮箱链接。"></a>插入电子邮箱链接。</h3><pre><code>&lt;%- mail_to(path, [text], [options]) %&gt;   参数    描述   class    Class 名称   id    ID   subject    邮件主题   cc    抄送（CC）   bcc    密送（BCC）   body    邮件内容</code></pre><h3 id="插入图片。"><a href="#插入图片。" class="headerlink" title="插入图片。"></a><a href="https://guardianss.github.io/2019/04/17/hexo%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E3%80%82" title="插入图片。"></a>插入图片。</h3><pre><code>&lt;%- image_tag(path, [options]) %&gt;   参数    描述   alt    图片的替代文字   class    Class 名称   id    ID   width    图片宽度   height    图片高度</code></pre><h3 id="插入分页链接。"><a href="#插入分页链接。" class="headerlink" title="插入分页链接。"></a><a href="https://guardianss.github.io/2019/04/17/hexo%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#%E6%8F%92%E5%85%A5%E5%88%86%E9%A1%B5%E9%93%BE%E6%8E%A5%E3%80%82" title="插入分页链接。"></a>插入分页链接。</h3><pre><code>&lt;%- paginator(options) %&gt;   参数    描述    默认值   base    基础网址    /   format    网址格式    page/%d/   total    分页总数    1   current    目前页数    0   prev_text    上一页链接的文字。仅在 prev_next 设定开启时才有用。    Prev   next_text    下一页链接的文字。仅在 prev_next 设定开启时才有用。    Next   space    空白文字    …   prev_next    显示上一页和下一页的链接    true   end_size    显示于两侧的页数    1   mid_size    显示于中间的页数    2   show_all    显示所有页数。如果开启此参数的话，end_size 和 mid_size 就没用了。    false   search_form</code></pre><h3 id="插入-Google-搜索框。"><a href="#插入-Google-搜索框。" class="headerlink" title="插入 Google 搜索框。"></a><a href="https://guardianss.github.io/2019/04/17/hexo%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#%E6%8F%92%E5%85%A5-Google-%E6%90%9C%E7%B4%A2%E6%A1%86%E3%80%82" title="插入 Google 搜索框。"></a>插入 Google 搜索框。</h3><pre><code>&lt;%- search_form(options) %&gt;   参数    描述    默认值   class    表单的 class name    search-form   text    搜索提示文字    Search   button    显示搜索按钮。此参数可为布尔值（boolean）或字符串，当设定是字符串的时候，即为搜索按钮的文字。    false</code></pre><hr>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
