<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Guardian</title>
    <link>https://guardianss.github.io/</link>
    
    <image>
      <url>https://guardianss.github.io/icon.png</url>
      <title>Guardian</title>
      <link>https://guardianss.github.io/</link>
    </image>
    
    <atom:link href="/atom.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Wed, 13 May 2020 03:28:07 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>python —— 名片管理系统</title>
      <link>https://guardianss.github.io/python-%E2%80%94%E2%80%94-%E5%90%8D%E7%89%87%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F.html</link>
      <guid>https://guardianss.github.io/python-%E2%80%94%E2%80%94-%E5%90%8D%E7%89%87%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F.html</guid>
      <pubDate>Wed, 13 May 2020 03:21:44 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot;
          
        
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="综合应用-——-名片管理系统"><a href="#综合应用-——-名片管理系统" class="headerlink" title="综合应用 —— 名片管理系统"></a>综合应用 —— 名片管理系统</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p>综合应用已经学习过的知识点：</p><ul><li><strong>变量</strong></li><li><strong>流程控制</strong></li><li><strong>函数</strong></li><li><strong>模块</strong></li></ul><p>开发 <strong>名片管理系统</strong></p><h2 id="系统需求"><a href="#系统需求" class="headerlink" title="系统需求"></a>系统需求</h2><ul><li><ol><li>程序启动，显示名片管理系统欢迎界面，并显示功能菜单</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">**************************************************</span><br><span class="line">欢迎使用【名片管理系统】V1.0</span><br><span class="line"></span><br><span class="line">1. 新建名片</span><br><span class="line">2. 显示全部</span><br><span class="line">3. 查询名片</span><br><span class="line"></span><br><span class="line">0. 退出系统</span><br><span class="line">**************************************************</span><br></pre></td></tr></table></figure><ul><li><ol start="2"><li>用户用数字选择不同的功能</li></ol></li><li><ol start="3"><li>根据功能选择，执行不同的功能</li></ol></li><li><ol start="4"><li>用户名片需要记录用户的 <strong>姓名</strong>、<strong>电话</strong>、<strong>QQ</strong>、<strong>邮件</strong></li></ol></li><li><ol start="5"><li>如果查询到指定的名片，用户可以选择 <strong>修改</strong> 或者 <strong>删除</strong> 名片</li></ol></li></ul><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li>框架搭建</li><li>新增名片</li><li>显示所有名片</li><li>查询名片</li><li>查询成功后修改、删除名片</li><li>让 Python 程序能够直接运行</li></ol><h2 id="01-框架搭建"><a href="#01-框架搭建" class="headerlink" title="01. 框架搭建"></a>01. 框架搭建</h2><p><strong>目标</strong></p><ul><li>搭建名片管理系统 <strong>框架结构</strong><ol><li><strong>准备文件</strong>，确定文件名，保证能够 <strong>在需要的位置</strong> 编写代码</li><li>编写 <strong>主运行循环</strong>，实现基本的 <strong>用户输入和判断</strong></li></ol></li></ul><h3 id="1-1-文件准备"><a href="#1-1-文件准备" class="headerlink" title="1.1 文件准备"></a>1.1 文件准备</h3><ol><li>新建 <code>cards_main.py</code> 保存 <strong>主程序功能代码</strong><ul><li>程序的入口</li><li>每一次启动名片管理系统都通过 <code>main</code> 这个文件启动 </li></ul></li><li>新建 <code>cards_tools.py</code> 保存 <strong>所有名片功能函数</strong><ul><li>将对名片的 <strong>新增</strong>、<strong>查询</strong>、<strong>修改</strong>、<strong>删除</strong> 等功能封装在不同的函数中</li></ul></li></ol><h3 id="1-2-编写主运行循环"><a href="#1-2-编写主运行循环" class="headerlink" title="1.2 编写主运行循环"></a>1.2 编写主运行循环</h3><ul><li>在 <code>cards_main</code> 中添加一个 <strong>无限循环</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">    <span class="comment"># TODO(小明) 显示系统菜单</span></span><br><span class="line"></span><br><span class="line">    action = input(<span class="string">"请选择操作功能："</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"您选择的操作是：%s"</span> % action)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据用户输入决定后续的操作</span></span><br><span class="line">    <span class="keyword">if</span> action <span class="keyword">in</span> [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>]:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="keyword">elif</span> action == <span class="string">"0"</span>:</span><br><span class="line">        print(<span class="string">"欢迎再次使用【名片管理系统】"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"输入错误，请重新输入"</span>)</span><br></pre></td></tr></table></figure><h4 id="字符串判断"><a href="#字符串判断" class="headerlink" title="字符串判断"></a>字符串判断</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> action <span class="keyword">in</span> [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>]:</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> action == <span class="string">"1"</span> <span class="keyword">or</span> action == <span class="string">"2"</span> <span class="keyword">or</span> action == <span class="string">"3"</span>:</span><br></pre></td></tr></table></figure><ol><li>使用 <code>in</code> 针对 <strong>列表</strong> 判断，避免使用 <code>or</code> 拼接复杂的逻辑条件</li><li>没有使用 <code>int</code> 转换用户输入，可以避免 <strong>一旦用户输入的不是数字</strong>，导致程序运行出错</li></ol><h4 id="pass"><a href="#pass" class="headerlink" title="pass"></a>pass</h4><ul><li><code>pass</code> 就是一个空语句，不做任何事情，一般用做占位语句</li><li>是为了保持程序结构的完整性</li></ul><h4 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h4><ul><li>在开发软件时，如果 <strong>不希望程序执行后</strong> 立即退出</li><li>可以在程序中增加一个 <strong>无限循环</strong></li><li><strong>由用户来决定</strong> 退出程序的时机</li></ul><h4 id="TODO-注释"><a href="#TODO-注释" class="headerlink" title="TODO 注释"></a>TODO 注释</h4><ul><li>在 <code>#</code> 后跟上 <code>TODO</code>，用于标记需要去做的工作</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TODO(作者/邮件) 显示系统菜单</span></span><br></pre></td></tr></table></figure><h3 id="1-3-在-cards-tools-中增加四个新函数"><a href="#1-3-在-cards-tools-中增加四个新函数" class="headerlink" title="1.3 在 cards_tools 中增加四个新函数"></a>1.3 在 <code>cards_tools</code> 中增加四个新函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_menu</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"""显示菜单</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_card</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"""新建名片</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">"-"</span> * <span class="number">50</span>)</span><br><span class="line">    print(<span class="string">"功能：新建名片"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_all</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"""显示全部</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">"-"</span> * <span class="number">50</span>)</span><br><span class="line">    print(<span class="string">"功能：显示全部"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_card</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"""搜索名片</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">"-"</span> * <span class="number">50</span>)</span><br><span class="line">    print(<span class="string">"功能：搜索名片"</span>)</span><br></pre></td></tr></table></figure><h3 id="1-4-导入模块"><a href="#1-4-导入模块" class="headerlink" title="1.4 导入模块"></a>1.4 导入模块</h3><ul><li>在 <code>cards_main.py</code> 中使用 <code>import</code> 导入 <code>cards_tools</code> 模块</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cards_tools</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">* 修改 `<span class="keyword">while</span>` 循环的代码如下：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="keyword">import</span> cards_tools</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">    cards_tools.show_menu()</span><br><span class="line"></span><br><span class="line">    action = input(<span class="string">"请选择操作功能："</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"您选择的操作是：%s"</span> % action)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 根据用户输入决定后续的操作</span></span><br><span class="line">    <span class="keyword">if</span> action <span class="keyword">in</span> [<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>]:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> action == <span class="string">"1"</span>:</span><br><span class="line">            cards_tools.new_card()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> action == <span class="string">"2"</span>:</span><br><span class="line">            cards_tools.show_all()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> action == <span class="string">"3"</span>:</span><br><span class="line">            cards_tools.search_card()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> action == <span class="string">"0"</span>:</span><br><span class="line">        print(<span class="string">"欢迎再次使用【名片管理系统】"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"输入错误，请重新输入："</span>)</span><br></pre></td></tr></table></figure><blockquote><p>至此：<code>cards_main</code> 中的所有代码全部开发完毕！</p></blockquote><h3 id="1-5-完成-show-menu-函数"><a href="#1-5-完成-show-menu-函数" class="headerlink" title="1.5 完成 show_menu 函数"></a>1.5 完成 <code>show_menu</code> 函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_menu</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"""显示菜单</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">"*"</span> * <span class="number">50</span>)</span><br><span class="line">    print(<span class="string">"欢迎使用【菜单管理系统】V1.0"</span>)</span><br><span class="line">    print(<span class="string">""</span>)</span><br><span class="line">    print(<span class="string">"1. 新建名片"</span>)</span><br><span class="line">    print(<span class="string">"2. 显示全部"</span>)</span><br><span class="line">    print(<span class="string">"3. 查询名片"</span>)</span><br><span class="line">    print(<span class="string">""</span>)</span><br><span class="line">    print(<span class="string">"0. 退出系统"</span>)</span><br><span class="line">    print(<span class="string">"*"</span> * <span class="number">50</span>)</span><br></pre></td></tr></table></figure><h2 id="02-保存名片数据的结构"><a href="#02-保存名片数据的结构" class="headerlink" title="02. 保存名片数据的结构"></a>02. 保存名片数据的结构</h2><p><strong>程序就是用来处理数据的，而变量就是用来存储数据的</strong></p><ul><li>使用 <strong>字典</strong> 记录 <strong>每一张名片</strong> 的详细信息</li><li>使用 <strong>列表</strong> 统一记录所有的 <strong>名片字典</strong></li></ul><p><img src="/" class="lazyload" data-src="media/14973084639044/001_%E5%90%8D%E7%89%87%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E5%85%A8%E5%B1%80%E5%88%97%E8%A1%A8.png"  alt="001_名片管理系统全局列表-w500"></p><h3 id="定义名片列表变量"><a href="#定义名片列表变量" class="headerlink" title="定义名片列表变量"></a>定义名片列表变量</h3><ul><li>在 <code>cards_tools</code> 文件的顶部增加一个 <strong>列表变量</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 所有名片记录的列表</span></span><br><span class="line">card_list = []</span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><ol><li><strong>所有名片相关操作</strong>，都需要使用这个列表，所以应该 <strong>定义在程序的顶部</strong></li><li><strong>程序刚运行时，没有数据</strong>，所以是 <strong>空列表</strong></li></ol><h2 id="03-新增名片"><a href="#03-新增名片" class="headerlink" title="03. 新增名片"></a>03. 新增名片</h2><h3 id="3-1-功能分析"><a href="#3-1-功能分析" class="headerlink" title="3.1 功能分析"></a>3.1 功能分析</h3><ol><li>提示用户依次输入名片信息</li><li>将名片信息保存到一个字典</li><li>将字典添加到名片列表</li><li>提示名片添加完成</li></ol><h3 id="3-2-实现-new-card-方法"><a href="#3-2-实现-new-card-方法" class="headerlink" title="3.2 实现 new_card 方法"></a>3.2 实现 new_card 方法</h3><ul><li>根据步骤实现代码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_card</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"""新建名片</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">"-"</span> * <span class="number">50</span>)</span><br><span class="line">    print(<span class="string">"功能：新建名片"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 提示用户输入名片信息</span></span><br><span class="line">    name = input(<span class="string">"请输入姓名："</span>)</span><br><span class="line">    phone = input(<span class="string">"请输入电话："</span>)</span><br><span class="line">    qq = input(<span class="string">"请输入 QQ 号码："</span>)</span><br><span class="line">    email = input(<span class="string">"请输入邮箱："</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 将用户信息保存到一个字典</span></span><br><span class="line">    card_dict = &#123;<span class="string">"name"</span>: name,</span><br><span class="line">                 <span class="string">"phone"</span>: phone,</span><br><span class="line">                 <span class="string">"qq"</span>: qq,</span><br><span class="line">                 <span class="string">"email"</span>: email&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3. 将用户字典添加到名片列表</span></span><br><span class="line">    card_list.append(card_dict)</span><br><span class="line"></span><br><span class="line">    print(card_list)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 4. 提示添加成功信息</span></span><br><span class="line">    print(<span class="string">"成功添加 %s 的名片"</span> % card_dict[<span class="string">"name"</span>])</span><br></pre></td></tr></table></figure><blockquote><p>技巧：在 <code>PyCharm</code> 中，可以使用 <code>SHIFT + F6</code> 统一修改变量名</p></blockquote><h2 id="04-显示所有名片"><a href="#04-显示所有名片" class="headerlink" title="04. 显示所有名片"></a>04. 显示所有名片</h2><h3 id="4-1-功能分析"><a href="#4-1-功能分析" class="headerlink" title="4.1 功能分析"></a>4.1 功能分析</h3><ul><li>循环遍历名片列表，顺序显示每一个字典的信息</li></ul><h3 id="4-2-基础代码实现"><a href="#4-2-基础代码实现" class="headerlink" title="4.2 基础代码实现"></a>4.2 基础代码实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_all</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"""显示全部</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">"-"</span> * <span class="number">50</span>)</span><br><span class="line">    print(<span class="string">"功能：显示全部"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> card_dict <span class="keyword">in</span> card_list:</span><br><span class="line"></span><br><span class="line">        print(card_dict)</span><br></pre></td></tr></table></figure><ul><li>显示效果不好！</li></ul><h3 id="4-3-增加标题和使用-t-显示"><a href="#4-3-增加标题和使用-t-显示" class="headerlink" title="4.3 增加标题和使用 \t 显示"></a>4.3 增加标题和使用 <code>\t</code> 显示</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_all</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""显示全部</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">"-"</span> * <span class="number">50</span>)</span><br><span class="line">    print(<span class="string">"功能：显示全部"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印表头</span></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> [<span class="string">"姓名"</span>, <span class="string">"电话"</span>, <span class="string">"QQ"</span>, <span class="string">"邮箱"</span>]:</span><br><span class="line">        print(name, end=<span class="string">"\t\t"</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印分隔线</span></span><br><span class="line">    print(<span class="string">"="</span> * <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> card_dict <span class="keyword">in</span> card_list:</span><br><span class="line"></span><br><span class="line">        print(<span class="string">"%s\t\t%s\t\t%s\t\t%s"</span> % (card_dict[<span class="string">"name"</span>],</span><br><span class="line">                                        card_dict[<span class="string">"phone"</span>],</span><br><span class="line">                                        card_dict[<span class="string">"qq"</span>],</span><br><span class="line">                                        card_dict[<span class="string">"email"</span>]))</span><br></pre></td></tr></table></figure><h3 id="4-4-增加没有名片记录判断"><a href="#4-4-增加没有名片记录判断" class="headerlink" title="4.4 增加没有名片记录判断"></a>4.4 增加没有名片记录判断</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_all</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""显示全部</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">"-"</span> * <span class="number">50</span>)</span><br><span class="line">    print(<span class="string">"功能：显示全部"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 判断是否有名片记录</span></span><br><span class="line">    <span class="keyword">if</span> len(card_list) == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">"提示：没有任何名片记录"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong></p><ul><li>在函数中使用 <code>return</code> 表示返回</li><li>如果在 <code>return</code> 后没有跟任何内容，只是表示该函数执行到此就不再执行后续的代码</li></ul><h2 id="05-查询名片"><a href="#05-查询名片" class="headerlink" title="05. 查询名片"></a>05. 查询名片</h2><h3 id="5-1-功能分析"><a href="#5-1-功能分析" class="headerlink" title="5.1 功能分析"></a>5.1 功能分析</h3><ol><li>提示用户要搜索的姓名</li><li>根据用户输入的姓名遍历列表</li><li>搜索到指定的名片后，再执行后续的操作</li></ol><h3 id="5-2-代码实现"><a href="#5-2-代码实现" class="headerlink" title="5.2 代码实现"></a>5.2 代码实现</h3><ul><li>查询功能实现</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_card</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"""搜索名片</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">"-"</span> * <span class="number">50</span>)</span><br><span class="line">    print(<span class="string">"功能：搜索名片"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 1. 提示要搜索的姓名</span></span><br><span class="line">    find_name = input(<span class="string">"请输入要搜索的姓名："</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 遍历字典</span></span><br><span class="line">    <span class="keyword">for</span> card_dict <span class="keyword">in</span> card_list:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> card_dict[<span class="string">"name"</span>] == find_name:</span><br><span class="line"></span><br><span class="line">            print(<span class="string">"姓名\t\t\t电话\t\t\tQQ\t\t\t邮箱"</span>)</span><br><span class="line">            print(<span class="string">"-"</span> * <span class="number">40</span>)</span><br><span class="line">            </span><br><span class="line">            print(<span class="string">"%s\t\t\t%s\t\t\t%s\t\t\t%s"</span> % (</span><br><span class="line">                card_dict[<span class="string">"name"</span>],</span><br><span class="line">                card_dict[<span class="string">"phone"</span>],</span><br><span class="line">                card_dict[<span class="string">"qq"</span>],</span><br><span class="line">                card_dict[<span class="string">"email"</span>]))</span><br><span class="line"></span><br><span class="line">            print(<span class="string">"-"</span> * <span class="number">40</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># TODO(小明) 针对找到的字典进行后续操作：修改/删除</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"没有找到 %s"</span> % find_name)</span><br></pre></td></tr></table></figure><ul><li>增加名片操作函数：<strong>修改</strong>/<strong>删除</strong>/<strong>返回主菜单</strong></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deal_card</span><span class="params">(find_dict)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"""操作搜索到的名片字典</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param find_dict:找到的名片字典</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(find_dict)</span><br><span class="line"></span><br><span class="line">    action_str = input(<span class="string">"请选择要执行的操作 "</span></span><br><span class="line">                       <span class="string">"[1] 修改 [2] 删除 [0] 返回上级菜单"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> action == <span class="string">"1"</span>:</span><br><span class="line">        print(<span class="string">"修改"</span>)</span><br><span class="line">    <span class="keyword">elif</span> action == <span class="string">"2"</span>:</span><br><span class="line">        print(<span class="string">"删除"</span>)</span><br></pre></td></tr></table></figure><h2 id="06-修改和删除"><a href="#06-修改和删除" class="headerlink" title="06. 修改和删除"></a>06. 修改和删除</h2><h3 id="6-1-查询成功后删除名片"><a href="#6-1-查询成功后删除名片" class="headerlink" title="6.1 查询成功后删除名片"></a>6.1 查询成功后删除名片</h3><ul><li>由于找到的字典记录已经在列表中保存</li><li>要删除名片记录，只需要把列表中对应的字典删除即可</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elif</span> action == <span class="string">"2"</span>:</span><br><span class="line">    card_list.remove(find_dict)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"删除成功"</span>)</span><br></pre></td></tr></table></figure><h3 id="6-2-修改名片"><a href="#6-2-修改名片" class="headerlink" title="6.2 修改名片"></a>6.2 修改名片</h3><ul><li>由于找到的字典记录已经在列表中保存</li><li>要修改名片记录，只需要把列表中对应的字典中每一个键值对的数据修改即可</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> action == <span class="string">"1"</span>:</span><br><span class="line"></span><br><span class="line">    find_dict[<span class="string">"name"</span>] = input(<span class="string">"请输入姓名："</span>)</span><br><span class="line">    find_dict[<span class="string">"phone"</span>] = input(<span class="string">"请输入电话："</span>)</span><br><span class="line">    find_dict[<span class="string">"qq"</span>] = input(<span class="string">"请输入QQ："</span>)</span><br><span class="line">    find_dict[<span class="string">"email"</span>] = input(<span class="string">"请输入邮件："</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"%s 的名片修改成功"</span> % find_dict[<span class="string">"name"</span>])</span><br></pre></td></tr></table></figure><h4 id="修改名片细化"><a href="#修改名片细化" class="headerlink" title="修改名片细化"></a>修改名片细化</h4><ul><li><strong>如果用户在使用时，某些名片内容并不想修改</strong>，应该如何做呢？—— 既然系统提供的 <code>input</code> 函数不能满足需求，那么就新定义一个函数 <code>input_card_info</code> 对系统的 <code>input</code> 函数进行扩展</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">input_card_info</span><span class="params">(dict_value, tip_message)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"""输入名片信息</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param dict_value: 字典原有值</span></span><br><span class="line"><span class="string">    :param tip_message: 输入提示信息</span></span><br><span class="line"><span class="string">    :return: 如果输入，返回输入内容，否则返回字典原有值</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment"># 1. 提示用户输入内容</span></span><br><span class="line">    result_str = input(tip_message)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2. 针对用户的输入进行判断，如果用户输入了内容，直接返回结果</span></span><br><span class="line">    <span class="keyword">if</span> len(result_str) &gt; <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result_str</span><br><span class="line">    <span class="comment"># 3. 如果用户没有输入内容，返回 `字典中原有的值`</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dict_value</span><br></pre></td></tr></table></figure><h2 id="07-LINUX-上的-Shebang-符号"><a href="#07-LINUX-上的-Shebang-符号" class="headerlink" title="07. LINUX 上的 Shebang 符号(#!)"></a>07. LINUX 上的 <code>Shebang</code> 符号(<code>#!</code>)</h2><ul><li><code>#!</code>这个符号叫做 <code>Shebang</code> 或者 <code>Sha-bang</code></li><li><code>Shebang</code> 通常在 <code>Unix</code> 系统脚本的中 <strong>第一行开头</strong> 使用</li><li>指明 <strong>执行这个脚本文件</strong> 的 <strong>解释程序</strong></li></ul><h3 id="使用-Shebang-的步骤"><a href="#使用-Shebang-的步骤" class="headerlink" title="使用 Shebang 的步骤"></a>使用 Shebang 的步骤</h3><ul><li><ol><li>使用 <code>which</code> 查询 <code>python3</code> 解释器所在路径</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">which</span> python3</span><br></pre></td></tr></table></figure><ul><li><ol start="2"><li>修改要运行的 <strong>主 python 文件</strong>，在第一行增加以下内容</li></ol></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python3</span></span><br></pre></td></tr></table></figure><ul><li><ol start="3"><li>修改 <strong>主 python 文件</strong> 的文件权限，增加执行权限</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ chmod +x cards_main.py</span><br></pre></td></tr></table></figure><ul><li><ol start="4"><li>在需要时执行程序即可</li></ol></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./cards_main.py</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://guardianss.github.io/python-%E2%80%94%E2%80%94-%E5%90%8D%E7%89%87%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>pypython高级变量类型</title>
      <link>https://guardianss.github.io/pypython%E9%AB%98%E7%BA%A7%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B.html</link>
      <guid>https://guardianss.github.io/pypython%E9%AB%98%E7%BA%A7%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B.html</guid>
      <pubDate>Wed, 13 May 2020 03:21:28 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot;
          
        
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="高级变量类型"><a href="#高级变量类型" class="headerlink" title="高级变量类型"></a>高级变量类型</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>列表</li><li>元组</li><li>字典</li><li>字符串</li><li>公共方法</li><li>变量高级</li></ul><h3 id="知识点回顾"><a href="#知识点回顾" class="headerlink" title="知识点回顾"></a>知识点回顾</h3><ul><li><p>Python 中数据类型可以分为 <strong>数字型</strong> 和 <strong>非数字型</strong></p></li><li><p>数字型</p><ul><li>整型 (<code>int</code>)</li><li>浮点型（<code>float</code>）</li><li>布尔型（<code>bool</code>） <ul><li>真 <code>True</code> <code>非 0 数</code> —— <strong>非零即真</strong></li><li>假 <code>False</code> <code>0</code></li></ul></li><li>复数型 (<code>complex</code>)<ul><li>主要用于科学计算，例如：平面场问题、波动问题、电感电容等问题</li></ul></li></ul></li><li><p>非数字型</p><ul><li>字符串</li><li>列表</li><li>元组</li><li>字典</li></ul></li><li><p>在 <code>Python</code> 中，所有 <strong>非数字型变量</strong> 都支持以下特点：</p><ol><li>都是一个 <strong>序列</strong> <code>sequence</code>，也可以理解为 <strong>容器</strong></li><li><strong>取值</strong> <code>[]</code></li><li><strong>遍历</strong> <code>for in</code></li><li><strong>计算长度</strong>、<strong>最大/最小值</strong>、<strong>比较</strong>、<strong>删除</strong></li><li><strong>链接</strong> <code>+</code> 和 <strong>重复</strong> <code>*</code></li><li><strong>切片</strong></li></ol></li></ul><h2 id="01-列表"><a href="#01-列表" class="headerlink" title="01. 列表"></a>01. 列表</h2><h3 id="1-1-列表的定义"><a href="#1-1-列表的定义" class="headerlink" title="1.1 列表的定义"></a>1.1 列表的定义</h3><ul><li><code>List</code>（列表） 是 <code>Python</code> 中使用 <strong>最频繁</strong> 的数据类型，在其他语言中通常叫做 <strong>数组</strong></li><li>专门用于存储 <strong>一串 信息</strong></li><li>列表用 <code>[]</code> 定义，<strong>数据</strong> 之间使用 <code>,</code> 分隔</li><li>列表的 <strong>索引</strong> 从 <code>0</code> 开始<ul><li><strong>索引</strong> 就是数据在 <strong>列表</strong> 中的位置编号，<strong>索引</strong> 又可以被称为 <strong>下标</strong></li></ul></li></ul><blockquote><p>注意：从列表中取值时，如果 <strong>超出索引范围</strong>，程序会报错</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name_list = [<span class="string">"zhangsan"</span>, <span class="string">"lisi"</span>, <span class="string">"wangwu"</span>]</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="media/14972568611505/001_%E5%88%97%E8%A1%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png"  alt="001_列表示意图"></p><h3 id="1-2-列表常用操作"><a href="#1-2-列表常用操作" class="headerlink" title="1.2 列表常用操作"></a>1.2 列表常用操作</h3><ul><li>在 <code>ipython3</code> 中定义一个 <strong>列表</strong>，例如：<code>name_list = []</code></li><li>输入 <code>name_list.</code> 按下 <code>TAB</code> 键，<code>ipython</code> 会提示 <strong>列表</strong> 能够使用的 <strong>方法</strong> 如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [1]: name_list.</span><br><span class="line">name_list.append   name_list.count    name_list.insert   name_list.reverse</span><br><span class="line">name_list.clear    name_list.extend   name_list.pop      name_list.sort</span><br><span class="line">name_list.copy     name_list.index    name_list.remove</span><br></pre></td></tr></table></figure><table><thead><tr><th>序号</th><th>分类</th><th>关键字 / 函数 / 方法</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>增加</td><td>列表.insert(索引, 数据)</td><td>在指定位置插入数据</td></tr><tr><td></td><td></td><td>列表.append(数据)</td><td>在末尾追加数据</td></tr><tr><td></td><td></td><td>列表.extend(列表2)</td><td>将列表2 的数据追加到列表</td></tr><tr><td>2</td><td>修改</td><td>列表[索引] = 数据</td><td>修改指定索引的数据</td></tr><tr><td>3</td><td>删除</td><td>del 列表[索引]</td><td>删除指定索引的数据</td></tr><tr><td></td><td></td><td>列表.remove[数据]</td><td>删除第一个出现的指定数据</td></tr><tr><td></td><td></td><td>列表.pop</td><td>删除末尾数据</td></tr><tr><td></td><td></td><td>列表.pop(索引)</td><td>删除指定索引数据</td></tr><tr><td></td><td></td><td>列表.clear</td><td>清空列表</td></tr><tr><td>4</td><td>统计</td><td>len(列表)</td><td>列表长度</td></tr><tr><td></td><td></td><td>列表.count(数据)</td><td>数据在列表中出现的次数</td></tr><tr><td>5</td><td>排序</td><td>列表.sort()</td><td>升序排序</td></tr><tr><td></td><td></td><td>列表.sort(reverse=True)</td><td>降序排序</td></tr><tr><td></td><td></td><td>列表.reverse()</td><td>逆序、反转</td></tr></tbody></table><h4 id="del-关键字（科普）"><a href="#del-关键字（科普）" class="headerlink" title="del 关键字（科普）"></a>del 关键字（科普）</h4><ul><li>使用 <code>del</code> 关键字(<code>delete</code>) 同样可以删除列表中元素</li><li><code>del</code> 关键字本质上是用来 <strong>将一个变量从内存中删除的</strong></li><li>如果使用 <code>del</code> 关键字将变量从内存中删除，后续的代码就不能再使用这个变量了</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> name_list[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><blockquote><p>在日常开发中，要从列表删除数据，建议 <strong>使用列表提供的方法</strong></p></blockquote><h4 id="关键字、函数和方法（科普）"><a href="#关键字、函数和方法（科普）" class="headerlink" title="关键字、函数和方法（科普）"></a>关键字、函数和方法（科普）</h4><ul><li><strong>关键字</strong> 是 Python 内置的、具有特殊意义的标识符</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> keyword</span><br><span class="line">In [<span class="number">2</span>]: print(keyword.kwlist)</span><br><span class="line">In [<span class="number">3</span>]: print(len(keyword.kwlist))</span><br></pre></td></tr></table></figure><blockquote><p>关键字后面不需要使用括号</p></blockquote><ul><li><strong>函数</strong> 封装了独立功能，可以直接调用</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数名(参数)</span><br></pre></td></tr></table></figure><blockquote><p>函数需要死记硬背</p></blockquote><ul><li><strong>方法</strong> 和函数类似，同样是封装了独立的功能</li><li><strong>方法</strong> 需要通过 <strong>对象</strong> 来调用，表示针对这个 <strong>对象</strong> 要做的操作</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对象.方法名(参数)</span><br></pre></td></tr></table></figure><blockquote><p>在变量后面输入 <code>.</code>，然后选择针对这个变量要执行的操作，记忆起来比函数要简单很多</p></blockquote><h3 id="1-3-循环遍历"><a href="#1-3-循环遍历" class="headerlink" title="1.3 循环遍历"></a>1.3 循环遍历</h3><ul><li><p><strong>遍历</strong> 就是 <strong>从头到尾</strong> <strong>依次</strong> 从 <strong>列表</strong> 中获取数据</p><ul><li>在 <strong>循环体内部</strong> 针对 <strong>每一个元素</strong>，执行相同的操作</li></ul></li><li><p>在 <code>Python</code> 中为了提高列表的遍历效率，专门提供的 <strong>迭代 iteration 遍历</strong></p></li><li><p>使用 <code>for</code> 就能够实现迭代遍历</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># for 循环内部使用的变量 in 列表</span></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> name_list:</span><br><span class="line"></span><br><span class="line">    循环内部针对列表元素进行操作</span><br><span class="line">    print(name)</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="media/14972568611505/002_forin%E5%BE%AA%E7%8E%AF%E6%B5%81%E7%A8%8B%E5%9B%BE.png"  alt="002_forin循环流程图-w420"></p><h3 id="1-4-应用场景"><a href="#1-4-应用场景" class="headerlink" title="1.4 应用场景"></a>1.4 <strong>应用场景</strong></h3><ul><li>尽管 <code>Python</code> 的 <strong>列表</strong> 中可以 <strong>存储不同类型的数据</strong></li><li>但是在开发中，更多的应用场景是<ol><li><strong>列表</strong> 存储相同类型的数据</li><li>通过 <strong>迭代遍历</strong>，在循环体内部，针对列表中的每一项元素，执行相同的操作</li></ol></li></ul><h2 id="02-元组"><a href="#02-元组" class="headerlink" title="02. 元组"></a>02. 元组</h2><h3 id="2-1-元组的定义"><a href="#2-1-元组的定义" class="headerlink" title="2.1 元组的定义"></a>2.1 元组的定义</h3><ul><li><code>Tuple</code>（元组）与列表类似，不同之处在于元组的 <strong>元素不能修改</strong><ul><li><strong>元组</strong> 表示多个元素组成的序列</li><li><strong>元组</strong> 在 <code>Python</code> 开发中，有特定的应用场景</li></ul></li><li>用于存储 <strong>一串 信息</strong>，<strong>数据</strong> 之间使用 <code>,</code> 分隔</li><li>元组用 <code>()</code> 定义</li><li>元组的 <strong>索引</strong> 从 <code>0</code> 开始<ul><li><strong>索引</strong> 就是数据在 <strong>元组</strong> 中的位置编号</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info_tuple = (<span class="string">"zhangsan"</span>, <span class="number">18</span>, <span class="number">1.75</span>)</span><br></pre></td></tr></table></figure><h4 id="创建空元组"><a href="#创建空元组" class="headerlink" title="创建空元组"></a>创建空元组</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info_tuple = ()</span><br></pre></td></tr></table></figure><h4 id="元组中-只包含一个元素-时，需要-在元素后面添加逗号"><a href="#元组中-只包含一个元素-时，需要-在元素后面添加逗号" class="headerlink" title="元组中 只包含一个元素 时，需要 在元素后面添加逗号"></a>元组中 <strong>只包含一个元素</strong> 时，需要 <strong>在元素后面添加逗号</strong></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info_tuple = (<span class="number">50</span>, )</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="media/14972568611505/003_%E5%85%83%E7%BB%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png"  alt="003_元组示意图-w500"></p><h3 id="2-2-元组常用操作"><a href="#2-2-元组常用操作" class="headerlink" title="2.2 元组常用操作"></a>2.2 元组常用操作</h3><ul><li>在 <code>ipython3</code> 中定义一个 <strong>元组</strong>，例如：<code>info = ()</code></li><li>输入 <code>info.</code> 按下 <code>TAB</code> 键，<code>ipython</code> 会提示 <strong>元组</strong> 能够使用的函数如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info.count  info.index</span><br></pre></td></tr></table></figure><blockquote><p>有关 <strong>元组</strong> 的 <strong>常用操作</strong> 可以参照上图练习</p></blockquote><h3 id="2-3-循环遍历"><a href="#2-3-循环遍历" class="headerlink" title="2.3 循环遍历"></a>2.3 循环遍历</h3><ul><li><strong>取值</strong> 就是从 <strong>元组</strong> 中获取存储在指定位置的数据</li><li><strong>遍历</strong> 就是 <strong>从头到尾</strong> <strong>依次</strong> 从 <strong>元组</strong> 中获取数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># for 循环内部使用的变量 in 元组</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> info:</span><br><span class="line"></span><br><span class="line">    循环内部针对元组元素进行操作</span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure><blockquote><ul><li>在 <code>Python</code> 中，可以使用 <code>for</code> 循环遍历所有非数字型类型的变量：<strong>列表</strong>、<strong>元组</strong>、<strong>字典</strong> 以及 <strong>字符串</strong></li><li>提示：在实际开发中，除非 <strong>能够确认元组中的数据类型</strong>，否则针对元组的循环遍历需求并不是很多</li></ul></blockquote><h3 id="2-4-应用场景"><a href="#2-4-应用场景" class="headerlink" title="2.4 应用场景"></a>2.4 应用场景</h3><ul><li>尽管可以使用 <code>for in</code> 遍历 <strong>元组</strong></li><li>但是在开发中，更多的应用场景是：<ul><li><strong>函数的 参数 和 返回值</strong>，一个函数可以接收 <strong>任意多个参数</strong>，或者 <strong>一次返回多个数据</strong><ul><li>有关 <strong>函数的参数 和 返回值</strong>，在后续 <strong>函数高级</strong> 给大家介绍</li></ul></li><li><strong>格式字符串</strong>，格式化字符串后面的 <code>()</code> 本质上就是一个元组</li><li><strong>让列表不可以被修改</strong>，以保护数据安全</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">info = (<span class="string">"zhangsan"</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"%s 的年龄是 %d"</span> % info)</span><br></pre></td></tr></table></figure><h4 id="元组和列表之间的转换"><a href="#元组和列表之间的转换" class="headerlink" title="元组和列表之间的转换"></a>元组和列表之间的转换</h4><ul><li>使用 <code>list</code> 函数可以把元组转换成列表</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list(元组)</span><br></pre></td></tr></table></figure><ul><li>使用 <code>tuple</code> 函数可以把列表转换成元组</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tuple(列表)</span><br></pre></td></tr></table></figure><h2 id="03-字典"><a href="#03-字典" class="headerlink" title="03. 字典"></a>03. 字典</h2><h3 id="3-1-字典的定义"><a href="#3-1-字典的定义" class="headerlink" title="3.1 字典的定义"></a>3.1 字典的定义</h3><ul><li><code>dictionary</code>（字典） 是 <strong>除列表以外</strong> <code>Python</code> 之中 <strong>最灵活</strong> 的数据类型</li><li>字典同样可以用来 <strong>存储多个数据</strong><ul><li>通常用于存储 <strong>描述一个 <code>物体</code> 的相关信息</strong> </li></ul></li><li>和列表的区别<ul><li><strong>列表</strong> 是 <strong>有序</strong> 的对象集合</li><li><strong>字典</strong> 是 <strong>无序</strong> 的对象集合</li></ul></li><li>字典用 <code>{}</code> 定义</li><li>字典使用 <strong>键值对</strong> 存储数据，键值对之间使用 <code>,</code> 分隔<ul><li><strong>键</strong> <code>key</code> 是索引</li><li><strong>值</strong> <code>value</code> 是数据</li><li><strong>键</strong> 和 <strong>值</strong> 之间使用 <code>:</code> 分隔</li><li><strong>键必须是唯一的</strong></li><li><strong>值</strong> 可以取任何数据类型，但 <strong>键</strong> 只能使用 <strong>字符串</strong>、<strong>数字</strong>或 <strong>元组</strong></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xiaoming = &#123;<span class="string">"name"</span>: <span class="string">"小明"</span>,</span><br><span class="line">            <span class="string">"age"</span>: <span class="number">18</span>,</span><br><span class="line">            <span class="string">"gender"</span>: <span class="literal">True</span>,</span><br><span class="line">            <span class="string">"height"</span>: <span class="number">1.75</span>&#125;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="media/14972568611505/002_%E5%AD%97%E5%85%B8%E7%A4%BA%E6%84%8F%E5%9B%BE.png"  alt="002_字典示意图"></p><h3 id="3-2-字典常用操作"><a href="#3-2-字典常用操作" class="headerlink" title="3.2 字典常用操作"></a>3.2 字典常用操作</h3><ul><li>在 <code>ipython3</code> 中定义一个 <strong>字典</strong>，例如：<code>xiaoming = {}</code></li><li>输入 <code>xiaoming.</code> 按下 <code>TAB</code> 键，<code>ipython</code> 会提示 <strong>字典</strong> 能够使用的函数如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">In [1]: xiaoming.</span><br><span class="line">xiaoming.clear       xiaoming.items       xiaoming.setdefault</span><br><span class="line">xiaoming.copy        xiaoming.keys        xiaoming.update</span><br><span class="line">xiaoming.fromkeys    xiaoming.pop         xiaoming.values</span><br><span class="line">xiaoming.get         xiaoming.popitem</span><br></pre></td></tr></table></figure><blockquote><p>有关 <strong>字典</strong> 的 <strong>常用操作</strong> 可以参照上图练习</p></blockquote><h3 id="3-3-循环遍历"><a href="#3-3-循环遍历" class="headerlink" title="3.3 循环遍历"></a>3.3 循环遍历</h3><ul><li><strong>遍历</strong> 就是 <strong>依次</strong> 从 <strong>字典</strong> 中获取所有键值对</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># for 循环内部使用的 `key 的变量` in 字典</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> xiaoming:</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"%s: %s"</span> % (k, xiaoming[k]))</span><br></pre></td></tr></table></figure><blockquote><p>提示：在实际开发中，由于字典中每一个键值对保存数据的类型是不同的，所以针对字典的循环遍历需求并不是很多</p></blockquote><h3 id="3-4-应用场景"><a href="#3-4-应用场景" class="headerlink" title="3.4 应用场景"></a>3.4 <strong>应用场景</strong></h3><ul><li>尽管可以使用 <code>for in</code> 遍历 <strong>字典</strong></li><li>但是在开发中，更多的应用场景是：<ul><li>使用 <strong>多个键值对</strong>，存储 <strong>描述一个 <code>物体</code> 的相关信息</strong> —— 描述更复杂的数据信息</li><li>将 <strong>多个字典</strong> 放在 <strong>一个列表</strong> 中，再进行遍历，在循环体内部针对每一个字典进行 <strong>相同的处理</strong></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">card_list = [&#123;<span class="string">"name"</span>: <span class="string">"张三"</span>,</span><br><span class="line">              <span class="string">"qq"</span>: <span class="string">"12345"</span>,</span><br><span class="line">              <span class="string">"phone"</span>: <span class="string">"110"</span>&#125;,</span><br><span class="line">             &#123;<span class="string">"name"</span>: <span class="string">"李四"</span>,</span><br><span class="line">              <span class="string">"qq"</span>: <span class="string">"54321"</span>,</span><br><span class="line">              <span class="string">"phone"</span>: <span class="string">"10086"</span>&#125;</span><br><span class="line">             ]</span><br></pre></td></tr></table></figure><h2 id="04-字符串"><a href="#04-字符串" class="headerlink" title="04. 字符串"></a>04. 字符串</h2><h3 id="4-1-字符串的定义"><a href="#4-1-字符串的定义" class="headerlink" title="4.1 字符串的定义"></a>4.1 字符串的定义</h3><ul><li><strong>字符串</strong> 就是 <strong>一串字符</strong>，是编程语言中表示文本的数据类型</li><li>在 Python 中可以使用 <strong>一对双引号</strong> <code>&quot;</code> 或者 <strong>一对单引号</strong> <code>&#39;</code> 定义一个字符串<ul><li>虽然可以使用 <code>\&quot;</code> 或者 <code>\&#39;</code> 做字符串的转义，但是在实际开发中：<ul><li>如果字符串内部需要使用 <code>&quot;</code>，可以使用 <code>&#39;</code> 定义字符串</li><li>如果字符串内部需要使用 <code>&#39;</code>，可以使用 <code>&quot;</code> 定义字符串</li></ul></li></ul></li><li>可以使用 <strong>索引</strong> 获取一个字符串中 <strong>指定位置的字符</strong>，索引计数从 <strong>0</strong> 开始</li><li>也可以使用 <code>for</code> <strong>循环遍历</strong> 字符串中每一个字符</li></ul><blockquote><p>大多数编程语言都是用 <code>&quot;</code> 来定义字符串</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string = <span class="string">"Hello Python"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> string:</span><br><span class="line">    print(c)</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="media/14972568611505/005_%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%A4%BA%E6%84%8F%E5%9B%BE.png"  alt="005_字符串示意图-w500"></p><h3 id="4-2-字符串的常用操作"><a href="#4-2-字符串的常用操作" class="headerlink" title="4.2 字符串的常用操作"></a>4.2 字符串的常用操作</h3><ul><li>在 <code>ipython3</code> 中定义一个 <strong>字符串</strong>，例如：<code>hello_str = &quot;&quot;</code></li><li>输入 <code>hello_str.</code> 按下 <code>TAB</code> 键，<code>ipython</code> 会提示 <strong>字符串</strong> 能够使用的 <strong>方法</strong> 如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">In [1]: hello_str.</span><br><span class="line">hello_str.capitalize    hello_str.isidentifier  hello_str.rindex</span><br><span class="line">hello_str.casefold      hello_str.islower       hello_str.rjust</span><br><span class="line">hello_str.center        hello_str.isnumeric     hello_str.rpartition</span><br><span class="line">hello_str.count         hello_str.isprintable   hello_str.rsplit</span><br><span class="line">hello_str.encode        hello_str.isspace       hello_str.rstrip</span><br><span class="line">hello_str.endswith      hello_str.istitle       hello_str.split</span><br><span class="line">hello_str.expandtabs    hello_str.isupper       hello_str.splitlines</span><br><span class="line">hello_str.find          hello_str.join          hello_str.startswith</span><br><span class="line">hello_str.format        hello_str.ljust         hello_str.strip</span><br><span class="line">hello_str.format_map    hello_str.lower         hello_str.swapcase</span><br><span class="line">hello_str.index         hello_str.lstrip        hello_str.title</span><br><span class="line">hello_str.isalnum       hello_str.maketrans     hello_str.translate</span><br><span class="line">hello_str.isalpha       hello_str.partition     hello_str.upper</span><br><span class="line">hello_str.isdecimal     hello_str.replace       hello_str.zfill</span><br><span class="line">hello_str.isdigit       hello_str.rfind</span><br></pre></td></tr></table></figure><blockquote><p>提示：正是因为 python 内置提供的方法足够多，才使得在开发时，能够针对字符串进行更加灵活的操作！应对更多的开发需求！</p></blockquote><h4 id="1-判断类型-9"><a href="#1-判断类型-9" class="headerlink" title="1) 判断类型 - 9"></a>1) 判断类型 - 9</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>string.isspace()</td><td>如果 string 中只包含空格，则返回 True</td></tr><tr><td>string.isalnum()</td><td>如果 string 至少有一个字符并且所有字符都是字母或数字则返回 True</td></tr><tr><td>string.isalpha()</td><td>如果 string 至少有一个字符并且所有字符都是字母则返回 True</td></tr><tr><td>string.isdecimal()</td><td>如果 string 只包含数字则返回 True，<code>全角数字</code></td></tr><tr><td>string.isdigit()</td><td>如果 string 只包含数字则返回 True，<code>全角数字</code>、<code>⑴</code>、<code>\u00b2</code></td></tr><tr><td>string.isnumeric()</td><td>如果 string 只包含数字则返回 True，<code>全角数字</code>，<code>汉字数字</code></td></tr><tr><td>string.istitle()</td><td>如果 string 是标题化的(每个单词的首字母大写)则返回 True</td></tr><tr><td>string.islower()</td><td>如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True</td></tr><tr><td>string.isupper()</td><td>如果 string 中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True</td></tr></tbody></table><h4 id="2-查找和替换-7"><a href="#2-查找和替换-7" class="headerlink" title="2) 查找和替换 - 7"></a>2) 查找和替换 - 7</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>string.startswith(str)</td><td>检查字符串是否是以 str 开头，是则返回 True</td></tr><tr><td>string.endswith(str)</td><td>检查字符串是否是以 str 结束，是则返回 True</td></tr><tr><td>string.find(str, start=0, end=len(string))</td><td>检测 str 是否包含在 string 中，如果 start 和 end 指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则返回 <code>-1</code></td></tr><tr><td>string.rfind(str, start=0, end=len(string))</td><td>类似于 find()，不过是从右边开始查找</td></tr><tr><td>string.index(str, start=0, end=len(string))</td><td>跟 find() 方法类似，不过如果 str 不在 string 会报错</td></tr><tr><td>string.rindex(str, start=0, end=len(string))</td><td>类似于 index()，不过是从右边开始</td></tr><tr><td>string.replace(old_str, new_str, num=string.count(old))</td><td>把 string 中的 old_str 替换成 new_str，如果 num 指定，则替换不超过 num 次</td></tr></tbody></table><h4 id="3-大小写转换-5"><a href="#3-大小写转换-5" class="headerlink" title="3) 大小写转换 - 5"></a>3) 大小写转换 - 5</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>string.capitalize()</td><td>把字符串的第一个字符大写</td></tr><tr><td>string.title()</td><td>把字符串的每个单词首字母大写</td></tr><tr><td>string.lower()</td><td>转换 string 中所有大写字符为小写</td></tr><tr><td>string.upper()</td><td>转换 string 中的小写字母为大写</td></tr><tr><td>string.swapcase()</td><td>翻转 string 中的大小写</td></tr></tbody></table><h4 id="4-文本对齐-3"><a href="#4-文本对齐-3" class="headerlink" title="4) 文本对齐 - 3"></a>4) 文本对齐 - 3</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>string.ljust(width)</td><td>返回一个原字符串左对齐，并使用空格填充至长度 width 的新字符串</td></tr><tr><td>string.rjust(width)</td><td>返回一个原字符串右对齐，并使用空格填充至长度 width 的新字符串</td></tr><tr><td>string.center(width)</td><td>返回一个原字符串居中，并使用空格填充至长度 width 的新字符串</td></tr></tbody></table><h4 id="5-去除空白字符-3"><a href="#5-去除空白字符-3" class="headerlink" title="5) 去除空白字符 - 3"></a>5) 去除空白字符 - 3</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>string.lstrip()</td><td>截掉 string 左边（开始）的空白字符</td></tr><tr><td>string.rstrip()</td><td>截掉 string 右边（末尾）的空白字符</td></tr><tr><td>string.strip()</td><td>截掉 string 左右两边的空白字符</td></tr></tbody></table><h4 id="6-拆分和连接-5"><a href="#6-拆分和连接-5" class="headerlink" title="6) 拆分和连接 - 5"></a>6) 拆分和连接 - 5</h4><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>string.partition(str)</td><td>把字符串 string 分成一个 3 元素的元组 (str前面, str, str后面)</td></tr><tr><td>string.rpartition(str)</td><td>类似于 partition() 方法，不过是从右边开始查找</td></tr><tr><td>string.split(str=””, num)</td><td>以 str 为分隔符拆分 string，如果 num 有指定值，则仅分隔 num + 1 个子字符串，str 默认包含 ‘\r’, ‘\t’, ‘\n’ 和空格</td></tr><tr><td>string.splitlines()</td><td>按照行(‘\r’, ‘\n’, ‘\r\n’)分隔，返回一个包含各行作为元素的列表</td></tr><tr><td>string.join(seq)</td><td>以 string 作为分隔符，将 seq 中所有的元素（的字符串表示）合并为一个新的字符串</td></tr></tbody></table><h3 id="4-3-字符串的切片"><a href="#4-3-字符串的切片" class="headerlink" title="4.3 字符串的切片"></a>4.3 字符串的切片</h3><ul><li><strong>切片</strong> 方法适用于 <strong>字符串</strong>、<strong>列表</strong>、<strong>元组</strong><ul><li><strong>切片</strong> 使用 <strong>索引值</strong> 来限定范围，从一个大的 <strong>字符串</strong> 中 <strong>切出</strong> 小的 <strong>字符串</strong></li><li><strong>列表</strong> 和 <strong>元组</strong> 都是 <strong>有序</strong> 的集合，都能够 <strong>通过索引值</strong> 获取到对应的数据</li><li><strong>字典</strong> 是一个 <strong>无序</strong> 的集合，是使用 <strong>键值对</strong> 保存数据</li></ul></li></ul><p><img src="/" class="lazyload" data-src="media/14972568611505/006_%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B4%A2%E5%BC%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png"  alt="006_字符串索引示意图"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">字符串[开始索引:结束索引:步长]</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><ol><li>指定的区间属于 <strong>左闭右开</strong> 型 <code>[开始索引,  结束索引)</code> =&gt; <code>开始索引 &gt;= 范围 &lt; 结束索引</code><ul><li>从 <code>起始</code> 位开始，到 <strong><code>结束</code>位的前一位</strong> 结束（<strong>不包含结束位本身</strong>)</li></ul></li><li>从头开始，<strong>开始索引</strong> <strong>数字可以省略，冒号不能省略</strong></li><li>到末尾结束，<strong>结束索引</strong> <strong>数字可以省略，冒号不能省略</strong></li><li>步长默认为 <code>1</code>，如果连续切片，<strong>数字和冒号都可以省略</strong></li></ol><h4 id="索引的顺序和倒序"><a href="#索引的顺序和倒序" class="headerlink" title="索引的顺序和倒序"></a>索引的顺序和倒序</h4><ul><li>在 Python 中不仅支持 <strong>顺序索引</strong>，同时还支持 <strong>倒序索引</strong></li><li>所谓倒序索引就是 <strong>从右向左</strong> 计算索引<ul><li>最右边的索引值是 <strong>-1</strong>，依次递减</li></ul></li></ul><p><strong>演练需求</strong></p><ul><li><ol><li>截取从 2 ~ 5 位置 的字符串</li></ol></li><li><ol start="2"><li>截取从 2 ~ <code>末尾</code> 的字符串</li></ol></li><li><ol start="3"><li>截取从 <code>开始</code> ~ 5 位置 的字符串</li></ol></li><li><ol start="4"><li>截取完整的字符串</li></ol></li><li><ol start="5"><li>从开始位置，每隔一个字符截取字符串</li></ol></li><li><ol start="6"><li>从索引 1 开始，每隔一个取一个</li></ol></li><li><ol start="7"><li>截取从 2 ~ <code>末尾 - 1</code> 的字符串</li></ol></li><li><ol start="8"><li>截取字符串末尾两个字符</li></ol></li><li><ol start="9"><li>字符串的逆序（面试题）</li></ol></li></ul><p><strong>答案</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">num_str &#x3D; &quot;0123456789&quot;</span><br><span class="line"></span><br><span class="line"># 1. 截取从 2 ~ 5 位置 的字符串</span><br><span class="line">print(num_str[2:6])</span><br><span class="line"></span><br><span class="line"># 2. 截取从 2 ~ &#96;末尾&#96; 的字符串</span><br><span class="line">print(num_str[2:])</span><br><span class="line"></span><br><span class="line"># 3. 截取从 &#96;开始&#96; ~ 5 位置 的字符串</span><br><span class="line">print(num_str[:6])</span><br><span class="line"></span><br><span class="line"># 4. 截取完整的字符串</span><br><span class="line">print(num_str[:])</span><br><span class="line"></span><br><span class="line"># 5. 从开始位置，每隔一个字符截取字符串</span><br><span class="line">print(num_str[::2])</span><br><span class="line"></span><br><span class="line"># 6. 从索引 1 开始，每隔一个取一个</span><br><span class="line">print(num_str[1::2])</span><br><span class="line"></span><br><span class="line"># 倒序切片</span><br><span class="line"># -1 表示倒数第一个字符</span><br><span class="line">print(num_str[-1])</span><br><span class="line"></span><br><span class="line"># 7. 截取从 2 ~ &#96;末尾 - 1&#96; 的字符串</span><br><span class="line">print(num_str[2:-1])</span><br><span class="line"></span><br><span class="line"># 8. 截取字符串末尾两个字符</span><br><span class="line">print(num_str[-2:])</span><br><span class="line"></span><br><span class="line"># 9. 字符串的逆序（面试题）</span><br><span class="line">print(num_str[::-1])</span><br></pre></td></tr></table></figure><h2 id="05-公共方法"><a href="#05-公共方法" class="headerlink" title="05. 公共方法"></a>05. 公共方法</h2><h3 id="5-1-Python-内置函数"><a href="#5-1-Python-内置函数" class="headerlink" title="5.1 Python 内置函数"></a>5.1 Python 内置函数</h3><p>Python 包含了以下内置函数：</p><table><thead><tr><th>函数</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td>len(item)</td><td>计算容器中元素个数</td><td></td></tr><tr><td>del(item)</td><td>删除变量</td><td>del 有两种方式</td></tr><tr><td>max(item)</td><td>返回容器中元素最大值</td><td>如果是字典，只针对 key 比较</td></tr><tr><td>min(item)</td><td>返回容器中元素最小值</td><td>如果是字典，只针对 key 比较</td></tr><tr><td>cmp(item1, item2)</td><td>比较两个值，-1 小于/0 相等/1 大于</td><td>Python 3.x 取消了 cmp 函数</td></tr></tbody></table><p><strong>注意</strong></p><ul><li><strong>字符串</strong> 比较符合以下规则： “0” &lt; “A” &lt; “a”</li></ul><h3 id="5-2-切片"><a href="#5-2-切片" class="headerlink" title="5.2 切片"></a>5.2 切片</h3><p>| 描述 | Python 表达式 | 结果 | 支持的数据类型 |<br>| :—: | — | — | — | — |<br>| 切片 | “0123456789”[::-2] | “97531” | 字符串、列表、元组 |</p><ul><li><strong>切片</strong> 使用 <strong>索引值</strong> 来限定范围，从一个大的 <strong>字符串</strong> 中 <strong>切出</strong> 小的 <strong>字符串</strong></li><li><strong>列表</strong> 和 <strong>元组</strong> 都是 <strong>有序</strong> 的集合，都能够 <strong>通过索引值</strong> 获取到对应的数据</li><li><strong>字典</strong> 是一个 <strong>无序</strong> 的集合，是使用 <strong>键值对</strong> 保存数据</li></ul><h3 id="5-3-运算符"><a href="#5-3-运算符" class="headerlink" title="5.3 运算符"></a>5.3 运算符</h3><table><thead><tr><th align="center">运算符</th><th>Python 表达式</th><th>结果</th><th>描述</th><th>支持的数据类型</th></tr></thead><tbody><tr><td align="center">+</td><td>[1, 2] + [3, 4]</td><td>[1, 2, 3, 4]</td><td>合并</td><td>字符串、列表、元组</td></tr><tr><td align="center">*</td><td>[“Hi!”] * 4</td><td>[‘Hi!’, ‘Hi!’, ‘Hi!’, ‘Hi!’]</td><td>重复</td><td>字符串、列表、元组</td></tr><tr><td align="center">in</td><td>3 in (1, 2, 3)</td><td>True</td><td>元素是否存在</td><td>字符串、列表、元组、字典</td></tr><tr><td align="center">not in</td><td>4 not in (1, 2, 3)</td><td>True</td><td>元素是否不存在</td><td>字符串、列表、元组、字典</td></tr><tr><td align="center">&gt; &gt;= == &lt; &lt;=</td><td>(1, 2, 3) &lt; (2, 2, 3)</td><td>True</td><td>元素比较</td><td>字符串、列表、元组</td></tr></tbody></table><p><strong>注意</strong></p><ul><li><code>in</code> 在对 <strong>字典</strong> 操作时，判断的是 <strong>字典的键</strong></li><li><code>in</code> 和 <code>not in</code> 被称为 <strong>成员运算符</strong></li></ul><h4 id="成员运算符"><a href="#成员运算符" class="headerlink" title="成员运算符"></a>成员运算符</h4><p>成员运算符用于 <strong>测试</strong> 序列中是否包含指定的 <strong>成员</strong></p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>in</td><td>如果在指定的序列中找到值返回 True，否则返回 False</td><td><code>3 in (1, 2, 3)</code> 返回 <code>True</code></td></tr><tr><td>not in</td><td>如果在指定的序列中没有找到值返回 True，否则返回 False</td><td><code>3 not in (1, 2, 3)</code> 返回 <code>False</code></td></tr></tbody></table><p>注意：在对 <strong>字典</strong> 操作时，判断的是 <strong>字典的键</strong></p><h3 id="5-4-完整的-for-循环语法"><a href="#5-4-完整的-for-循环语法" class="headerlink" title="5.4 完整的 for 循环语法"></a>5.4 完整的 for 循环语法</h3><ul><li>在 <code>Python</code> 中完整的 <code>for 循环</code> 的语法如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> 集合:</span><br><span class="line">    </span><br><span class="line">    循环体代码</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    没有通过 <span class="keyword">break</span> 退出循环，循环结束后，会执行的代码</span><br></pre></td></tr></table></figure><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>在 <strong>迭代遍历</strong> 嵌套的数据类型时，例如 <strong>一个列表包含了多个字典</strong></li><li>需求：要判断 某一个字典中 是否存在 指定的 值 <ul><li>如果 <strong>存在</strong>，提示并且退出循环</li><li>如果 <strong>不存在</strong>，在 <strong>循环整体结束</strong> 后，希望 <strong>得到一个统一的提示</strong></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">students = [</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"阿土"</span>,</span><br><span class="line">     <span class="string">"age"</span>: <span class="number">20</span>,</span><br><span class="line">     <span class="string">"gender"</span>: <span class="literal">True</span>,</span><br><span class="line">     <span class="string">"height"</span>: <span class="number">1.7</span>,</span><br><span class="line">     <span class="string">"weight"</span>: <span class="number">75.0</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"小美"</span>,</span><br><span class="line">     <span class="string">"age"</span>: <span class="number">19</span>,</span><br><span class="line">     <span class="string">"gender"</span>: <span class="literal">False</span>,</span><br><span class="line">     <span class="string">"height"</span>: <span class="number">1.6</span>,</span><br><span class="line">     <span class="string">"weight"</span>: <span class="number">45.0</span>&#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">find_name = <span class="string">"阿土"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> stu_dict <span class="keyword">in</span> students:</span><br><span class="line"></span><br><span class="line">    print(stu_dict)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断当前遍历的字典中姓名是否为find_name</span></span><br><span class="line">    <span class="keyword">if</span> stu_dict[<span class="string">"name"</span>] == find_name:</span><br><span class="line">        print(<span class="string">"找到了"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 如果已经找到，直接退出循环，就不需要再对后续的数据进行比较</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"没有找到"</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"循环结束"</span>)</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://guardianss.github.io/pypython%E9%AB%98%E7%BA%A7%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>pypython —— 函数和模块的使用</title>
      <link>https://guardianss.github.io/pypython-%E2%80%94%E2%80%94-%E5%87%BD%E6%95%B0%E5%92%8C%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8.html</link>
      <guid>https://guardianss.github.io/pypython-%E2%80%94%E2%80%94-%E5%87%BD%E6%95%B0%E5%92%8C%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8.html</guid>
      <pubDate>Wed, 13 May 2020 03:21:07 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot;
          
        
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="函数和模块的使用"><a href="#函数和模块的使用" class="headerlink" title="函数和模块的使用"></a>函数和模块的使用</h2><p>在讲解本章节的内容之前，我们先来研究一道数学题，请说出下面的方程有多少组正整数解。</p><p>$$x_1 + x_2 + x_3 + x_4 = 8$$</p><p>事实上，上面的问题等同于将8个苹果分成四组每组至少一个苹果有多少种方案。想到这一点问题的答案就呼之欲出了。</p><p>$$C_M^N =\frac{M!}{N!(M-N)!}, \text{(M=7, N=3)} $$</p><p>可以用Python的程序来计算出这个值，代码如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">输入M和N计算C(M,N)</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line">m = int(input(<span class="string">'m = '</span>))</span><br><span class="line">n = int(input(<span class="string">'n = '</span>))</span><br><span class="line">fm = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>, m + <span class="number">1</span>):</span><br><span class="line">    fm *= num</span><br><span class="line">fn = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">    fn *= num</span><br><span class="line">fmn = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> range(<span class="number">1</span>, m - n + <span class="number">1</span>):</span><br><span class="line">    fmn *= num</span><br><span class="line">print(fm // fn // fmn)</span><br></pre></td></tr></table></figure><h3 id="函数的作用"><a href="#函数的作用" class="headerlink" title="函数的作用"></a>函数的作用</h3><p>不知道大家是否注意到，在上面的代码中，我们做了3次求阶乘，这样的代码实际上就是重复代码。编程大师Martin Fowler先生曾经说过：“代码有很多种坏味道，重复是最坏的一种！”，要写出高质量的代码首先要解决的就是重复代码的问题。对于上面的代码来说，我们可以将计算阶乘的功能封装到一个称之为“函数”的功能模块中，在需要计算阶乘的地方，我们只需要“调用”这个“函数”就可以了。</p><h3 id="定义函数"><a href="#定义函数" class="headerlink" title="定义函数"></a>定义函数</h3><p>在Python中可以使用<code>def</code>关键字来定义函数，和变量一样每个函数也有一个响亮的名字，而且命名规则跟变量的命名规则是一致的。在函数名后面的圆括号中可以放置传递给函数的参数，这一点和数学上的函数非常相似，程序中函数的参数就相当于是数学上说的函数的自变量，而函数执行完成后我们可以通过<code>return</code>关键字来返回一个值，这相当于数学上说的函数的因变量。</p><p>在了解了如何定义函数后，我们可以对上面的代码进行重构，所谓重构就是在不影响代码执行结果的前提下对代码的结构进行调整，重构之后的代码如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    求阶乘</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    :param num: 非负整数</span></span><br><span class="line"><span class="string">    :return: num的阶乘</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    result = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">1</span>, num + <span class="number">1</span>):</span><br><span class="line">        result *= n</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">m = int(input(<span class="string">'m = '</span>))</span><br><span class="line">n = int(input(<span class="string">'n = '</span>))</span><br><span class="line"><span class="comment"># 当需要计算阶乘的时候不用再写循环求阶乘而是直接调用已经定义好的函数</span></span><br><span class="line">print(factorial(m) // factorial(n) // factorial(m - n))</span><br></pre></td></tr></table></figure><blockquote><p><strong>说明：</strong>Python的math模块中其实已经有一个factorial函数了，事实上要计算阶乘可以直接使用这个现成的函数而不用自己定义。下面例子中的某些函数其实Python中也是内置了，我们这里是为了讲解函数的定义和使用才把它们又实现了一遍，实际开发中不建议做这种低级的重复性的工作。</p></blockquote><h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><p>函数是绝大多数编程语言中都支持的一个代码的“构建块”，但是Python中的函数与其他语言中的函数还是有很多不太相同的地方，其中一个显著的区别就是Python对函数参数的处理。在Python中，函数的参数可以有默认值，也支持使用可变参数，所以Python并不需要像其他语言一样支持<a href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD" target="_blank" rel="noopener">函数的重载</a>，因为我们在定义一个函数的时候可以让它有多种不同的使用方式，下面是两个小例子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">roll_dice</span><span class="params">(n=<span class="number">2</span>)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    摇色子</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    :param n: 色子的个数</span></span><br><span class="line"><span class="string">    :return: n颗色子点数之和</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(n):</span><br><span class="line">        total += randint(<span class="number">1</span>, <span class="number">6</span>)</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a=<span class="number">0</span>, b=<span class="number">0</span>, c=<span class="number">0</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b + c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果没有指定参数那么使用默认值摇两颗色子</span></span><br><span class="line">print(roll_dice())</span><br><span class="line"><span class="comment"># 摇三颗色子</span></span><br><span class="line">print(roll_dice(<span class="number">3</span>))</span><br><span class="line">print(add())</span><br><span class="line">print(add(<span class="number">1</span>))</span><br><span class="line">print(add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">print(add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="comment"># 传递参数时可以不按照设定的顺序进行传递</span></span><br><span class="line">print(add(c=<span class="number">50</span>, a=<span class="number">100</span>, b=<span class="number">200</span>))</span><br></pre></td></tr></table></figure><p>我们给上面两个函数的参数都设定了默认值，这也就意味着如果在调用函数的时候如果没有传入对应参数的值时将使用该参数的默认值，所以在上面的代码中我们可以用各种不同的方式去调用<code>add</code>函数，这跟其他很多语言中函数重载的效果是一致的。</p><p>其实上面的<code>add</code>函数还有更好的实现方案，因为我们可能会对0个或多个参数进行加法运算，而具体有多少个参数是由调用者来决定，我们作为函数的设计者对这一点是一无所知的，因此在不确定参数个数的时候，我们可以使用可变参数，代码如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在参数名前面的*表示args是一个可变参数</span></span><br><span class="line"><span class="comment"># 即在调用add函数时可以传入0个或多个参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(*args)</span>:</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> val <span class="keyword">in</span> args:</span><br><span class="line">        total += val</span><br><span class="line">    <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(add())</span><br><span class="line">print(add(<span class="number">1</span>))</span><br><span class="line">print(add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">print(add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">print(add(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>))</span><br></pre></td></tr></table></figure><h3 id="用模块管理函数"><a href="#用模块管理函数" class="headerlink" title="用模块管理函数"></a>用模块管理函数</h3><p>对于任何一种编程语言来说，给变量、函数这样的标识符起名字都是一个让人头疼的问题，因为我们会遇到命名冲突这种尴尬的情况。最简单的场景就是在同一个.py文件中定义了两个同名函数，由于Python没有函数重载的概念，那么后面的定义会覆盖之前的定义，也就意味着两个函数同名函数实际上只有一个是存在的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'hello, world!'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'goodbye, world!'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面的代码会输出什么呢？</span></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>当然上面的这种情况我们很容易就能避免，但是如果项目是由多人协作进行团队开发的时候，团队中可能有多个程序员都定义了名为<code>foo</code>的函数，那么怎么解决这种命名冲突呢？答案其实很简单，Python中每个文件就代表了一个模块（module），我们在不同的模块中可以有同名的函数，在使用函数的时候我们通过<code>import</code>关键字导入指定的模块就可以区分到底要使用的是哪个模块中的<code>foo</code>函数，代码如下所示。</p><p>module1.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'hello, world!'</span>)</span><br></pre></td></tr></table></figure><p>module2.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'goodbye, world!'</span>)</span><br></pre></td></tr></table></figure><p>test.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> module1 <span class="keyword">import</span> foo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出hello, world!</span></span><br><span class="line">foo()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> module2 <span class="keyword">import</span> foo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出goodbye, world!</span></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>也可以按照如下所示的方式来区分到底要使用哪一个<code>foo</code>函数。</p><p>test.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> module1 <span class="keyword">as</span> m1</span><br><span class="line"><span class="keyword">import</span> module2 <span class="keyword">as</span> m2</span><br><span class="line"></span><br><span class="line">m1.foo()</span><br><span class="line">m2.foo()</span><br></pre></td></tr></table></figure><p>但是如果将代码写成了下面的样子，那么程序中调用的是最后导入的那个<code>foo</code>，因为后导入的foo覆盖了之前导入的<code>foo</code>。</p><p>test.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> module1 <span class="keyword">import</span> foo</span><br><span class="line"><span class="keyword">from</span> module2 <span class="keyword">import</span> foo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出goodbye, world!</span></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>test.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> module2 <span class="keyword">import</span> foo</span><br><span class="line"><span class="keyword">from</span> module1 <span class="keyword">import</span> foo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出hello, world!</span></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>需要说明的是，如果我们导入的模块除了定义函数之外还中有可以执行代码，那么Python解释器在导入这个模块时就会执行这些代码，事实上我们可能并不希望如此，因此如果我们在模块中编写了执行代码，最好是将这些执行代码放入如下所示的条件中，这样的话除非直接运行该模块，if条件下的这些代码是不会执行的，因为只有直接执行的模块的名字才是“__main__”。</p><p>module3.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># __name__是Python中一个隐含的变量它代表了模块的名字</span></span><br><span class="line"><span class="comment"># 只有被Python解释器直接执行的模块的名字才是__main__</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'call foo()'</span>)</span><br><span class="line">    foo()</span><br><span class="line">    print(<span class="string">'call bar()'</span>)</span><br><span class="line">    bar()</span><br></pre></td></tr></table></figure><p>test.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> module3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入module3时 不会执行模块中if条件成立时的代码 因为模块的名字是module3而不是__main__</span></span><br></pre></td></tr></table></figure><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><h4 id="练习1：实现计算求最大公约数和最小公倍数的函数。"><a href="#练习1：实现计算求最大公约数和最小公倍数的函数。" class="headerlink" title="练习1：实现计算求最大公约数和最小公倍数的函数。"></a>练习1：实现计算求最大公约数和最小公倍数的函数。</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gcd</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    (x, y) = (y, x) <span class="keyword">if</span> x &gt; y <span class="keyword">else</span> (x, y)</span><br><span class="line">    <span class="keyword">for</span> factor <span class="keyword">in</span> range(x, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">if</span> x % factor == <span class="number">0</span> <span class="keyword">and</span> y % factor == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> factor</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lcm</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * y // gcd(x, y)</span><br></pre></td></tr></table></figure><h4 id="练习2：实现判断一个数是不是回文数的函数。"><a href="#练习2：实现判断一个数是不是回文数的函数。" class="headerlink" title="练习2：实现判断一个数是不是回文数的函数。"></a>练习2：实现判断一个数是不是回文数的函数。</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_palindrome</span><span class="params">(num)</span>:</span></span><br><span class="line">    temp = num</span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> temp &gt; <span class="number">0</span>:</span><br><span class="line">        total = total * <span class="number">10</span> + temp % <span class="number">10</span></span><br><span class="line">        temp //= <span class="number">10</span></span><br><span class="line">    <span class="keyword">return</span> total == num</span><br></pre></td></tr></table></figure><h4 id="练习3：实现判断一个数是不是素数的函数。"><a href="#练习3：实现判断一个数是不是素数的函数。" class="headerlink" title="练习3：实现判断一个数是不是素数的函数。"></a>练习3：实现判断一个数是不是素数的函数。</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_prime</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> factor <span class="keyword">in</span> range(<span class="number">2</span>, num):</span><br><span class="line">        <span class="keyword">if</span> num % factor == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span> <span class="keyword">if</span> num != <span class="number">1</span> <span class="keyword">else</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="练习4：写一个程序判断输入的正整数是不是回文素数。"><a href="#练习4：写一个程序判断输入的正整数是不是回文素数。" class="headerlink" title="练习4：写一个程序判断输入的正整数是不是回文素数。"></a>练习4：写一个程序判断输入的正整数是不是回文素数。</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    num = int(input(<span class="string">'请输入正整数: '</span>))</span><br><span class="line">    <span class="keyword">if</span> is_palindrome(num) <span class="keyword">and</span> is_prime(num):</span><br><span class="line">        print(<span class="string">'%d是回文素数'</span> % num)</span><br></pre></td></tr></table></figure><p>通过上面的程序可以看出，当我们将代码中重复出现的和相对独立的功能抽取成函数后，我们可以组合使用这些函数来解决更为复杂的问题，这也是我们为什么要定义和使用函数的一个非常重要的原因。</p><p>最后，我们来讨论一下Python中有关变量作用域的问题。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    b = <span class="string">'hello'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span>  <span class="comment"># Python中可以在函数内部再定义函数</span></span><br><span class="line">        c = <span class="literal">True</span></span><br><span class="line">        print(a)</span><br><span class="line">        print(b)</span><br><span class="line">        print(c)</span><br><span class="line"></span><br><span class="line">    bar()</span><br><span class="line">    <span class="comment"># print(c)  # NameError: name 'c' is not defined</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = <span class="number">100</span></span><br><span class="line">    <span class="comment"># print(b)  # NameError: name 'b' is not defined</span></span><br><span class="line">    foo()</span><br></pre></td></tr></table></figure><p>上面的代码能够顺利的执行并且打印出100和“hello”，但我们注意到了，在<code>bar</code>函数的内部并没有定义<code>a</code>和<code>b</code>两个变量，那么<code>a</code>和<code>b</code>是从哪里来的。我们在上面代码的<code>if</code>分支中定义了一个变量<code>a</code>，这是一个全局变量（global variable），属于全局作用域，因为它没有定义在任何一个函数中。在上面的<code>foo</code>函数中我们定义了变量<code>b</code>，这是一个定义在函数中的局部变量（local variable），属于局部作用域，在<code>foo</code>函数的外部并不能访问到它；但对于<code>foo</code>函数内部的<code>bar</code>函数来说，变量<code>b</code>属于嵌套作用域，在<code>bar</code>函数中我们是可以访问到它的。<code>bar</code>函数中的变量<code>c</code>属于局部作用域，在<code>bar</code>函数之外是无法访问的。事实上，Python查找一个变量时会按照“局部作用域”、“嵌套作用域”、“全局作用域”和“内置作用域”的顺序进行搜索，前三者我们在上面的代码中已经看到了，所谓的“内置作用域”就是Python内置的那些隐含标识符<code>min</code>、<code>len</code>等都属于内置作用域）。</p><p>再看看下面这段代码，我们希望通过函数调用修改全局变量<code>a</code>的值，但实际上下面的代码是做不到的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    a = <span class="number">200</span></span><br><span class="line">    print(a)  <span class="comment"># 200</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = <span class="number">100</span></span><br><span class="line">    foo()</span><br><span class="line">    print(a)  <span class="comment"># 100</span></span><br></pre></td></tr></table></figure><p>在调用<code>foo</code>函数后，我们发现<code>a</code>的值仍然是100，这是因为当我们在函数<code>foo</code>中写<code>a = 200</code>的时候，是重新定义了一个名字为<code>a</code>的局部变量，它跟全局作用域的<code>a</code>并不是同一个变量，因为局部作用域中有了自己的变量<code>a</code>，因此<code>foo</code>函数不再搜索全局作用域中的<code>a</code>。如果我们希望在<code>foo</code>函数中修改全局作用域中的<code>a</code>，代码如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    a = <span class="number">200</span></span><br><span class="line">    print(a)  <span class="comment"># 200</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = <span class="number">100</span></span><br><span class="line">    foo()</span><br><span class="line">    print(a)  <span class="comment"># 200</span></span><br></pre></td></tr></table></figure><p>我们可以使用<code>global</code>关键字来指示<code>foo</code>函数中的变量<code>a</code>来自于全局作用域，如果全局作用域中没有<code>a</code>，那么下面一行的代码就会定义变量<code>a</code>并将其置于全局作用域。同理，如果我们希望函数内部的函数能够修改嵌套作用域中的变量，可以使用<code>nonlocal</code>关键字来指示变量来自于嵌套作用域，请大家自行试验。</p><p>在实际开发中，我们应该尽量减少对全局变量的使用，因为全局变量的作用域和影响过于广泛，可能会发生意料之外的修改和使用，除此之外全局变量比局部变量拥有更长的生命周期，可能导致对象占用的内存长时间无法被<a href="https://zh.wikipedia.org/wiki/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)" target="_blank" rel="noopener">垃圾回收</a>。事实上，减少对全局变量的使用，也是降低代码之间耦合度的一个重要举措，同时也是对<a href="https://zh.wikipedia.org/zh-hans/%E5%BE%97%E5%A2%A8%E5%BF%92%E8%80%B3%E5%AE%9A%E5%BE%8B" target="_blank" rel="noopener">迪米特法则</a>的践行。减少全局变量的使用就意味着我们应该尽量让变量的作用域在函数的内部，但是如果我们希望将一个局部变量的生命周期延长，使其在函数调用结束后依然可以访问，这时候就需要使用<a href="https://zh.wikipedia.org/wiki/%E9%97%AD%E5%8C%85_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)" target="_blank" rel="noopener">闭包</a>，这个我们在后续的内容中进行讲解。</p><blockquote><p><strong>说明</strong>：很多人经常会将“闭包”一词和<a href="https://zh.wikipedia.org/wiki/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">“匿名函数”</a>混为一谈，但实际上它们是不同的概念，如果想提前了解这个概念，推荐看看<a href="https://zh.wikipedia.org/wiki/" target="_blank" rel="noopener">维基百科</a>或者<a href="https://www.zhihu.com/" target="_blank" rel="noopener">知乎</a>上对这个概念的讨论。</p></blockquote><p>说了那么多，其实结论很简单，从现在开始我们可以将Python代码按照下面的格式进行书写，这一点点的改进其实就是在我们理解了函数和作用域的基础上跨出的巨大的一步。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># Todo: Add your code here</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://guardianss.github.io/pypython-%E2%80%94%E2%80%94-%E5%87%BD%E6%95%B0%E5%92%8C%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>pypython —— 面向对象进阶</title>
      <link>https://guardianss.github.io/pypython-%E2%80%94%E2%80%94-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6.html</link>
      <guid>https://guardianss.github.io/pypython-%E2%80%94%E2%80%94-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6.html</guid>
      <pubDate>Wed, 13 May 2020 03:20:52 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot;
          
        
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="面向对象进阶"><a href="#面向对象进阶" class="headerlink" title="面向对象进阶"></a>面向对象进阶</h2><p>在前面的章节我们已经了解了面向对象的入门知识，知道了如何定义类，如何创建对象以及如何给对象发消息。为了能够更好的使用面向对象编程思想进行程序开发，我们还需要对Python中的面向对象编程进行更为深入的了解。</p><h3 id="property装饰器"><a href="#property装饰器" class="headerlink" title="@property装饰器"></a>@property装饰器</h3><p>之前我们讨论过Python中属性和方法访问权限的问题，虽然我们不建议将属性设置为私有的，但是如果直接将属性暴露给外界也是有问题的，比如我们没有办法检查赋给属性的值是否有效。我们之前的建议是将属性命名以单下划线开头，通过这种方式来暗示属性是受保护的，不建议外界直接访问，那么如果想访问属性可以通过属性的getter（访问器）和setter（修改器）方法进行对应的操作。如果要做到这点，就可以考虑使用@property包装器来包装getter和setter方法，使得对属性的访问既安全又方便，代码如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self._name = name</span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 访问器 - getter方法</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 访问器 - getter方法</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._age</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 修改器 - setter方法</span></span><br><span class="line"><span class="meta">    @age.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self, age)</span>:</span></span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">play</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self._age &lt;= <span class="number">16</span>:</span><br><span class="line">            print(<span class="string">'%s正在玩飞行棋.'</span> % self._name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'%s正在玩斗地主.'</span> % self._name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    person = Person(<span class="string">'王大锤'</span>, <span class="number">12</span>)</span><br><span class="line">    person.play()</span><br><span class="line">    person.age = <span class="number">22</span></span><br><span class="line">    person.play()</span><br><span class="line">    <span class="comment"># person.name = '白元芳'  # AttributeError: can't set attribute</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="slots-魔法"><a href="#slots-魔法" class="headerlink" title="__slots__魔法"></a>__slots__魔法</h3><p>我们讲到这里，不知道大家是否已经意识到，Python是一门<a href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">动态语言</a>。通常，动态语言允许我们在程序运行时给对象绑定新的属性或方法，当然也可以对已经绑定的属性和方法进行解绑定。但是如果我们需要限定自定义类型的对象只能绑定某些属性，可以通过在类中定义__slots__变量来进行限定。需要注意的是__slots__的限定只对当前类的对象生效，对子类并不起任何作用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 限定Person对象只能绑定_name, _age和_gender属性</span></span><br><span class="line">    __slots__ = (<span class="string">'_name'</span>, <span class="string">'_age'</span>, <span class="string">'_gender'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self._name = name</span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @age.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self, age)</span>:</span></span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">play</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self._age &lt;= <span class="number">16</span>:</span><br><span class="line">            print(<span class="string">'%s正在玩飞行棋.'</span> % self._name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'%s正在玩斗地主.'</span> % self._name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    person = Person(<span class="string">'王大锤'</span>, <span class="number">22</span>)</span><br><span class="line">    person.play()</span><br><span class="line">    person._gender = <span class="string">'男'</span></span><br><span class="line">    <span class="comment"># AttributeError: 'Person' object has no attribute '_is_gay'</span></span><br><span class="line">    <span class="comment"># person._is_gay = True</span></span><br></pre></td></tr></table></figure><h3 id="静态方法和类方法"><a href="#静态方法和类方法" class="headerlink" title="静态方法和类方法"></a>静态方法和类方法</h3><p>之前，我们在类中定义的方法都是对象方法，也就是说这些方法都是发送给对象的消息。实际上，我们写在类中的方法并不需要都是对象方法，例如我们定义一个“三角形”类，通过传入三条边长来构造三角形，并提供计算周长和面积的方法，但是传入的三条边长未必能构造出三角形对象，因此我们可以先写一个方法来验证三条边长是否可以构成三角形，这个方法很显然就不是对象方法，因为在调用这个方法时三角形对象尚未创建出来（因为都不知道三条边能不能构成三角形），所以这个方法是属于三角形类而并不属于三角形对象的。我们可以使用静态方法来解决这类问题，代码如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangle</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, a, b, c)</span>:</span></span><br><span class="line">        self._a = a</span><br><span class="line">        self._b = b</span><br><span class="line">        self._c = c</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_valid</span><span class="params">(a, b, c)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> a + b &gt; c <span class="keyword">and</span> b + c &gt; a <span class="keyword">and</span> a + c &gt; b</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">perimeter</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._a + self._b + self._c</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">area</span><span class="params">(self)</span>:</span></span><br><span class="line">        half = self.perimeter() / <span class="number">2</span></span><br><span class="line">        <span class="keyword">return</span> sqrt(half * (half - self._a) *</span><br><span class="line">                    (half - self._b) * (half - self._c))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    a, b, c = <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span></span><br><span class="line">    <span class="comment"># 静态方法和类方法都是通过给类发消息来调用的</span></span><br><span class="line">    <span class="keyword">if</span> Triangle.is_valid(a, b, c):</span><br><span class="line">        t = Triangle(a, b, c)</span><br><span class="line">        print(t.perimeter())</span><br><span class="line">        <span class="comment"># 也可以通过给类发消息来调用对象方法但是要传入接收消息的对象作为参数</span></span><br><span class="line">        <span class="comment"># print(Triangle.perimeter(t))</span></span><br><span class="line">        print(t.area())</span><br><span class="line">        <span class="comment"># print(Triangle.area(t))</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'无法构成三角形.'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>和静态方法比较类似，Python还可以在类中定义类方法，类方法的第一个参数约定名为cls，它代表的是当前类相关的信息的对象（类本身也是一个对象，有的地方也称之为类的元数据对象），通过这个参数我们可以获取和类相关的信息并且可以创建出类的对象，代码如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time, localtime, sleep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""数字时钟"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, hour=<span class="number">0</span>, minute=<span class="number">0</span>, second=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self._hour = hour</span><br><span class="line">        self._minute = minute</span><br><span class="line">        self._second = second</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">now</span><span class="params">(cls)</span>:</span></span><br><span class="line">        ctime = localtime(time())</span><br><span class="line">        <span class="keyword">return</span> cls(ctime.tm_hour, ctime.tm_min, ctime.tm_sec)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""走字"""</span></span><br><span class="line">        self._second += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> self._second == <span class="number">60</span>:</span><br><span class="line">            self._second = <span class="number">0</span></span><br><span class="line">            self._minute += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> self._minute == <span class="number">60</span>:</span><br><span class="line">                self._minute = <span class="number">0</span></span><br><span class="line">                self._hour += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> self._hour == <span class="number">24</span>:</span><br><span class="line">                    self._hour = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""显示时间"""</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'%02d:%02d:%02d'</span> % \</span><br><span class="line">               (self._hour, self._minute, self._second)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 通过类方法创建对象并获取系统时间</span></span><br><span class="line">    clock = Clock.now()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(clock.show())</span><br><span class="line">        sleep(<span class="number">1</span>)</span><br><span class="line">        clock.run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h3><p>简单的说，类和类之间的关系有三种：is-a、has-a和use-a关系。</p><ul><li>is-a关系也叫继承或泛化，比如学生和人的关系、手机和电子产品的关系都属于继承关系。</li><li>has-a关系通常称之为关联，比如部门和员工的关系，汽车和引擎的关系都属于关联关系；关联关系如果是整体和部分的关联，那么我们称之为聚合关系；如果整体进一步负责了部分的生命周期（整体和部分是不可分割的，同时同在也同时消亡），那么这种就是最强的关联关系，我们称之为合成关系。</li><li>use-a关系通常称之为依赖，比如司机有一个驾驶的行为（方法），其中（的参数）使用到了汽车，那么司机和汽车的关系就是依赖关系。</li></ul><p>我们可以使用一种叫做<a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">UML</a>（统一建模语言）的东西来进行面向对象建模，其中一项重要的工作就是把类和类之间的关系用标准化的图形符号描述出来。关于UML我们在这里不做详细的介绍，有兴趣的读者可以自行阅读<a href="https://e.jd.com/30392949.html" target="_blank" rel="noopener">《UML面向对象设计基础》</a>一书。</p><p><img src="/" class="lazyload" data-src="./res/uml-components.png"  alt=""></p><p><img src="/" class="lazyload" data-src="./res/uml-example.png"  alt=""></p><p>利用类之间的这些关系，我们可以在已有类的基础上来完成某些操作，也可以在已有类的基础上创建新的类，这些都是实现代码复用的重要手段。复用现有的代码不仅可以减少开发的工作量，也有利于代码的管理和维护，这是我们在日常工作中都会使用到的技术手段。</p><h3 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h3><p>刚才我们提到了，可以在已有类的基础上创建新类，这其中的一种做法就是让一个类从另一个类那里将属性和方法直接继承下来，从而减少重复代码的编写。提供继承信息的我们称之为父类，也叫超类或基类；得到继承信息的我们称之为子类，也叫派生类或衍生类。子类除了继承父类提供的属性和方法，还可以定义自己特有的属性和方法，所以子类比父类拥有的更多的能力，在实际开发中，我们经常会用子类对象去替换掉一个父类对象，这是面向对象编程中一个常见的行为，对应的原则称之为<a href="https://zh.wikipedia.org/wiki/%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99" target="_blank" rel="noopener">里氏替换原则</a>。下面我们先看一个继承的例子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""人"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self._name = name</span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._age</span><br><span class="line"></span><br><span class="line"><span class="meta">    @age.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self, age)</span>:</span></span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">play</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'%s正在愉快的玩耍.'</span> % self._name)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">watch_av</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self._age &gt;= <span class="number">18</span>:</span><br><span class="line">            print(<span class="string">'%s正在观看爱情动作片.'</span> % self._name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'%s只能观看《熊出没》.'</span> % self._name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="string">"""学生"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, grade)</span>:</span></span><br><span class="line">        super().__init__(name, age)</span><br><span class="line">        self._grade = grade</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">grade</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._grade</span><br><span class="line"></span><br><span class="line"><span class="meta">    @grade.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">grade</span><span class="params">(self, grade)</span>:</span></span><br><span class="line">        self._grade = grade</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">study</span><span class="params">(self, course)</span>:</span></span><br><span class="line">        print(<span class="string">'%s的%s正在学习%s.'</span> % (self._grade, self._name, course))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="string">"""老师"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, title)</span>:</span></span><br><span class="line">        super().__init__(name, age)</span><br><span class="line">        self._title = title</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">title</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._title</span><br><span class="line"></span><br><span class="line"><span class="meta">    @title.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">title</span><span class="params">(self, title)</span>:</span></span><br><span class="line">        self._title = title</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">teach</span><span class="params">(self, course)</span>:</span></span><br><span class="line">        print(<span class="string">'%s%s正在讲%s.'</span> % (self._name, self._title, course))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    stu = Student(<span class="string">'王大锤'</span>, <span class="number">15</span>, <span class="string">'初三'</span>)</span><br><span class="line">    stu.study(<span class="string">'数学'</span>)</span><br><span class="line">    stu.watch_av()</span><br><span class="line">    t = Teacher(<span class="string">'骆昊'</span>, <span class="number">38</span>, <span class="string">'老叫兽'</span>)</span><br><span class="line">    t.teach(<span class="string">'Python程序设计'</span>)</span><br><span class="line">    t.watch_av()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>子类在继承了父类的方法后，可以对父类已有的方法给出新的实现版本，这个动作称之为方法重写（override）。通过方法重写我们可以让父类的同一个行为在子类中拥有不同的实现版本，当我们调用这个经过子类重写的方法时，不同的子类对象会表现出不同的行为，这个就是多态（poly-morphism）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span><span class="params">(object, metaclass=ABCMeta)</span>:</span></span><br><span class="line">    <span class="string">"""宠物"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, nickname)</span>:</span></span><br><span class="line">        self._nickname = nickname</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_voice</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""发出声音"""</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Pet)</span>:</span></span><br><span class="line">    <span class="string">"""狗"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_voice</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'%s: 汪汪汪...'</span> % self._nickname)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span><span class="params">(Pet)</span>:</span></span><br><span class="line">    <span class="string">"""猫"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_voice</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'%s: 喵...喵...'</span> % self._nickname)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    pets = [Dog(<span class="string">'旺财'</span>), Cat(<span class="string">'凯蒂'</span>), Dog(<span class="string">'大黄'</span>)]</span><br><span class="line">    <span class="keyword">for</span> pet <span class="keyword">in</span> pets:</span><br><span class="line">        pet.make_voice()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们将<code>Pet</code>类处理成了一个抽象类，所谓抽象类就是不能够创建对象的类，这种类的存在就是专门为了让其他类去继承它。Python从语法层面并没有像Java或C#那样提供对抽象类的支持，但是我们可以通过<code>abc</code>模块的<code>ABCMeta</code>元类和<code>abstractmethod</code>包装器来达到抽象类的效果，如果一个类中存在抽象方法那么这个类就不能够实例化（创建对象）。上面的代码中，<code>Dog</code>和<code>Cat</code>两个子类分别对<code>Pet</code>类中的<code>make_voice</code>抽象方法进行了重写并给出了不同的实现版本，当我们在<code>main</code>函数中调用该方法时，这个方法就表现出了多态行为（同样的方法做了不同的事情）。</p><h3 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h3><h4 id="案例1：奥特曼打小怪兽"><a href="#案例1：奥特曼打小怪兽" class="headerlink" title="案例1：奥特曼打小怪兽"></a>案例1：奥特曼打小怪兽</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint, randrange</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fighter</span><span class="params">(object, metaclass=ABCMeta)</span>:</span></span><br><span class="line">    <span class="string">"""战斗者"""</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 通过__slots__魔法限定对象可以绑定的成员变量</span></span><br><span class="line">    __slots__ = (<span class="string">'_name'</span>, <span class="string">'_hp'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, hp)</span>:</span></span><br><span class="line">        <span class="string">"""初始化方法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param name: 名字</span></span><br><span class="line"><span class="string">        :param hp: 生命值</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self._name = name</span><br><span class="line">        self._hp = hp</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hp</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._hp</span><br><span class="line"></span><br><span class="line"><span class="meta">    @hp.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hp</span><span class="params">(self, hp)</span>:</span></span><br><span class="line">        self._hp = hp <span class="keyword">if</span> hp &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">alive</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._hp &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">attack</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="string">"""攻击</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param other: 被攻击的对象</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ultraman</span><span class="params">(Fighter)</span>:</span></span><br><span class="line">    <span class="string">"""奥特曼"""</span></span><br><span class="line"></span><br><span class="line">    __slots__ = (<span class="string">'_name'</span>, <span class="string">'_hp'</span>, <span class="string">'_mp'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, hp, mp)</span>:</span></span><br><span class="line">        <span class="string">"""初始化方法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param name: 名字</span></span><br><span class="line"><span class="string">        :param hp: 生命值</span></span><br><span class="line"><span class="string">        :param mp: 魔法值</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        super().__init__(name, hp)</span><br><span class="line">        self._mp = mp</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">attack</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        other.hp -= randint(<span class="number">15</span>, <span class="number">25</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">huge_attack</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="string">"""究极必杀技(打掉对方至少50点或四分之三的血)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param other: 被攻击的对象</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :return: 使用成功返回True否则返回False</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self._mp &gt;= <span class="number">50</span>:</span><br><span class="line">            self._mp -= <span class="number">50</span></span><br><span class="line">            injury = other.hp * <span class="number">3</span> // <span class="number">4</span></span><br><span class="line">            injury = injury <span class="keyword">if</span> injury &gt;= <span class="number">50</span> <span class="keyword">else</span> <span class="number">50</span></span><br><span class="line">            other.hp -= injury</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.attack(other)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">magic_attack</span><span class="params">(self, others)</span>:</span></span><br><span class="line">        <span class="string">"""魔法攻击</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param others: 被攻击的群体</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :return: 使用魔法成功返回True否则返回False</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self._mp &gt;= <span class="number">20</span>:</span><br><span class="line">            self._mp -= <span class="number">20</span></span><br><span class="line">            <span class="keyword">for</span> temp <span class="keyword">in</span> others:</span><br><span class="line">                <span class="keyword">if</span> temp.alive:</span><br><span class="line">                    temp.hp -= randint(<span class="number">10</span>, <span class="number">15</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">resume</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""恢复魔法值"""</span></span><br><span class="line">        incr_point = randint(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">        self._mp += incr_point</span><br><span class="line">        <span class="keyword">return</span> incr_point</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'~~~%s奥特曼~~~\n'</span> % self._name + \</span><br><span class="line">            <span class="string">'生命值: %d\n'</span> % self._hp + \</span><br><span class="line">            <span class="string">'魔法值: %d\n'</span> % self._mp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monster</span><span class="params">(Fighter)</span>:</span></span><br><span class="line">    <span class="string">"""小怪兽"""</span></span><br><span class="line"></span><br><span class="line">    __slots__ = (<span class="string">'_name'</span>, <span class="string">'_hp'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">attack</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        other.hp -= randint(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'~~~%s小怪兽~~~\n'</span> % self._name + \</span><br><span class="line">            <span class="string">'生命值: %d\n'</span> % self._hp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_any_alive</span><span class="params">(monsters)</span>:</span></span><br><span class="line">    <span class="string">"""判断有没有小怪兽是活着的"""</span></span><br><span class="line">    <span class="keyword">for</span> monster <span class="keyword">in</span> monsters:</span><br><span class="line">        <span class="keyword">if</span> monster.alive &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_alive_one</span><span class="params">(monsters)</span>:</span></span><br><span class="line">    <span class="string">"""选中一只活着的小怪兽"""</span></span><br><span class="line">    monsters_len = len(monsters)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        index = randrange(monsters_len)</span><br><span class="line">        monster = monsters[index]</span><br><span class="line">        <span class="keyword">if</span> monster.alive &gt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> monster</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">display_info</span><span class="params">(ultraman, monsters)</span>:</span></span><br><span class="line">    <span class="string">"""显示奥特曼和小怪兽的信息"""</span></span><br><span class="line">    print(ultraman)</span><br><span class="line">    <span class="keyword">for</span> monster <span class="keyword">in</span> monsters:</span><br><span class="line">        print(monster, end=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    u = Ultraman(<span class="string">'骆昊'</span>, <span class="number">1000</span>, <span class="number">120</span>)</span><br><span class="line">    m1 = Monster(<span class="string">'狄仁杰'</span>, <span class="number">250</span>)</span><br><span class="line">    m2 = Monster(<span class="string">'白元芳'</span>, <span class="number">500</span>)</span><br><span class="line">    m3 = Monster(<span class="string">'王大锤'</span>, <span class="number">750</span>)</span><br><span class="line">    ms = [m1, m2, m3]</span><br><span class="line">    fight_round = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> u.alive <span class="keyword">and</span> is_any_alive(ms):</span><br><span class="line">        print(<span class="string">'========第%02d回合========'</span> % fight_round)</span><br><span class="line">        m = select_alive_one(ms)  <span class="comment"># 选中一只小怪兽</span></span><br><span class="line">        skill = randint(<span class="number">1</span>, <span class="number">10</span>)   <span class="comment"># 通过随机数选择使用哪种技能</span></span><br><span class="line">        <span class="keyword">if</span> skill &lt;= <span class="number">6</span>:  <span class="comment"># 60%的概率使用普通攻击</span></span><br><span class="line">            print(<span class="string">'%s使用普通攻击打了%s.'</span> % (u.name, m.name))</span><br><span class="line">            u.attack(m)</span><br><span class="line">            print(<span class="string">'%s的魔法值恢复了%d点.'</span> % (u.name, u.resume()))</span><br><span class="line">        <span class="keyword">elif</span> skill &lt;= <span class="number">9</span>:  <span class="comment"># 30%的概率使用魔法攻击(可能因魔法值不足而失败)</span></span><br><span class="line">            <span class="keyword">if</span> u.magic_attack(ms):</span><br><span class="line">                print(<span class="string">'%s使用了魔法攻击.'</span> % u.name)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">'%s使用魔法失败.'</span> % u.name)</span><br><span class="line">        <span class="keyword">else</span>:  <span class="comment"># 10%的概率使用究极必杀技(如果魔法值不足则使用普通攻击)</span></span><br><span class="line">            <span class="keyword">if</span> u.huge_attack(m):</span><br><span class="line">                print(<span class="string">'%s使用究极必杀技虐了%s.'</span> % (u.name, m.name))</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(<span class="string">'%s使用普通攻击打了%s.'</span> % (u.name, m.name))</span><br><span class="line">                print(<span class="string">'%s的魔法值恢复了%d点.'</span> % (u.name, u.resume()))</span><br><span class="line">        <span class="keyword">if</span> m.alive &gt; <span class="number">0</span>:  <span class="comment"># 如果选中的小怪兽没有死就回击奥特曼</span></span><br><span class="line">            print(<span class="string">'%s回击了%s.'</span> % (m.name, u.name))</span><br><span class="line">            m.attack(u)</span><br><span class="line">        display_info(u, ms)  <span class="comment"># 每个回合结束后显示奥特曼和小怪兽的信息</span></span><br><span class="line">        fight_round += <span class="number">1</span></span><br><span class="line">    print(<span class="string">'\n========战斗结束!========\n'</span>)</span><br><span class="line">    <span class="keyword">if</span> u.alive &gt; <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">'%s奥特曼胜利!'</span> % u.name)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">'小怪兽胜利!'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="案例2：扑克游戏"><a href="#案例2：扑克游戏" class="headerlink" title="案例2：扑克游戏"></a>案例2：扑克游戏</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Card</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""一张牌"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, suite, face)</span>:</span></span><br><span class="line">        self._suite = suite</span><br><span class="line">        self._face = face</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">face</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._face</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">suite</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._suite</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self._face == <span class="number">1</span>:</span><br><span class="line">            face_str = <span class="string">'A'</span></span><br><span class="line">        <span class="keyword">elif</span> self._face == <span class="number">11</span>:</span><br><span class="line">            face_str = <span class="string">'J'</span></span><br><span class="line">        <span class="keyword">elif</span> self._face == <span class="number">12</span>:</span><br><span class="line">            face_str = <span class="string">'Q'</span></span><br><span class="line">        <span class="keyword">elif</span> self._face == <span class="number">13</span>:</span><br><span class="line">            face_str = <span class="string">'K'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            face_str = str(self._face)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'%s%s'</span> % (self._suite, face_str)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__str__()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Poker</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""一副牌"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._cards = [Card(suite, face) </span><br><span class="line">                       <span class="keyword">for</span> suite <span class="keyword">in</span> <span class="string">'♠♥♣♦'</span></span><br><span class="line">                       <span class="keyword">for</span> face <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">14</span>)]</span><br><span class="line">        self._current = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cards</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._cards</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shuffle</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""洗牌(随机乱序)"""</span></span><br><span class="line">        self._current = <span class="number">0</span></span><br><span class="line">        random.shuffle(self._cards)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""发牌"""</span></span><br><span class="line">        card = self._cards[self._current]</span><br><span class="line">        self._current += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> card</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_next</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""还有没有牌"""</span></span><br><span class="line">        <span class="keyword">return</span> self._current &lt; len(self._cards)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Player</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""玩家"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self._name = name</span><br><span class="line">        self._cards_on_hand = []</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cards_on_hand</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._cards_on_hand</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, card)</span>:</span></span><br><span class="line">        <span class="string">"""摸牌"""</span></span><br><span class="line">        self._cards_on_hand.append(card)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">arrange</span><span class="params">(self, card_key)</span>:</span></span><br><span class="line">        <span class="string">"""玩家整理手上的牌"""</span></span><br><span class="line">        self._cards_on_hand.sort(key=card_key)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 排序规则-先根据花色再根据点数排序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_key</span><span class="params">(card)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (card.suite, card.face)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    p = Poker()</span><br><span class="line">    p.shuffle()</span><br><span class="line">    players = [Player(<span class="string">'东邪'</span>), Player(<span class="string">'西毒'</span>), Player(<span class="string">'南帝'</span>), Player(<span class="string">'北丐'</span>)]</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">13</span>):</span><br><span class="line">        <span class="keyword">for</span> player <span class="keyword">in</span> players:</span><br><span class="line">            player.get(p.next)</span><br><span class="line">    <span class="keyword">for</span> player <span class="keyword">in</span> players:</span><br><span class="line">        print(player.name + <span class="string">':'</span>, end=<span class="string">' '</span>)</span><br><span class="line">        player.arrange(get_key)</span><br><span class="line">        print(player.cards_on_hand)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><blockquote><p><strong>说明</strong>：大家可以自己尝试在上面代码的基础上写一个简单的扑克游戏，例如21点(Black Jack)，游戏的规则可以自己在网上找一找。</p></blockquote><h4 id="案例3：工资结算系统"><a href="#案例3：工资结算系统" class="headerlink" title="案例3：工资结算系统"></a>案例3：工资结算系统</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">某公司有三种类型的员工 分别是部门经理、程序员和销售员</span></span><br><span class="line"><span class="string">需要设计一个工资结算系统 根据提供的员工信息来计算月薪</span></span><br><span class="line"><span class="string">部门经理的月薪是每月固定15000元</span></span><br><span class="line"><span class="string">程序员的月薪按本月工作时间计算 每小时150元</span></span><br><span class="line"><span class="string">销售员的月薪是1200元的底薪加上销售额5%的提成</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span><span class="params">(object, metaclass=ABCMeta)</span>:</span></span><br><span class="line">    <span class="string">"""员工"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        初始化方法</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param name: 姓名</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self._name = name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">name</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._name</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_salary</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        获得月薪</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :return: 月薪</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span><span class="params">(Employee)</span>:</span></span><br><span class="line">    <span class="string">"""部门经理"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_salary</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">15000.0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Programmer</span><span class="params">(Employee)</span>:</span></span><br><span class="line">    <span class="string">"""程序员"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, working_hour=<span class="number">0</span>)</span>:</span></span><br><span class="line">        super().__init__(name)</span><br><span class="line">        self._working_hour = working_hour</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">working_hour</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._working_hour</span><br><span class="line"></span><br><span class="line"><span class="meta">    @working_hour.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">working_hour</span><span class="params">(self, working_hour)</span>:</span></span><br><span class="line">        self._working_hour = working_hour <span class="keyword">if</span> working_hour &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_salary</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">150.0</span> * self._working_hour</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Salesman</span><span class="params">(Employee)</span>:</span></span><br><span class="line">    <span class="string">"""销售员"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, sales=<span class="number">0</span>)</span>:</span></span><br><span class="line">        super().__init__(name)</span><br><span class="line">        self._sales = sales</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sales</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._sales</span><br><span class="line"></span><br><span class="line"><span class="meta">    @sales.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sales</span><span class="params">(self, sales)</span>:</span></span><br><span class="line">        self._sales = sales <span class="keyword">if</span> sales &gt; <span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_salary</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1200.0</span> + self._sales * <span class="number">0.05</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    emps = [</span><br><span class="line">        Manager(<span class="string">'刘备'</span>), Programmer(<span class="string">'诸葛亮'</span>),</span><br><span class="line">        Manager(<span class="string">'曹操'</span>), Salesman(<span class="string">'荀彧'</span>),</span><br><span class="line">        Salesman(<span class="string">'吕布'</span>), Programmer(<span class="string">'张辽'</span>),</span><br><span class="line">        Programmer(<span class="string">'赵云'</span>)</span><br><span class="line">    ]</span><br><span class="line">    <span class="keyword">for</span> emp <span class="keyword">in</span> emps:</span><br><span class="line">        <span class="keyword">if</span> isinstance(emp, Programmer):</span><br><span class="line">            emp.working_hour = int(input(<span class="string">'请输入%s本月工作时间: '</span> % emp.name))</span><br><span class="line">        <span class="keyword">elif</span> isinstance(emp, Salesman):</span><br><span class="line">            emp.sales = float(input(<span class="string">'请输入%s本月销售额: '</span> % emp.name))</span><br><span class="line">        <span class="comment"># 同样是接收get_salary这个消息但是不同的员工表现出了不同的行为(多态)</span></span><br><span class="line">        print(<span class="string">'%s本月工资为: ￥%s元'</span> %</span><br><span class="line">              (emp.name, emp.get_salary()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      <comments>https://guardianss.github.io/pypython-%E2%80%94%E2%80%94-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BF%9B%E9%98%B6.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>python —— 进程和线程</title>
      <link>https://guardianss.github.io/python-%E2%80%94%E2%80%94-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.html</link>
      <guid>https://guardianss.github.io/python-%E2%80%94%E2%80%94-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.html</guid>
      <pubDate>Wed, 13 May 2020 03:20:26 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot;
          
        
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><p>今天我们使用的计算机早已进入多CPU或多核时代，而我们使用的操作系统都是支持“多任务”的操作系统，这使得我们可以同时运行多个程序，也可以将一个程序分解为若干个相对独立的子任务，让多个子任务并发的执行，从而缩短程序的执行时间，同时也让用户获得更好的体验。因此在当下不管是用什么编程语言进行开发，实现让程序同时执行多个任务也就是常说的“并发编程”，应该是程序员必备技能之一。为此，我们需要先讨论两个概念，一个叫进程，一个叫线程。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>进程就是操作系统中执行的一个程序，操作系统以进程为单位分配存储空间，每个进程都有自己的地址空间、数据栈以及其他用于跟踪进程执行的辅助数据，操作系统管理所有进程的执行，为它们合理的分配资源。进程可以通过fork或spawn的方式来创建新的进程来执行其他的任务，不过新的进程也有自己独立的内存空间，因此必须通过进程间通信机制（IPC，Inter-Process Communication）来实现数据共享，具体的方式包括管道、信号、套接字、共享内存区等。</p><p>一个进程还可以拥有多个并发的执行线索，简单的说就是拥有多个可以获得CPU调度的执行单元，这就是所谓的线程。由于线程在同一个进程下，它们可以共享相同的上下文，因此相对于进程而言，线程间的信息共享和通信更加容易。当然在单核CPU系统中，真正的并发是不可能的，因为在某个时刻能够获得CPU的只有唯一的一个线程，多个线程共享了CPU的执行时间。使用多线程实现并发编程为程序带来的好处是不言而喻的，最主要的体现在提升程序的性能和改善用户体验，今天我们使用的软件几乎都用到了多线程技术，这一点可以利用系统自带的进程监控工具（如macOS中的“活动监视器”、Windows中的“任务管理器”）来证实，如下图所示。</p><p><img src="/" class="lazyload" data-src="./res/macos-monitor.png"  alt=""></p><p>当然多线程也并不是没有坏处，站在其他进程的角度，多线程的程序对其他程序并不友好，因为它占用了更多的CPU执行时间，导致其他程序无法获得足够的CPU执行时间；另一方面，站在开发者的角度，编写和调试多线程的程序都对开发者有较高的要求，对于初学者来说更加困难。</p><p>Python既支持多进程又支持多线程，因此使用Python实现并发编程主要有3种方式：多进程、多线程、多进程+多线程。</p><h3 id="Python中的多进程"><a href="#Python中的多进程" class="headerlink" title="Python中的多进程"></a>Python中的多进程</h3><p>Unix和Linux操作系统上提供了<code>fork()</code>系统调用来创建进程，调用<code>fork()</code>函数的是父进程，创建出的是子进程，子进程是父进程的一个拷贝，但是子进程拥有自己的PID。<code>fork()</code>函数非常特殊它会返回两次，父进程中可以通过<code>fork()</code>函数的返回值得到子进程的PID，而子进程中的返回值永远都是0。Python的os模块提供了<code>fork()</code>函数。由于Windows系统没有<code>fork()</code>调用，因此要实现跨平台的多进程编程，可以使用multiprocessing模块的<code>Process</code>类来创建子进程，而且该模块还提供了更高级的封装，例如批量启动进程的进程池（<code>Pool</code>）、用于进程间通信的队列（<code>Queue</code>）和管道（<code>Pipe</code>）等。</p><p>下面用一个下载文件的例子来说明使用多进程和不使用多进程到底有什么差别，先看看下面的代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time, sleep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_task</span><span class="params">(filename)</span>:</span></span><br><span class="line">    print(<span class="string">'开始下载%s...'</span> % filename)</span><br><span class="line">    time_to_download = randint(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">    sleep(time_to_download)</span><br><span class="line">    print(<span class="string">'%s下载完成! 耗费了%d秒'</span> % (filename, time_to_download))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    start = time()</span><br><span class="line">    download_task(<span class="string">'Python从入门到住院.pdf'</span>)</span><br><span class="line">    download_task(<span class="string">'Peking Hot.avi'</span>)</span><br><span class="line">    end = time()</span><br><span class="line">    print(<span class="string">'总共耗费了%.2f秒.'</span> % (end - start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>下面是运行程序得到的一次运行结果。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">开始下载Python从入门到住院.pdf...</span><br><span class="line">Python从入门到住院.pdf下载完成! 耗费了6秒</span><br><span class="line">开始下载Peking Hot.avi...</span><br><span class="line">Peking Hot.avi下载完成! 耗费了7秒</span><br><span class="line">总共耗费了13.01秒.</span><br></pre></td></tr></table></figure><p>从上面的例子可以看出，如果程序中的代码只能按顺序一点点的往下执行，那么即使执行两个毫不相关的下载任务，也需要先等待一个文件下载完成后才能开始下一个下载任务，很显然这并不合理也没有效率。接下来我们使用多进程的方式将两个下载任务放到不同的进程中，代码如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> os <span class="keyword">import</span> getpid</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time, sleep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_task</span><span class="params">(filename)</span>:</span></span><br><span class="line">    print(<span class="string">'启动下载进程，进程号[%d].'</span> % getpid())</span><br><span class="line">    print(<span class="string">'开始下载%s...'</span> % filename)</span><br><span class="line">    time_to_download = randint(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">    sleep(time_to_download)</span><br><span class="line">    print(<span class="string">'%s下载完成! 耗费了%d秒'</span> % (filename, time_to_download))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    start = time()</span><br><span class="line">    p1 = Process(target=download_task, args=(<span class="string">'Python从入门到住院.pdf'</span>, ))</span><br><span class="line">    p1.start()</span><br><span class="line">    p2 = Process(target=download_task, args=(<span class="string">'Peking Hot.avi'</span>, ))</span><br><span class="line">    p2.start()</span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line">    end = time()</span><br><span class="line">    print(<span class="string">'总共耗费了%.2f秒.'</span> % (end - start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>在上面的代码中，我们通过<code>Process</code>类创建了进程对象，通过<code>target</code>参数我们传入一个函数来表示进程启动后要执行的代码，后面的<code>args</code>是一个元组，它代表了传递给函数的参数。<code>Process</code>对象的<code>start</code>方法用来启动进程，而<code>join</code>方法表示等待进程执行结束。运行上面的代码可以明显发现两个下载任务“同时”启动了，而且程序的执行时间将大大缩短，不再是两个任务的时间总和。下面是程序的一次执行结果。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">启动下载进程，进程号[1530].</span><br><span class="line">开始下载Python从入门到住院.pdf...</span><br><span class="line">启动下载进程，进程号[1531].</span><br><span class="line">开始下载Peking Hot.avi...</span><br><span class="line">Peking Hot.avi下载完成! 耗费了7秒</span><br><span class="line">Python从入门到住院.pdf下载完成! 耗费了10秒</span><br><span class="line">总共耗费了10.01秒.</span><br></pre></td></tr></table></figure><p>我们也可以使用subprocess模块中的类和函数来创建和启动子进程，然后通过管道来和子进程通信，这些内容我们不在此进行讲解，有兴趣的读者可以自己了解这些知识。接下来我们将重点放在如何实现两个进程间的通信。我们启动两个进程，一个输出Ping，一个输出Pong，两个进程输出的Ping和Pong加起来一共10个。听起来很简单吧，但是如果这样写可是错的哦。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">counter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub_task</span><span class="params">(string)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> counter</span><br><span class="line">    <span class="keyword">while</span> counter &lt; <span class="number">10</span>:</span><br><span class="line">        print(string, end=<span class="string">''</span>, flush=<span class="literal">True</span>)</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">        sleep(<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    Process(target=sub_task, args=(<span class="string">'Ping'</span>, )).start()</span><br><span class="line">    Process(target=sub_task, args=(<span class="string">'Pong'</span>, )).start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>看起来没毛病，但是最后的结果是Ping和Pong各输出了10个，Why？当我们在程序中创建进程的时候，子进程复制了父进程及其所有的数据结构，每个子进程有自己独立的内存空间，这也就意味着两个子进程中各有一个<code>counter</code>变量，所以结果也就可想而知了。要解决这个问题比较简单的办法是使用multiprocessing模块中的<code>Queue</code>类，它是可以被多个进程共享的队列，底层是通过管道和<a href="">信号量（semaphore）</a>机制来实现的，有兴趣的读者可以自己尝试一下。</p><h3 id="Python中的多线程"><a href="#Python中的多线程" class="headerlink" title="Python中的多线程"></a>Python中的多线程</h3><p>在Python早期的版本中就引入了thread模块（现在名为_thread）来实现多线程编程，然而该模块过于底层，而且很多功能都没有提供，因此目前的多线程开发我们推荐使用threading模块，该模块对多线程编程提供了更好的面向对象的封装。我们把刚才下载文件的例子用多线程的方式来实现一遍。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time, sleep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(filename)</span>:</span></span><br><span class="line">    print(<span class="string">'开始下载%s...'</span> % filename)</span><br><span class="line">    time_to_download = randint(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">    sleep(time_to_download)</span><br><span class="line">    print(<span class="string">'%s下载完成! 耗费了%d秒'</span> % (filename, time_to_download))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    start = time()</span><br><span class="line">    t1 = Thread(target=download, args=(<span class="string">'Python从入门到住院.pdf'</span>,))</span><br><span class="line">    t1.start()</span><br><span class="line">    t2 = Thread(target=download, args=(<span class="string">'Peking Hot.avi'</span>,))</span><br><span class="line">    t2.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line">    end = time()</span><br><span class="line">    print(<span class="string">'总共耗费了%.3f秒'</span> % (end - start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>我们可以直接使用threading模块的<code>Thread</code>类来创建线程，但是我们之前讲过一个非常重要的概念叫“继承”，我们可以从已有的类创建新类，因此也可以通过继承<code>Thread</code>类的方式来创建自定义的线程类，然后再创建线程对象并启动线程。代码如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time, sleep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadTask</span><span class="params">(Thread)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, filename)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self._filename = filename</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'开始下载%s...'</span> % self._filename)</span><br><span class="line">        time_to_download = randint(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">        sleep(time_to_download)</span><br><span class="line">        print(<span class="string">'%s下载完成! 耗费了%d秒'</span> % (self._filename, time_to_download))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    start = time()</span><br><span class="line">    t1 = DownloadTask(<span class="string">'Python从入门到住院.pdf'</span>)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2 = DownloadTask(<span class="string">'Peking Hot.avi'</span>)</span><br><span class="line">    t2.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line">    end = time()</span><br><span class="line">    print(<span class="string">'总共耗费了%.2f秒.'</span> % (end - start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>因为多个线程可以共享进程的内存空间，因此要实现多个线程间的通信相对简单，大家能想到的最直接的办法就是设置一个全局变量，多个线程共享这个全局变量即可。但是当多个线程共享同一个变量（我们通常称之为“资源”）的时候，很有可能产生不可控的结果从而导致程序失效甚至崩溃。如果一个资源被多个线程竞争使用，那么我们通常称之为“临界资源”，对“临界资源”的访问需要加上保护，否则资源会处于“混乱”的状态。下面的例子演示了100个线程向同一个银行账户转账（转入1元钱）的场景，在这个例子中，银行账户就是一个临界资源，在没有保护的情况下我们很有可能会得到错误的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._balance = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deposit</span><span class="params">(self, money)</span>:</span></span><br><span class="line">        <span class="comment"># 计算存款后的余额</span></span><br><span class="line">        new_balance = self._balance + money</span><br><span class="line">        <span class="comment"># 模拟受理存款业务需要0.01秒的时间</span></span><br><span class="line">        sleep(<span class="number">0.01</span>)</span><br><span class="line">        <span class="comment"># 修改账户余额</span></span><br><span class="line">        self._balance = new_balance</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">balance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._balance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddMoneyThread</span><span class="params">(Thread)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, account, money)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self._account = account</span><br><span class="line">        self._money = money</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._account.deposit(self._money)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    account = Account()</span><br><span class="line">    threads = []</span><br><span class="line">    <span class="comment"># 创建100个存款的线程向同一个账户中存钱</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        t = AddMoneyThread(account, <span class="number">1</span>)</span><br><span class="line">        threads.append(t)</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="comment"># 等所有存款的线程都执行完毕</span></span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line">    print(<span class="string">'账户余额为: ￥%d元'</span> % account.balance)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>运行上面的程序，结果让人大跌眼镜，100个线程分别向账户中转入1元钱，结果居然远远小于100元。之所以出现这种情况是因为我们没有对银行账户这个“临界资源”加以保护，多个线程同时向账户中存钱时，会一起执行到<code>new_balance = self._balance + money</code>这行代码，多个线程得到的账户余额都是初始状态下的<code>0</code>，所以都是<code>0</code>上面做了+1的操作，因此得到了错误的结果。在这种情况下，“锁”就可以派上用场了。我们可以通过“锁”来保护“临界资源”，只有获得“锁”的线程才能访问“临界资源”，而其他没有得到“锁”的线程只能被阻塞起来，直到获得“锁”的线程释放了“锁”，其他线程才有机会获得“锁”，进而访问被保护的“临界资源”。下面的代码演示了如何使用“锁”来保护对银行账户的操作，从而获得正确的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Lock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._balance = <span class="number">0</span></span><br><span class="line">        self._lock = Lock()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deposit</span><span class="params">(self, money)</span>:</span></span><br><span class="line">        <span class="comment"># 先获取锁才能执行后续的代码</span></span><br><span class="line">        self._lock.acquire()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            new_balance = self._balance + money</span><br><span class="line">            sleep(<span class="number">0.01</span>)</span><br><span class="line">            self._balance = new_balance</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="comment"># 在finally中执行释放锁的操作保证正常异常锁都能释放</span></span><br><span class="line">            self._lock.release()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">balance</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._balance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddMoneyThread</span><span class="params">(Thread)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, account, money)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self._account = account</span><br><span class="line">        self._money = money</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._account.deposit(self._money)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    account = Account()</span><br><span class="line">    threads = []</span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        t = AddMoneyThread(account, <span class="number">1</span>)</span><br><span class="line">        threads.append(t)</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line">    print(<span class="string">'账户余额为: ￥%d元'</span> % account.balance)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>比较遗憾的一件事情是Python的多线程并不能发挥CPU的多核特性，这一点只要启动几个执行死循环的线程就可以得到证实了。之所以如此，是因为Python的解释器有一个“全局解释器锁”（GIL）的东西，任何线程执行前必须先获得GIL锁，然后每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行，这是一个历史遗留问题，但是即便如此，就如我们之前举的例子，使用多线程在提升执行效率和改善用户体验方面仍然是有积极意义的。</p><h3 id="多进程还是多线程"><a href="#多进程还是多线程" class="headerlink" title="多进程还是多线程"></a>多进程还是多线程</h3><p>无论是多进程还是多线程，只要数量一多，效率肯定上不去，为什么呢？我们打个比方，假设你不幸正在准备中考，每天晚上需要做语文、数学、英语、物理、化学这5科的作业，每项作业耗时1小时。如果你先花1小时做语文作业，做完了，再花1小时做数学作业，这样，依次全部做完，一共花5小时，这种方式称为单任务模型。如果你打算切换到多任务模型，可以先做1分钟语文，再切换到数学作业，做1分钟，再切换到英语，以此类推，只要切换速度足够快，这种方式就和单核CPU执行多任务是一样的了，以旁观者的角度来看，你就正在同时写5科作业。</p><p>但是，切换作业是有代价的，比如从语文切到数学，要先收拾桌子上的语文书本、钢笔（这叫保存现场），然后，打开数学课本、找出圆规直尺（这叫准备新环境），才能开始做数学作业。操作系统在切换进程或者线程时也是一样的，它需要先保存当前执行的现场环境（CPU寄存器状态、内存页等），然后，把新任务的执行环境准备好（恢复上次的寄存器状态，切换内存页等），才能开始执行。这个切换过程虽然很快，但是也需要耗费时间。如果有几千个任务同时进行，操作系统可能就主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口无反应，系统处于假死状态。所以，多任务一旦多到一个限度，反而会使得系统性能急剧下降，最终导致所有任务都做不好。</p><p>是否采用多任务的第二个考虑是任务的类型，可以把任务分为计算密集型和I/O密集型。计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如对视频进行编码解码或者格式转换等等，这种任务全靠CPU的运算能力，虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低。计算密集型任务由于主要消耗CPU资源，这类任务用Python这样的脚本语言去执行效率通常很低，最能胜任这类任务的是C语言，我们之前提到了Python中有嵌入C/C++代码的机制。</p><p>除了计算密集型任务，其他的涉及到网络、存储介质I/O的任务都可以视为I/O密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待I/O操作完成（因为I/O的速度远远低于CPU和内存的速度）。对于I/O密集型任务，如果启动多任务，就可以减少I/O等待时间从而让CPU高效率的运转。有一大类的任务都属于I/O密集型任务，这其中包括了我们很快会涉及到的网络应用和Web应用。</p><blockquote><p><strong>说明：</strong>上面的内容和例子来自于<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000" target="_blank" rel="noopener">廖雪峰官方网站的《Python教程》</a>，因为对作者文中的某些观点持有不同的看法，对原文的文字描述做了适当的调整。</p></blockquote><h3 id="单线程-异步I-O"><a href="#单线程-异步I-O" class="headerlink" title="单线程+异步I/O"></a>单线程+异步I/O</h3><p>现代操作系统对I/O操作的改进中最为重要的就是支持异步I/O。如果充分利用操作系统提供的异步I/O支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型。Nginx就是支持异步I/O的Web服务器，它在单核CPU上采用单进程模型就可以高效地支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。用Node.js开发的服务器端程序也使用了这种工作模式，这也是当下实现多任务编程的一种趋势。</p><p>在Python语言中，单线程+异步I/O的编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。协程最大的优势就是极高的执行效率，因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销。协程的第二个优势就是不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不用加锁，只需要判断状态就好了，所以执行效率比多线程高很多。如果想要充分利用CPU的多核特性，最简单的方法是多进程+协程，既充分利用多核，又充分发挥协程的高效率，可获得极高的性能。关于这方面的内容，我稍后会做一个专题来进行讲解。</p><h3 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h3><h4 id="例子1：将耗时间的任务放到线程中以获得更好的用户体验。"><a href="#例子1：将耗时间的任务放到线程中以获得更好的用户体验。" class="headerlink" title="例子1：将耗时间的任务放到线程中以获得更好的用户体验。"></a>例子1：将耗时间的任务放到线程中以获得更好的用户体验。</h4><p>如下所示的界面中，有“下载”和“关于”两个按钮，用休眠的方式模拟点击“下载”按钮会联网下载文件需要耗费10秒的时间，如果不使用“多线程”，我们会发现，当点击“下载”按钮后整个程序的其他部分都被这个耗时间的任务阻塞而无法执行了，这显然是非常糟糕的用户体验，代码如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> tkinter</span><br><span class="line"><span class="keyword">import</span> tkinter.messagebox</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 模拟下载任务需要花费10秒钟时间</span></span><br><span class="line">    time.sleep(<span class="number">10</span>)</span><br><span class="line">    tkinter.messagebox.showinfo(<span class="string">'提示'</span>, <span class="string">'下载完成!'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_about</span><span class="params">()</span>:</span></span><br><span class="line">    tkinter.messagebox.showinfo(<span class="string">'关于'</span>, <span class="string">'作者: 骆昊(v1.0)'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    top = tkinter.Tk()</span><br><span class="line">    top.title(<span class="string">'单线程'</span>)</span><br><span class="line">    top.geometry(<span class="string">'200x150'</span>)</span><br><span class="line">    top.wm_attributes(<span class="string">'-topmost'</span>, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    panel = tkinter.Frame(top)</span><br><span class="line">    button1 = tkinter.Button(panel, text=<span class="string">'下载'</span>, command=download)</span><br><span class="line">    button1.pack(side=<span class="string">'left'</span>)</span><br><span class="line">    button2 = tkinter.Button(panel, text=<span class="string">'关于'</span>, command=show_about)</span><br><span class="line">    button2.pack(side=<span class="string">'right'</span>)</span><br><span class="line">    panel.pack(side=<span class="string">'bottom'</span>)</span><br><span class="line"></span><br><span class="line">    tkinter.mainloop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>如果使用多线程将耗时间的任务放到一个独立的线程中执行，这样就不会因为执行耗时间的任务而阻塞了主线程，修改后的代码如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> tkinter</span><br><span class="line"><span class="keyword">import</span> tkinter.messagebox</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">DownloadTaskHandler</span><span class="params">(Thread)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">            time.sleep(<span class="number">10</span>)</span><br><span class="line">            tkinter.messagebox.showinfo(<span class="string">'提示'</span>, <span class="string">'下载完成!'</span>)</span><br><span class="line">            <span class="comment"># 启用下载按钮</span></span><br><span class="line">            button1.config(state=tkinter.NORMAL)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="comment"># 禁用下载按钮</span></span><br><span class="line">        button1.config(state=tkinter.DISABLED)</span><br><span class="line">        <span class="comment"># 通过daemon参数将线程设置为守护线程(主程序退出就不再保留执行)</span></span><br><span class="line">        <span class="comment"># 在线程中处理耗时间的下载任务</span></span><br><span class="line">        DownloadTaskHandler(daemon=<span class="literal">True</span>).start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_about</span><span class="params">()</span>:</span></span><br><span class="line">        tkinter.messagebox.showinfo(<span class="string">'关于'</span>, <span class="string">'作者: 骆昊(v1.0)'</span>)</span><br><span class="line"></span><br><span class="line">    top = tkinter.Tk()</span><br><span class="line">    top.title(<span class="string">'单线程'</span>)</span><br><span class="line">    top.geometry(<span class="string">'200x150'</span>)</span><br><span class="line">    top.wm_attributes(<span class="string">'-topmost'</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    panel = tkinter.Frame(top)</span><br><span class="line">    button1 = tkinter.Button(panel, text=<span class="string">'下载'</span>, command=download)</span><br><span class="line">    button1.pack(side=<span class="string">'left'</span>)</span><br><span class="line">    button2 = tkinter.Button(panel, text=<span class="string">'关于'</span>, command=show_about)</span><br><span class="line">    button2.pack(side=<span class="string">'right'</span>)</span><br><span class="line">    panel.pack(side=<span class="string">'bottom'</span>)</span><br><span class="line"></span><br><span class="line">    tkinter.mainloop()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="例子2：使用多进程对复杂任务进行“分而治之”。"><a href="#例子2：使用多进程对复杂任务进行“分而治之”。" class="headerlink" title="例子2：使用多进程对复杂任务进行“分而治之”。"></a>例子2：使用多进程对复杂任务进行“分而治之”。</h4><p>我们来完成1~100000000求和的计算密集型任务，这个问题本身非常简单，有点循环的知识就能解决，代码如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    number_list = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">100000001</span>)]</span><br><span class="line">    start = time()</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> number_list:</span><br><span class="line">        total += number</span><br><span class="line">    print(total)</span><br><span class="line">    end = time()</span><br><span class="line">    print(<span class="string">'Execution time: %.3fs'</span> % (end - start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>在上面的代码中，我故意先去创建了一个列表容器然后填入了100000000个数，这一步其实是比较耗时间的，所以为了公平起见，当我们将这个任务分解到8个进程中去执行的时候，我们暂时也不考虑列表切片操作花费的时间，只是把做运算和合并运算结果的时间统计出来，代码如下所示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task_handler</span><span class="params">(curr_list, result_queue)</span>:</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> curr_list:</span><br><span class="line">        total += number</span><br><span class="line">    result_queue.put(total)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    processes = []</span><br><span class="line">    number_list = [x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">100000001</span>)]</span><br><span class="line">    result_queue = Queue()</span><br><span class="line">    index = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 启动8个进程将数据切片后进行运算</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">        p = Process(target=task_handler,</span><br><span class="line">                    args=(number_list[index:index + <span class="number">12500000</span>], result_queue))</span><br><span class="line">        index += <span class="number">12500000</span></span><br><span class="line">        processes.append(p)</span><br><span class="line">        p.start()</span><br><span class="line">    <span class="comment"># 开始记录所有进程执行完成花费的时间</span></span><br><span class="line">    start = time()</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> processes:</span><br><span class="line">        p.join()</span><br><span class="line">    <span class="comment"># 合并执行结果</span></span><br><span class="line">    total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> result_queue.empty():</span><br><span class="line">        total += result_queue.get()</span><br><span class="line">    print(total)</span><br><span class="line">    end = time()</span><br><span class="line">    print(<span class="string">'Execution time: '</span>, (end - start), <span class="string">'s'</span>, sep=<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>比较两段代码的执行结果（在我目前使用的MacBook上，上面的代码需要大概6秒左右的时间，而下面的代码只需要不到1秒的时间，再强调一次我们只是比较了运算的时间，不考虑列表创建及切片操作花费的时间），使用多进程后由于获得了更多的CPU执行时间以及更好的利用了CPU的多核特性，明显的减少了程序的执行时间，而且计算量越大效果越明显。当然，如果愿意还可以将多个进程部署在不同的计算机上，做成分布式进程，具体的做法就是通过multiprocessing.managers模块中提供的管理器将<code>Queue</code>对象通过网络共享出来（注册到网络上让其他计算机可以访问），这部分内容也留到爬虫的专题再进行讲解。</p>]]></content:encoded>
      
      <comments>https://guardianss.github.io/python-%E2%80%94%E2%80%94-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>ssm知识整理</title>
      <link>https://guardianss.github.io/ssm%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86.html</link>
      <guid>https://guardianss.github.io/ssm%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86.html</guid>
      <pubDate>Mon, 11 May 2020 15:26:52 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot;
          
        
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="resultType和resultMap的区别是什么？"><a href="#resultType和resultMap的区别是什么？" class="headerlink" title="resultType和resultMap的区别是什么？"></a>resultType和resultMap的区别是什么？</h2><p> MyBatis中在查询进行select映射的时候，返回类型可以用resultType，也可以用resultMap，resultType是直接表示返回类型的(对应着我们的model对象中的实体)，而resultMap则是对外部ResultMap的引用(提前定义了db和model之间的隐射key–&gt;value关系)，但是resultType跟resultMap不能同时存在。</p><h2 id="在MyBatis进行查询映射时，其实查询出来的每一个属性都是放在一个对应的Map里面的，其中键是属性名，值则是其对应的值。"><a href="#在MyBatis进行查询映射时，其实查询出来的每一个属性都是放在一个对应的Map里面的，其中键是属性名，值则是其对应的值。" class="headerlink" title="在MyBatis进行查询映射时，其实查询出来的每一个属性都是放在一个对应的Map里面的，其中键是属性名，值则是其对应的值。"></a>在MyBatis进行查询映射时，其实查询出来的每一个属性都是放在一个对应的Map里面的，其中键是属性名，值则是其对应的值。</h2><p>  ①当提供的返回类型属性是resultType时，MyBatis会将Map里面的键值对取出赋给resultType所指定的对象对应的属性。所以其实MyBatis的每一个查询映射的返回类型都是ResultMap，只是当提供的返回类型属性是resultType的时候，MyBatis对自动的给把对应的值赋给resultType所指定对象的属性。<br>  ②当提供的返回类型是resultMap时，因为Map不能很好表示领域模型，就需要自己再进一步的把它转化为对应的对象，这常常在复杂查询中很有作用。</p><h2 id="MyBatis传参的几种方式？"><a href="#MyBatis传参的几种方式？" class="headerlink" title="MyBatis传参的几种方式？"></a>MyBatis传参的几种方式？</h2><p>1、  按照序列入参<br>2、  第二种：基本数据类型（parameterType=”xxx”）(接口方法声明参数中可使用注解@param(“xx”),一个参数时可以不用加@param，多个参数是就要用@param了。)<br>3、  JAVA实体类<br>4、  Map</p><h2 id="mapper元素的namespace属性的作用是什么？"><a href="#mapper元素的namespace属性的作用是什么？" class="headerlink" title="mapper元素的namespace属性的作用是什么？"></a>mapper元素的namespace属性的作用是什么？</h2><p>在mybatis中，映射文件中的namespace是用于绑定Dao接口的，即面向接口编程。<br>当你的namespace绑定接口后，你可以不用写接口实现类，mybatis会通过该绑定自动帮你找到对应要执行的SQL语句</p><h2 id="谈谈你对association和collection元素的理解"><a href="#谈谈你对association和collection元素的理解" class="headerlink" title="谈谈你对association和collection元素的理解"></a>谈谈你对association和collection元素的理解</h2><p>Association映射到javabean的某个复杂数据类型，比如javabean类，即javabean内部嵌套一个复杂数据类型属性这种情况属于复杂类型的关联，但association仅处理一对一的关联关系<br>Collection和association的作用差不多，只是映射的属性是个集合列表，是javabean内部嵌套的一个复杂数据类型（集合）属性</p><h2 id="实现动态SQL的主要元素有哪些？"><a href="#实现动态SQL的主要元素有哪些？" class="headerlink" title="实现动态SQL的主要元素有哪些？"></a>实现动态SQL的主要元素有哪些？</h2><p>If:简单的条件查询<br>Choose：相当于java中的switch语句通常和when和otherwise搭配<br>Where：简化SQL语句中的where条件判断<br>Set：解决动态更新语句<br>Trim：可以去除灵活的关键字<br>Foreach：迭代一个集合通常与in连用</p><h2 id="什么是数据持久化？"><a href="#什么是数据持久化？" class="headerlink" title="什么是数据持久化？"></a>什么是数据持久化？</h2><p>是程序数据在瞬时状态和持久状态间转换的过程</p><h2 id="简述SqlSessionFactoryBuild"><a href="#简述SqlSessionFactoryBuild" class="headerlink" title="简述SqlSessionFactoryBuild"></a>简述SqlSessionFactoryBuild</h2><p>负责构建SqlSessionFactory，并提供多个build方法的重载</p><h2 id="SqlSessionFactoryBuilder-SqlSessionFactory、SqlSession的生命周期和作用域"><a href="#SqlSessionFactoryBuilder-SqlSessionFactory、SqlSession的生命周期和作用域" class="headerlink" title="SqlSessionFactoryBuilder SqlSessionFactory、SqlSession的生命周期和作用域"></a>SqlSessionFactoryBuilder SqlSessionFactory、SqlSession的生命周期和作用域</h2><p>SqlSessionFactorBuildr用过即丢，最佳范围存在方法体内，也就是局部变量而已。<br>SqlSessionFactory对象一旦创建，就会在整个应用运行期间始终存在它的生命周期和应用同存在<br>SqlSession对应一次数据库会话</p><h2 id="Spring两大核心技术？"><a href="#Spring两大核心技术？" class="headerlink" title="Spring两大核心技术？"></a>Spring两大核心技术？</h2><p>SpringIOC(控制反转/依赖注入)<br>SpringAOP(面向切面编程)</p><h2 id="如何理解SpringIOC？"><a href="#如何理解SpringIOC？" class="headerlink" title="如何理解SpringIOC？"></a>如何理解SpringIOC？</h2><p>SpringIOC即控制反转/依赖注入,是面向对象编程中的一种设计理念,用来降低程序之间的耦合度</p><h2 id="如何理解SpringAOP"><a href="#如何理解SpringAOP" class="headerlink" title="如何理解SpringAOP ?"></a>如何理解SpringAOP ?</h2><p>SpringAop即面向切面编程，是面向对象编程的扩展，一般适用于具有横切逻辑的场合，如控制事物，事物管理、性能检测，SpringAOP简单来说就是在不改变原有代码的情况下增加新功能</p><h2 id="Spring有哪些优点？"><a href="#Spring有哪些优点？" class="headerlink" title="Spring有哪些优点？"></a>Spring有哪些优点？</h2><p>低侵入式设计<br>独立于各种应用服务器<br>依赖注入特性将组件关系透明化，降低耦合度<br>通用任务集中处理<br>与第三方框架的良好整和</p><h2 id="如何通过属性文件配置数据源？"><a href="#如何通过属性文件配置数据源？" class="headerlink" title="如何通过属性文件配置数据源？"></a>如何通过属性文件配置数据源？</h2><p>使用Spring提供的PropertyPlaceholderConfigurer类加载属性文件，在Spring配置文件中采用${ ……}的方式引用属性文件中的键值对</p><h2 id="如何加载JNDI数据源？"><a href="#如何加载JNDI数据源？" class="headerlink" title="如何加载JNDI数据源？"></a>如何加载JNDI数据源？</h2><p>Spring提供引用JNDI资源的JndiObjectFactoryBean类来调用</p><h2 id="简述Bean的作用域有几种？"><a href="#简述Bean的作用域有几种？" class="headerlink" title="简述Bean的作用域有几种？"></a>简述Bean的作用域有几种？</h2><p>1、singleton，单例模式，bean的实例只有一个<br>2、protopyte，每次容器获取bean时，都会创建一个新的实例<br>3、request，用于web应用环境，针对每次的http请求都会创建一个实例<br>4、session，同一个会话共享一个实例，不同的会话使用不同的实例<br>5、global，仅在Porplet的web环境中使用，同一个全局会话共享一个实例。对于非Porplet环境等同于session</p><h2 id="简述自动装配都有几种类型？"><a href="#简述自动装配都有几种类型？" class="headerlink" title="简述自动装配都有几种类型？"></a>简述自动装配都有几种类型？</h2><p>ByName  byType   constructor</p><h2 id="列举获取映射接口实例，实现数据操作的几中方式："><a href="#列举获取映射接口实例，实现数据操作的几中方式：" class="headerlink" title="列举获取映射接口实例，实现数据操作的几中方式："></a>列举获取映射接口实例，实现数据操作的几中方式：</h2><p>1、使用MapperFactoryBean注入映射器<br>2、使用MapperScannerConfigurer注入映射器</p><h2 id="简述声明事务配置的步骤："><a href="#简述声明事务配置的步骤：" class="headerlink" title="简述声明事务配置的步骤："></a>简述声明事务配置的步骤：</h2><p>  配置步骤<br> 导入tx和aop命名空间<br> 定义事务管理器Bean，并为其注入数据源Bean<br> 通过<a href="tx:advice">tx:advice</a>配置事务增强，绑定事务管理器并针对不同方法定义事务规则<br> 配置切面，将事务增强与方法切入点组</p><h2 id="什么是SpringMVC设计模式"><a href="#什么是SpringMVC设计模式" class="headerlink" title="什么是SpringMVC设计模式"></a>什么是SpringMVC设计模式</h2><p>数据访问接口：Dao层<br>处理业务逻辑层：Service层<br>数据实体层：Pojo<br>负责访问前端请求和处理：Servlet<br>负责前段页面展示：jsp<br>M:Model即数据模型—java<br>V:view即视图—jsp<br>C：controllor即控制器—Servlet</p><h2 id="简述SpringMVC的请求流程"><a href="#简述SpringMVC的请求流程" class="headerlink" title="简述SpringMVC的请求流程:"></a>简述SpringMVC的请求流程:</h2><p>当用户发送URL请求时,web.xml中的DispatcherServlet会截获请求，根据HandlerMappering找到对应的Controller来处理请求，Controller处理完成后，返回ModelAndView对象，该对象告诉DispatcherServlet需要通过哪个视图来进行数据模型展示，最后Dispatcher Servlet根据视图解析器把Controller返回的逻辑视图转换成view返回给用户界面</p><h2 id="什么是单例模式？"><a href="#什么是单例模式？" class="headerlink" title="什么是单例模式？"></a>什么是单例模式？</h2><p>系统运行期间，只有一个实例<br>具体来说有一下三个关键点：<br>1、一个类只有一个实例<br>2、它必须自行创建这个实例<br>3、它必须自行向整个系统提供这个实例</p><h2 id="SpringMVC如何处理多文件上传？"><a href="#SpringMVC如何处理多文件上传？" class="headerlink" title="SpringMVC如何处理多文件上传？"></a>SpringMVC如何处理多文件上传？</h2><p>1、表单页面加上file标签<br>2、单独入参，控制器处理</p><h2 id="SpringMVC中服务器端的数据如何实现验证的？"><a href="#SpringMVC中服务器端的数据如何实现验证的？" class="headerlink" title="SpringMVC中服务器端的数据如何实现验证的？"></a>SpringMVC中服务器端的数据如何实现验证的？</h2><p>1、利用Spring自带的验证框架<br>2、利用JSR303实现(java为bean数据合法性检验所提供得标准框架，SpringMVC支持JSR303标准得校验框架 JSR303通过在bean属性上标注类似于0)</p><h2 id="简述REST风格"><a href="#简述REST风格" class="headerlink" title="简述REST风格"></a>简述REST风格</h2><p>表述性状态转移，是一种软件架构风格，即使用URL表示资源时，每个资源都用一个独一无二的URL来表示，并使用HTTP方法白送和i操作，即准确的描述服务器对资源的处理动作（GET、POST、PUT、DELETE），并实现资源得增删改查</p><h2 id="PathVariable得用法："><a href="#PathVariable得用法：" class="headerlink" title="@PathVariable得用法："></a>@PathVariable得用法：</h2><p>接受REST风格URL中得参数</p><h2 id="ResponseBody注解的用法？"><a href="#ResponseBody注解的用法？" class="headerlink" title="@ResponseBody注解的用法？"></a>@ResponseBody注解的用法？</h2><p>该注解的作用是将标注该注解的处理方法的返回结果直接写入HTTP ResponseBody中，一般情况下该注解都会在异常处理数据时使用，被其标注的处理方法返回的数据将会输出到响应流中，客户端获取并显示数据</p><h2 id="SpringMVC中输出json数据时，对于日期格式应该如何处理？"><a href="#SpringMVC中输出json数据时，对于日期格式应该如何处理？" class="headerlink" title="SpringMVC中输出json数据时，对于日期格式应该如何处理？"></a>SpringMVC中输出json数据时，对于日期格式应该如何处理？</h2><p>1、注解方式：@JSONField(format= “yyyy-MM-dd”)<br>2、配置FastJson的消息转换器-FastJsonHttpMessageConverter<br>设置features属性：指定输出时的日期转换器为WriteDateUseDateFormat</p><h2 id="ContentNegotiatingViewResolver-视图解析器的应用理解？"><a href="#ContentNegotiatingViewResolver-视图解析器的应用理解？" class="headerlink" title="ContentNegotiatingViewResolver 视图解析器的应用理解？"></a>ContentNegotiatingViewResolver 视图解析器的应用理解？</h2><p>可以根据请求所要求的MIME类型决定由哪个视图解析器负责处理，它允许以同样的内容数据来呈现不同的View</p><h2 id="简述SSM框架整合的步骤？"><a href="#简述SSM框架整合的步骤？" class="headerlink" title="简述SSM框架整合的步骤？"></a>简述SSM框架整合的步骤？</h2><p>1、建项目导jar包<br>2、配置web.xml中的SpringMVC的核心控制器DispatcherServlet<br>3、配置applicationContext-Mybatis.xml Spring配置文件 database.properties  log4j.propertise  mybatis-config.xml  Springmvc-servlet.xml<br>4、事务管理配置SqlSessionFactoryBean MapperScannerConfiguer<br>5、对象数据模型pojo<br>6、数据访问接口Dao<br>7、系统服务接口 sevices<br>8、前端控制层controller<br>9、Tools工具类<br>10、前端页面jsp和静态资源statics</p><h2 id="面向过程编程，面向对象编程和面向切面编程理解"><a href="#面向过程编程，面向对象编程和面向切面编程理解" class="headerlink" title="面向过程编程，面向对象编程和面向切面编程理解"></a>面向过程编程，面向对象编程和面向切面编程理解</h2><p>面向过程(ProcedureOriented)是一种以过程为中心的编程思想。这些都是以什么正在发生为主要目标进行编程，不同于面向对象的是谁在受影响。与面向对象明显的不同就是封装、继承、类。<br>面向对象编程（ObjectOriented Programming，OOP，面向对象程序设计）是一种计算机编程架构。OOP 的一条基本原则是计算机程序是由单个能够起到子程序作用的单元或对象组合而成。OOP 达到了软件工程的三个主要目标：重用性、灵活性和扩展性。为了实现整体运算，每个对象都能够接收信息、处理数据和向其它对象发送信息。<br>面向切面编程（AspectOriented Programming(AOP)），是一个比较热门的话题。AOP主要实现的目的是针对业务处理过程中的切面进行提取，它所面对的是处理过程中的某个步骤或阶段，以获得逻辑过程中各部分之间低耦合性的隔离效果。</p><h2 id="怎么理解SpringAOP？"><a href="#怎么理解SpringAOP？" class="headerlink" title="怎么理解SpringAOP？"></a>怎么理解SpringAOP？</h2><p>SpringAOP是一种通过预编译和运行期间动态实现代理的方式实现了不修改代码的情况下给程序动态添加新功能的技术。</p><h2 id="SpringAOP增强处理类型有哪些？"><a href="#SpringAOP增强处理类型有哪些？" class="headerlink" title="SpringAOP增强处理类型有哪些？"></a>SpringAOP增强处理类型有哪些？</h2><p>前置增强   (org.springframework.aop.BeforeAdvice)   表示在目标方法执行前来实施增强<br>后置增强   (org.springframework.aop.AfterReturningAdvice)   表示在目标方法执行后来实施增强<br>环绕增强   (org.aopalliance.intercept.MethodInterceptor)   表示在目标方法执行前后同时实施增强<br>异常抛出增强   (org.springframework.aop.ThrowsAdvice)   表示在目标方法抛出异常后来实施增强<br>引介增强   (org.springframework.aop.introductioninterceptor)   表示在目标类中添加一些新的方法和属性</p><h2 id="IoC-主要的实现形式有两种"><a href="#IoC-主要的实现形式有两种" class="headerlink" title="IoC 主要的实现形式有两种 :"></a>IoC 主要的实现形式有两种 :</h2><p>依赖查找：容器提供回调接口和上下文环境给组件。 EJB 和 Apache Avalon 都是使用这种方式。<br>依赖注入：组件不做定位查询，只是提供普通的 Java 方法让容器去决定依赖关系。容器全权负责组件的装配，它会把符合依赖关系的对象通过 JavaBean 属性或者构造子传递给需要的对象。通过 JavaBean 属性注射依赖关系的做法称为设值方法注入（ Setter Injection ）；将依赖关系作为构造子参数传入的做法称为构造子注入（ Constructor Injection ）。</p><h2 id="AOP在Spring中的实现"><a href="#AOP在Spring中的实现" class="headerlink" title="AOP在Spring中的实现"></a>AOP在Spring中的实现</h2><p>基于AOP，业界存在各种各样的AOP实现，比如，JBoss AOP、Spring AOP、ASP ectJ、 Aspect Werkz等。各自实现的功能也不一样。AOP实现的强弱在很大程度上取决于连接点模型。目前，Spring只支持方法级的连接点。这和一些其他AOP框架不一样，如AspectJ和JBoss，它们还提供了属性接入点，这样可以防止你创建特别细致的通知，如对更新对象属性值进行拦截。然而，由于 Spring关注于提供一个实现J2EE 服务的框架，所以方法拦截可以满足大部分要求，而且Spring的观点是属性拦截破坏了封装，让Advice触发在属性值改变而不是方法调用上无疑是破坏了这个概念。</p><p>1、添加jar包<br>2、编写前置增强、后置增强等<br>3、编写spring配置文件applicantionContent.xml<br>4、编写代码，获取增强处理的对象</p><h2 id="Spring的AOP框架的关键点如下："><a href="#Spring的AOP框架的关键点如下：" class="headerlink" title="Spring的AOP框架的关键点如下："></a>Spring的AOP框架的关键点如下：</h2><p>（1）Spring实现了AOP联盟接口。在SpringAOP中，存在如下几种通知（Advice）类型<br>Before通知：在目标方法被调用前调用，涉及接口org.springFramework .aop.MethodBeforeAdvice;<br>After通知：在目标方法被调用后调用，涉及接口为org.springframework.aop.AfterReturningAdvice;<br>Throws通知：目标方法抛出异常时调用，涉及接口org.springframework.aop.MethodBeforeAdvice;<br>Around通知：拦截对目标对象方法调用，涉及接口为org.aopalliance.intercept.MethodInterceptor。<br>（2）用Java编写Spring通知，并在Spring的配置文件中，定义在什么地方应用通知的切入点。<br>（3）Spring的运行时通知对象。代理Bean只有在第一次被应用系统需要的时候才被创建。如果你使用的是ApplicationContext，代理对象在BeanFactory载入所有Bean的时候被创建。Spring有两种代理创建方式。如果目标对象实现了一个或多个接口暴露的方法，Spring将使用JDK 的 java.lang.reflect.Proxy类创建代理。这个类让Spring动态产生一个新的类，它实现所需的接口，织入了通知，并且代理对目标对象的所有请求。如果目标对象没有实现任何接口，Spring使用CGLIB库生成目标对象的子类。在创建这个子类的时候，Spring将通知织入，并且将对目标对象的调用委托给这个子类。此时，需要将Spring发行包lib/cglib目录下的JAR文件发布到应用系统中。</p>]]></content:encoded>
      
      <comments>https://guardianss.github.io/ssm%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>软件测试</title>
      <link>https://guardianss.github.io/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95.html</link>
      <guid>https://guardianss.github.io/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95.html</guid>
      <pubDate>Fri, 08 May 2020 09:10:58 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot;
          
        
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="软件测试的分类"><a href="#软件测试的分类" class="headerlink" title="软件测试的分类"></a>软件测试的分类</h2><p>1、按测试阶段划分：单元、集成、系统、验收（Alpha、Beta、正式）<br>2、按测试技术划分：黑盒：看不到程序的逻辑与走向，在测试过程中只关注输入输出，也叫数据驱动测试<br> 白盒：基于软件内部设计和程序实现的测试方法。不仅关注输入输出的结果，还关注程序是如何处理的。<br> 灰盒：介于白盒和黑盒之间的一种测试，例如接口测试。<br>3、按被测试对象是否运行划分：静态、动态<br>4、按不同的测试手段划分：手动、自动<br>5、按测试包含的内容划分：<br> 功能测试：测试软件功能是否符合需求。<br> 界面测试：UI测试，测试系统用户界面是否合理，整体风格是否一致，界面文字是否正确，图片美观等等。<br> 性能测试：为获取或验证系统性能指标而进行的测试，会在不同负载情况下进行。<br> 安全性测试：测试该系统防止非法入侵的能力。<br> 负载测试：通过改变系统负载方式、增加负载等来发现系统中存在的性能问题。体现一种方法和一种技术。<br> 兼容性测试：测试该系统与其他软硬件兼容能力（app，c/s架构软件、b/s架构软件）。<br> 压力测试（强度测试）：主要为了确定系统稳定性<br> 1、高负载下长时间  的稳定性压力测试；<br> 2、极限负载情况下导致系统崩溃的破坏性压力测试。<br> 恢复测试：检查系统的容错能力。<br> 易用测试：软件测试是否易用，主观性较强。<br>6、其他测试：<br> 冒烟测试：对象是每一个新编译的需要正式测试的软件版本，确认基本功能正常，可继续后续正式测试工作。<br> 回归测试：指错误被修正后或软件功能、环境发生变化后进行的重新测试，确认修改部分不会对其他功能造成影响。<br> 探索性测试</p><h2 id="软件质量"><a href="#软件质量" class="headerlink" title="软件质量"></a>软件质量</h2><pre><code>软件质量包括正确性，可靠性，可读性，可移植性和健壮性，主要含义是软件的可靠性</code></pre><h2 id="软件可靠性"><a href="#软件可靠性" class="headerlink" title="软件可靠性"></a>软件可靠性</h2><pre><code>特定环境下，在给定时间内，无障碍运行的概率</code></pre><h2 id="度量"><a href="#度量" class="headerlink" title="度量"></a>度量</h2><pre><code>软件中初始故障的数量软件经过测试后，通过查错，改错，在软件中剩余故障的数量平均无故障时间故障间隔的时间长度故障发生率经过预测下次故障的发生时间</code></pre><h2 id="软件故障"><a href="#软件故障" class="headerlink" title="软件故障"></a>软件故障</h2><p>定义<br>    从内部看，软件故障是软件产品开发或维护过程中存在的错误，毛病等各种问题<br>    从外部看，软件故障是系统所需要实现的某种功能的失效或违背<br>计算机系统或程序存在任何一种破坏正常运行能力的问题，错误，或者隐藏的功能缺陷等<br>软件故障导致软件产品在某种程度上不能满足用户的需求<br>硬件故障<br>  物理性能恶化<br>软件故障<br>  设计阶段人为因素造成的<br>操作故障<br>  操作人员和维护人员的错误<br>环境故障<br>  电源，外界干扰，地震，火灾，病毒等各种外界因素引起的故障<br>错误<br>  人是会犯错的。过失是人犯下的，是人做一件错事或认为产生的一个不正确的结果<br>故障<br>  故障时错误的结果<br>失效<br>  故障引起的结果</p><h2 id="软件测试与软件可靠性"><a href="#软件测试与软件可靠性" class="headerlink" title="软件测试与软件可靠性"></a>软件测试与软件可靠性</h2><pre><code>软件中都会有故障存在可以减少故障的引入，但是不可能完全杜绝软件中的故障</code></pre><h2 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h2><pre><code>软件需求分析，设计说明和编码的最终复审是软件质量保证的关键步骤</code></pre><p> 是为了发现故障而执行程序的过程<br>定义：</p><ol><li>是否满足规定的需求</li><li>是否有差别<br>测试是为了发现故障而执行程序的过程<br>谁来执行<br>测试什么<br>什么时候测试<br>怎样进行测试<br>测试停止的标准<br>成功采用了具体的测试用例设计方法<br>每一类覆盖的覆盖率<br>故障检测率<br>检测出故障的具体数量或消耗的具体时间<h2 id="软件生存周期"><a href="#软件生存周期" class="headerlink" title="软件生存周期"></a>软件生存周期</h2>制定计划<br>需求分析<br>设计<br>程序编码<br>测试<br>运行维护</li></ol><h1 id="测试原则"><a href="#测试原则" class="headerlink" title="测试原则"></a>测试原则</h1><h2 id="黑盒测试与白盒测试"><a href="#黑盒测试与白盒测试" class="headerlink" title="黑盒测试与白盒测试"></a>黑盒测试与白盒测试</h2><h3 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h3><p> 等价类划分<br> 边界值分析<br> 决策表驱动</p><h3 id="白盒测试"><a href="#白盒测试" class="headerlink" title="白盒测试"></a>白盒测试</h3><p> 逻辑覆盖<br> 数据流测试<br> 域测试<br> 符号测试<br> 路径分析<br> 程序变异<br> 程序插装技术</p><h3 id="软件测试过程"><a href="#软件测试过程" class="headerlink" title="软件测试过程"></a>软件测试过程</h3><p>软件开发是自顶向下，软件测试自底向上</p><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p>又称模块测试，针对程序模块来进行正确性检验的测试工作<br> 模块接口测试<br> 局部数据结构测试<br> 路径测试<br> 错误处理测试<br> 边界测试</p><h2 id="静态测试与动态测试"><a href="#静态测试与动态测试" class="headerlink" title="静态测试与动态测试"></a>静态测试与动态测试</h2><h3 id="静态测试"><a href="#静态测试" class="headerlink" title="静态测试"></a>静态测试</h3><p>不利用计算机运行被测试的程序，通过其他手段达到检测的目的</p><h3 id="动态测试"><a href="#动态测试" class="headerlink" title="动态测试"></a>动态测试</h3><p>通过运行和使用被测程序，发现软件故障，达到检测目的</p><h3 id="回归测试"><a href="#回归测试" class="headerlink" title="回归测试"></a>回归测试</h3><p>对程序进行测试已确定是否因修复故障而引入了新的故障</p><h3 id="α-alphaα测试"><a href="#α-alphaα测试" class="headerlink" title="α\alphaα测试"></a>α\alphaα测试</h3><p>由一个用户在开发环境下进行的测试<br>目的是平价产品的功能，可使用性，可靠性，性能和支持</p><h3 id="β-betaβ测试"><a href="#β-betaβ测试" class="headerlink" title="β\betaβ测试"></a>β\betaβ测试</h3><p>软件的多个用户在一个或多个用户的实际使用环境下进行的测试。开发者通常不在测试现场<br>α\alphaα测试达到一定的可靠程度时才能进行β\betaβ测试，它处在整个测试的最后阶段</p><h1 id="测试与调试"><a href="#测试与调试" class="headerlink" title="测试与调试"></a>测试与调试</h1><p>调试不属于测试<br>成功的测试发现错误从而引起调试的进行</p><h2 id="测试生命周期"><a href="#测试生命周期" class="headerlink" title="测试生命周期"></a>测试生命周期</h2><p> 测试计划<br> 测试设计<br> 测试开发<br> 测试执行<br> 测试评估</p><h2 id="测试工具"><a href="#测试工具" class="headerlink" title="测试工具"></a>测试工具</h2><h3 id="测试评估"><a href="#测试评估" class="headerlink" title="测试评估"></a>测试评估</h3><p> 测试覆盖测试<br> 软件故障评估<br> 测试有效性评估</p><h3 id="软件质量评估"><a href="#软件质量评估" class="headerlink" title="软件质量评估"></a>软件质量评估</h3><p>检查和评价当前软件开发过程,并设法达到防止软件故障出现</p><h3 id="软件过程成熟度"><a href="#软件过程成熟度" class="headerlink" title="软件过程成熟度"></a>软件过程成熟度</h3><ol><li>初始度</li><li>可重复级</li><li>定义明确</li><li>定量管理级</li><li>优化级</li></ol><h1 id="结构性测试"><a href="#结构性测试" class="headerlink" title="结构性测试"></a>结构性测试</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p> 基于被测试程序的源代码,而不是软件规格说明<br> 更容易发现软件测试故障,常用于单元测试</p><h2 id="结构性测试-1"><a href="#结构性测试-1" class="headerlink" title="结构性测试"></a>结构性测试</h2><p>白盒测试又称结构测试或者基于程序的测试.<br> 该方法将被测对象看做一个打开的盒子,允许内部人员检查其内部结构.测试人员根据程序内部结构特性,设计,选择测试用例,检查程序的每条路径是否都按照预定的要求正确执行.</p><h3 id="常见的白盒测试方法有"><a href="#常见的白盒测试方法有" class="headerlink" title="常见的白盒测试方法有:"></a>常见的白盒测试方法有:</h3><p> 逻辑覆盖<br> 数据流测试<br> 域测试<br> 符号测试<br> 路径分析<br> 程序变异<br> 程序插装<br>逻辑覆盖<br>使用最广泛<br> 要求对被测试程序逻辑结构有清楚的了解,要能掌握程序的所有细节<br> 要求对被测试程序的结构做到一定程度的覆盖<br> 分为:</p><h3 id="语义覆盖"><a href="#语义覆盖" class="headerlink" title="语义覆盖"></a>语义覆盖</h3><p>是比较弱的测试覆盖准则</p><h3 id="判定覆盖"><a href="#判定覆盖" class="headerlink" title="判定覆盖"></a>判定覆盖</h3><p>又称之为分支覆盖,使得每个判断的取真分支和取假分支至少执行一次,即判断的真假值均要被检测</p><h3 id="条件覆盖"><a href="#条件覆盖" class="headerlink" title="条件覆盖"></a>条件覆盖</h3><p>每个判断的每个条件的可能取值至少被执行一次</p><h3 id="判定-条件覆盖"><a href="#判定-条件覆盖" class="headerlink" title="判定-条件覆盖"></a>判定-条件覆盖</h3><p>判断中的每个条件的所有可能取值至少执行一次,同时每个判断的所有可能判断结果也至少被执行一次</p><h3 id="路径覆盖"><a href="#路径覆盖" class="headerlink" title="路径覆盖"></a>路径覆盖</h3><p>程序控制图</p><h3 id="重要性"><a href="#重要性" class="headerlink" title="重要性"></a>重要性</h3><p>明确地描述测试用例和测试用例所执行的程序部分之间的关系.<br>McCabe的基本路径法</p><h2 id="测试观点"><a href="#测试观点" class="headerlink" title="测试观点"></a>测试观点</h2><p>强连通图的圈数就是图中线性独立环路的数目</p><ol><li>选择一条基线路径,一般选择有较多判断结点的路径</li><li>回溯基线路径<h2 id="符号测试"><a href="#符号测试" class="headerlink" title="符号测试"></a>符号测试</h2><h2 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h2>允许程序的输入不仅可以是具体的数值数据,而且还可以包括符号值.<br>执行过程中以符号计算代替了普通执行中的数值计算,所得到的结果自然是符号公式或符号谓词<br>普通测试执行的事算数运算,符号测试执行的是代数计算<h3 id="程序插装"><a href="#程序插装" class="headerlink" title="程序插装"></a>程序插装</h3>借助于往被测试程序中插入操作来实现测试目的的方法<br>考虑的方面<br>探测哪些信息<br>在程序的什么部位设置探测点<br>需要设置多少个探测点<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3></li><li>覆盖分析</li><li>监控和断言</li><li>查找数据流异常<h2 id="指导方针"><a href="#指导方针" class="headerlink" title="指导方针"></a>指导方针</h2><h3 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h3>具有高圈复杂度的程序需要更充分的测试<br>一般选择V(G)=10<br>如果单元具有更高的复杂度,可以简化单元或计划更充分的测试<br>简化单元的最好方法是解决非结构化的问题<h3 id="覆盖指标"><a href="#覆盖指标" class="headerlink" title="覆盖指标"></a>覆盖指标</h3></li><li>作为一种强制执行的标准</li><li>作为一种机制,指导要求更严格部分的代码有选择地进行测试<h3 id="数据流测试"><a href="#数据流测试" class="headerlink" title="数据流测试"></a>数据流测试</h3>数据流是指关注定义点和使用(或引用)点的一种结构测试方法,它和数据流图没有什么联系.<br>实际上很多数据流测试支持者和研究人员将这种测试方法看作是一种路径测试.<br>通过分析变量的定义和使用,以查找如引用未定义变量等程序错误,也可以用来查找对以前未曾使用的变量的再次赋值等数据流异常的情况<br>早期数据流分析常常集中于现在叫定义/引用异常的缺陷:<br>变量被定义但是从来没有被使用<br>所使用的变量没有被定义<br>变量在使用之前被定义了两次<br>这些异常可以通过程序的索引表发现,可以通过所谓的静态分析发现<br>将程序中的变量出现分为定义和引用<br>语句K执行时改变了程序变量V的值,则称K定义了变量V<br>若语句k执行时引用了变量V的值,则称K引用了变量V<h3 id="定义-使用测试"><a href="#定义-使用测试" class="headerlink" title="定义/使用测试"></a>定义/使用测试</h3>假设V是程序P中的变量的集合,程序P控制流程图用G(P)表示,其中结点代表语句或语句片段,边代表结点序列.G(P)有一个单入口节点和一个单出口节点,并且不允许有某个结点到自身的边<br>变量V的定义结点,记作DEF(v,n)<br>结点n∈\in∈ G(P)是变量v∈\in∈V定义的结点,当且仅当变量V的值由对应结点n的语句或语句片段所定义.<br>变量v的使用结点n记作USE(v,n)<br>结点n∈\in∈ G(P)是变量v∈\in∈V的使用结点,当且仅当变量v的值在对应结点n的语句或语句片段中被引用.<br>谓词使用,记作P-use<br>USE(v,n)是一个谓词使用,当且仅当n是谓词语句,否则,USE(v,n)是计算使用,记作C-use.<br>定义/使用路径,记作du-path<br>如果对某个变量v∈\in∈V,存在一个定义,使用结点对,即DEF(v,m)和USE(v,n),使得变量v在结点m处被定义,在结点n处被使用,则称为一条定义/使用路径,结点m称为该定义使用路径的开始结点,而结点n则称为该定义/使用路径的结束结点.<br>定义清晰路径(defination-clear path),记作dc-path<br>如果一个变量v∈\in∈V,存在一个定义,使用结点对,即DEF(v,m)和USE(v,n),使得变量v在结点m处被定义,在结点n处被使用,并且从m到n的结点序列中没有其他结点对对变量v进行过定义,则从m到n的结点序列称为一条定义清晰路径,结点m称为该定义/使用路径的开始结点,而结点n则称为该定义/使用路径的结束结点.<br>定义/使用路径和定义清晰路径描述了变量从被定义到被引用点数据流向.<br>不是定义清晰的定义/使用路径,很可能是潜在问题的所在.所以应该特别关注定义/使用路径<h3 id="定义-使用路径覆盖测试"><a href="#定义-使用路径覆盖测试" class="headerlink" title="定义/使用路径覆盖测试"></a>定义/使用路径覆盖测试</h3>数据流覆盖测试指标<br>P是被测程序,G(P)是其控制流图,T是G(P)的路径集合,并假设定义/使用路径都是可执行路径<br>所有定义/使用路径覆盖准则<br>集合T满足程序P的所有定义/使用路径覆盖准则,当且仅当对所有的变量v∈\in∈V,T包含了从v的每个定义结点到v所有使用结点的定义清晰路径.<br>所有定义覆盖准则<br>集合T满足程序P所有定义覆盖准则,当且仅当对所有的变量v∈\in∈V,T包含了从变量v的每个定义结点到v的一个使用结点的定义清晰路径.<br>所有使用覆盖准则<br>集合T满足程序P的所有使用覆盖准则,当且仅当对所有的变量v∈\in∈V,T包含了从v的每个定义结点到v的所有使用结点的定义清晰路径<br>所有谓词使用/部分计算使用覆盖准则<br>集合T满足程序P的所有谓词使用/部分计算使用覆盖准则,当且仅当对所有的变量v∈\in∈V,T包含了从v的每个定义结点到v的所有谓词使用结点的定义清晰路径,并且如果v的一个定义没有谓词使用结点,则定义清晰路径至少包含一个计算使用<br>所有计算使用/部分谓词使用覆盖准则<br>集合T满足程序P的所有计算使用/部分谓词使用覆盖准则,当且仅当对所有的变量v∈\in∈V,T包含了从每个定义结点v的所有计算使用结点的定义清晰路径,并且如果v的一个定义没有使用计算节点,则定义清晰路径至少包含一个谓词使用.</li></ol><h2 id="测试和质量的关系"><a href="#测试和质量的关系" class="headerlink" title="测试和质量的关系"></a>测试和质量的关系</h2><p>修复软件缺陷的代价：<br>假设在需求分析阶段修复软件缺陷的代价为“单位1”。<br>设计阶段：3～6倍。<br>编程阶段：10倍。<br>内部测试阶段：20～40倍。<br>外部测试阶段：30～70倍。<br>产品发布后：40～1000倍。<br>修正错误的代价不是随时间线性增长，而几乎是呈指数增长的。</p><h2 id="软件测试结束的标准："><a href="#软件测试结束的标准：" class="headerlink" title="软件测试结束的标准："></a>软件测试结束的标准：</h2><p>用例全部测试；<br>覆盖率达到标准；<br>缺陷率达到标准；<br>其他指标达到标准。</p><h2 id="软件测试的工作范围"><a href="#软件测试的工作范围" class="headerlink" title="软件测试的工作范围"></a>软件测试的工作范围</h2><p>1、软件测试工作的组织与管理：制定测试策略、测试计划，确认所采用的测试方法与规范，控制测试进度，管理测试资源。<br>2、测试工作的实施：编制符合标准的测试文档，搭建测试环境，开发测试脚本、与开发组织协作实现各阶段的测试活动。</p><h2 id="软件质量与软件缺陷"><a href="#软件质量与软件缺陷" class="headerlink" title="软件质量与软件缺陷"></a>软件质量与软件缺陷</h2><p>软件质量：<br>软件产品满足使用要求的程度。</p><h3 id="白盒测试黑盒测试"><a href="#白盒测试黑盒测试" class="headerlink" title="白盒测试黑盒测试"></a>白盒测试黑盒测试</h3><p>白盒测试也称结构测试或逻辑驱动测试，它是按照程序内部的结构测试程序，通过测试来检测产品内部动作是否按照设计规格说明书的规定正常进行，检验程序中的每条通路是否都能按预定要求正确工作。</p><p>黑盒测试也称功能测试，它是通过测试来检测每个功能是否都能正常使用。在测试中，把程序看作一个不能打开的黑盒子，在完全不考虑程序内部结构和内部特性的情况下，在程序接口进行测试，它只检查程序功能是否按照需求规格说明书的规定正常使用，程序是否能适当地接收输入数据而产生正确的输出信息。黑盒测试着眼于程序外部结构，不考虑内部逻辑结构，主要针对软件界面和软件功能进行测试。</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><p>测试用例：<br>为某个特殊目标而编制的一组测试输入、执行条件以及预期结果，以便测试某个程序路径或核实是否满足某个特定需求。指对一项特定的软件产品进行测试任务的描述，体现测试方案、方法、技术和策略。内容包括测试目标、测试环境、输入数据、测试步骤、预期结果、测试脚本等，并形成文档。</p><h3 id="设计测试用例的原因："><a href="#设计测试用例的原因：" class="headerlink" title="设计测试用例的原因："></a>设计测试用例的原因：</h3><p>测试用例构成了设计和制定测试过程的基础。<br>测试的“深度”与测试用例的数量成比例。由于每个测试用例反映不同的场景、条件或经由产品的事件流，因而，随着测试用例数量的增加，对产品质量和测试流程也就越有信心。判断测试是否完全的一个主要评测方法是基于需求的覆盖，而这又是以确定、实施和/或执行的测试用例的数量为依据的。<br>测试工作量与测试用例的数量成比例。根据全面且细化的测试用例，可以更准确地估计测试周期各连续阶段的时间安排。<br>测试设计和开发的类型以及所需的资源主要都受控于测试用例。<br>测试用例通常根据它们所关联关系的测试类型或测试需求来分类，而且将随类型和需求进行相应地改变。最佳方案是为每个测试需求至少编制两个测试用例：一个测试用例用于证明该需求已经满足，通常称作正面测试用例；另一个测试用例反映某个无法接受、反常或意外的条件或数据，用于论证只有在所需条件下才能够满足该需求，这个测试用例称作负面测试用例。<br>测试用例是软件测试的核心。</p><p>4.1 W模型<br>4.2 五大流派<br>1、分析学派：<br>分析学派认为软件测试是严格的技术性的，这一派在学术界有很多支持者。<br>2、标准学派：<br>标准学派认为软件测试是用于衡量进度的一种方式，强调成本度量和可重复的标准。<br>3、质量学派：<br>质量学派强调过程，软件测试人员像警察一样审判开发人员，又像守门员一样保证质量。<br>4、上下文驱动学派：<br>上下文驱动学派强调软件测试人的作用，寻找利益相关的BUG。<br>5、敏捷学派：<br>敏捷学派使用软件测试来验证开发是否完成，强调自动化。</p><h1 id="单元测试-1"><a href="#单元测试-1" class="headerlink" title="单元测试"></a>单元测试</h1><p>单元测试是对软件基本组成单元（如函数、类的方法等）进行的测试。<br>单元测试是对软件基本组成单元进行的测试。</p><h2 id="单元测试的时机："><a href="#单元测试的时机：" class="headerlink" title="单元测试的时机："></a>单元测试的时机：</h2><p>一般在代码完成后由开发人员完成，QA（质量保证）人员辅助。</p><p>单元测试相关概念：模块, 组件, 单元。<br>单元测试的测试人员：程序人员和开发人员。</p><p>单元测试的测试依据：详细设计说明书、概要设计说明书。<br>单元测试测试的不仅仅是代码，还有：接口测试、局部数据结构测试、独立路径测试、独立路径测试、边界条件测试、错误处理测试、功能测试、性能测试、内存使用测试等。</p><h2 id="单元测试的主要目标："><a href="#单元测试的主要目标：" class="headerlink" title="单元测试的主要目标："></a>单元测试的主要目标：</h2><p>测试单元模块是否被正确编码，具体表现为：<br>1、信息能否正确地流入和流出单元；<br>2、在单元工作过程中，其内部数据能否保持其完整性，包括内部数据的形式、内容及相互关系不发生错误，也包括全局变量在单元中的处理和影响。<br>3、在为限制数据加工而设置的边界处，能否正确工作。<br>4、单元的运行能否做到满足特定的逻辑覆盖。<br>5、单元中发生了错误，其中的出错处理措施是否有效。</p><h2 id="驱动程序和桩程序"><a href="#驱动程序和桩程序" class="headerlink" title="驱动程序和桩程序"></a>驱动程序和桩程序</h2><h3 id="驱动程序："><a href="#驱动程序：" class="headerlink" title="驱动程序："></a>驱动程序：</h3><p>对底层或子层模块进行测试所编写的，调用这些模块的程序。</p><h3 id="桩程序："><a href="#桩程序：" class="headerlink" title="桩程序："></a>桩程序：</h3><p>对顶层或上层模块进行测试时所编写的，替代下层模块的程序。</p><h2 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h2><p>集成测试是将软件集成起来，对模块之间的接口进行测试。 集成测试又叫子系统测试、组装测试、部件测试等。</p><p>1、模块内的集成，主要是测试模块内各个接口间的交互集成关系；<br>2、子系统内的集成，测试子系统内各个模块间的交互关系；<br>3、系统内的集成，测试系统内各个子系统和模块间的集成关系。</p><p>集成测试的测试人员：有经验的测试人员和开发者共同进行测试。</p><h2 id="非渐增式测试模式："><a href="#非渐增式测试模式：" class="headerlink" title="非渐增式测试模式："></a>非渐增式测试模式：</h2><p>先分别测试每个模块，再把所有模块按设计要求放在一起结合成所要的程序，如大棒模式。</p><h2 id="渐增式测试模式："><a href="#渐增式测试模式：" class="headerlink" title="渐增式测试模式："></a>渐增式测试模式：</h2><p>把下一个要测试的模块同已经测试好的模块结合进来进行测试，测试完后再把下一个应该测试的模块结合起来测试。</p><p>渐增式测试又可以根据每次添加模块的路线分为自顶向下测试、自底向上测试和混合测试（三明治集成方法）等方式。</p><h2 id="系统测试"><a href="#系统测试" class="headerlink" title="系统测试"></a>系统测试</h2><p>系统测试（特征测试）：<br>检验系统所有元素之间协作是否合适，整个系统的性能和功能是否达到要求。</p><p>系统测试的测试内容：功能测试，非功能测试与回归测试。</p><h3 id="非功能性测试（特征测试）包含的内容："><a href="#非功能性测试（特征测试）包含的内容：" class="headerlink" title="非功能性测试（特征测试）包含的内容："></a>非功能性测试（特征测试）包含的内容：</h3><p>性能测试，压力测试，容量测试，安全性测试，可靠性测试，容错性测试。</p><h3 id="系统测试的测试依据："><a href="#系统测试的测试依据：" class="headerlink" title="系统测试的测试依据："></a>系统测试的测试依据：</h3><p>需求说明书，概要设计说明书，详细设计说明书，最重要的是需求说明书。</p><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>性能测试（performance test）就是为了发现系统性能问题或获取系统性能相关指标而进行的测试。一般在真实环境、特定负载条件下，通过工具模拟实际软件系统的运行及其操作，同时监控性能各项指标，最后对测试结果进行分析来确定系统的性能状况。</p><h2 id="验收测试："><a href="#验收测试：" class="headerlink" title="验收测试："></a>验收测试：</h2><p>检查软件是否符合合同要求，包括需求规格说明、设计规格说明和用户手册等。</p><p>验收测试的测试人员：用户和测试部门共同完成。</p><p>验收测试的测试依据 ：<br>国家规范，行业标准，合同条款，用户确认的SRS。</p><h2 id="α，β测试"><a href="#α，β测试" class="headerlink" title="α，β测试"></a>α，β测试</h2><p>α测试是指软件开发公司组织内部人员模拟各类用户行对即将面市软件产品（称为α版本）进行测试，试图发现错误并修正。<br>经过α测试调整的软件产品称为β版本。紧随其后的β测试是指软件开发公司组织各方面的典型用户在日常工作中实际使用β版本，并要求用户报告异常情况、提出批评意见。然后软件开发公司再对β版本进行改错和完善。</p><h2 id="自动化测试"><a href="#自动化测试" class="headerlink" title="自动化测试"></a>自动化测试</h2><p>自动化测试是相对手工测试而存在的一个概念，由手工逐个地运行测试用例的操作过程被测试工具自动执行的过程所代替。</p>]]></content:encoded>
      
      <comments>https://guardianss.github.io/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>win10快捷键</title>
      <link>https://guardianss.github.io/win10%E5%BF%AB%E6%8D%B7%E9%94%AE.html</link>
      <guid>https://guardianss.github.io/win10%E5%BF%AB%E6%8D%B7%E9%94%AE.html</guid>
      <pubDate>Fri, 08 May 2020 03:02:22 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot;
          
        
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="复制、粘贴和其他常规键盘快捷方式"><a href="#复制、粘贴和其他常规键盘快捷方式" class="headerlink" title="复制、粘贴和其他常规键盘快捷方式"></a>复制、粘贴和其他常规键盘快捷方式</h1><p>Ctrl + X  -&gt;剪切选定项<br>Ctrl + C（或 Ctrl + Insert） -&gt; 复制选定项<br>Ctrl + V（或 Shift + Insert） -&gt; 粘贴选定项<br>Ctrl + Z -&gt; 撤消操作<br>Alt + Tab -&gt; 在打开的应用之间切换<br>Alt + F4 -&gt; 关闭活动项，或者退出活动应用<br>Windows 徽标键 + L -&gt; 锁定电脑<br>Windows 徽标键 + D -&gt; 显示和隐藏桌面</p><p>F2 -&gt; 重命名选定项<br>F3 -&gt; 在文件资源管理器中搜索文件或文件夹<br>F4 -&gt; 在文件资源管理器中显示地址栏列表<br>F5 -&gt; 刷新活动窗口<br>F6 -&gt; 在窗口中或桌面上循环浏览屏幕元素<br>F10 -&gt; 激活活动应用中的菜单栏<br>Alt + F8 -&gt; 在登录屏幕上显示密码<br>Alt + Esc -&gt; 以项目打开的顺序循环切换项目<br>Alt + 带下划线的字母 -&gt; 执行该字母对应的命令<br>Alt + Enter -&gt; 显示选定项的属性<br>Alt + 空格键 -&gt; 为活动窗口打开快捷菜单<br>Alt + 向左键 -&gt; 后退<br>Alt + 向右键 -&gt; 前进<br>Alt + Page Up -&gt; 向上移动一个屏幕<br>Alt + Page Down -&gt; 向下移动一个屏幕</p><p>Ctrl + F4 -&gt; 关闭活动文档（在全屏模式和允许你同时打开多个文档的应用中）<br>Ctrl + A -&gt; 选择文档或窗口中的所有项目<br>Ctrl + D（或 Delete） -&gt; 删除选定项并将其移动到“回收站”<br>Ctrl + R（或 F5） -&gt; 刷新活动窗口<br>Ctrl + Y -&gt; 重做操作<br>Ctrl + 向右键 -&gt; 将光标移动到下一个字词的起始处<br>Ctrl + 向左键 -&gt; 将光标移动到上一个字词的起始处<br>Ctrl + 向下键 -&gt; 将光标移动到下一个段落的起始处<br>Ctrl + 向上键 -&gt; 将光标移动到上一个段落的起始处<br>Ctrl + Alt + Tab -&gt; 使用箭头键在所有打开的应用之间切换<br>Ctrl + Alt + Shift + 箭头键 -&gt; 当分组或磁贴在“开始”菜单中获得焦点时，请将其按指定方向移动<br>Ctrl + 箭头键（用来移动到某个项目）+ 空格键 -&gt; 在窗口中或桌面上选择多个单独的项目<br>Ctrl + Shift 加某个箭头键 -&gt; 选择文本块</p><p>Ctrl + Esc -&gt; 打开“开始”屏幕<br>Ctrl + Shift + Esc -&gt; 打开任务管理器<br>Ctrl + Shift -&gt; 在提供了多个键盘布局时切换键盘布局<br>Ctrl + 空格键 -&gt; 打开或关闭中文输入法编辑器 (IME)<br>Shift + F10 -&gt; 显示选定项的快捷菜单<br>Shift 加任意箭头键 -&gt; 在窗口中或桌面上选择多个项目，或者在文档中选择文本<br>Shift + Delete -&gt; 无需先将选定项移动到“回收站”，直接将其删除<br>向右键 -&gt; 打开右侧的下一个菜单，或者打开子菜单<br>向左键 -&gt; 打开左侧的下一个菜单，或者关闭子菜单<br>Esc -&gt; 停止或退出当前任务</p><h1 id="Windows-徽标键键盘快捷方式"><a href="#Windows-徽标键键盘快捷方式" class="headerlink" title="Windows 徽标键键盘快捷方式"></a>Windows 徽标键键盘快捷方式</h1><p>Windows 徽标键 -&gt; 打开或关闭“开始”菜单<br>Windows 徽标键 + A -&gt; 打开“操作中心”<br>Windows 徽标键 + B -&gt; 将焦点设置到通知区域<br>Windows 徽标键 + D -&gt; 显示和隐藏桌面<br>Windows 徽标键 + Alt + D -&gt; 显示和隐藏桌面上的日期和时间<br>Windows 徽标键 + E -&gt; 打开“文件资源管理器”<br>Windows 徽标键 + F -&gt; 打开“反馈中心”<br>Windows 徽标键 + G -&gt; 打开游戏栏（当游戏处于打开状态时）<br>Windows 徽标键 + H -&gt; 打开“共享”超级按钮<br>Windows 徽标键 + I -&gt; 打开“设置”</p><p>Windows 徽标键 + J -&gt;  将焦点设置到 Windows 提示（如果可用）。出现 Windows   提示时，将焦点移到该提示。 再次按这些键盘快捷方式，将焦点移到定位 Windows 提示的屏幕上的元素。<br>Windows 徽标键 + K -&gt; 打开“连接”快速操作<br>Windows 徽标键 + L -&gt; 锁定电脑或切换帐户<br>Windows 徽标键 + M -&gt; 最小化所有窗口<br>Windows 徽标键 + O -&gt; 锁定设备方向<br>Windows 徽标键 + P -&gt; 选择演示显示模式<br>Windows 徽标键 + R -&gt; 打开“运行”对话框<br>Windows 徽标键 + S -&gt; 打开搜素<br>Windows 徽标键 + T -&gt; 在任务栏上循环切换应用<br>Windows 徽标键 + U -&gt; 打开“轻松使用设置中心”<br>Windows 徽标键 + V -&gt; 循环切换通知<br>Windows 徽标键 + Shift + V -&gt; 以相反的顺序循环切换通知<br>Windows 徽标键 + X -&gt; 打开“快速链接”菜单<br>Windows 徽标键 + Z -&gt; 显示在以全屏模式呈现的应用中可用的命令<br>Windows 徽标键 + 逗号 (,) -&gt; 临时快速查看桌面</p><p>Windows 徽标键 + Pause -&gt; 显示“系统属性”对话框<br>Windows 徽标键 + Ctrl + F -&gt; 搜索电脑（如果你位于网络中）<br>Windows 徽标键 + Shift + M -&gt; 将最小化的窗口还原到桌面<br>Windows 徽标键 + 数字 -&gt; 打开桌面，并启动固定到任务栏的位于该数字所表示位置的应用。如果该应用已在运行，则切换到该应用。<br>Windows 徽标键 + Shift + 数字 -&gt; 打开桌面，并启动固定到任务栏的位于该数字所表示位置的应用的新实例<br>Windows 徽标键 + Ctrl + 数字 -&gt; 打开桌面，并切换到固定到任务栏的位于该数字所表示位置的应用的最后一个活动窗口<br>Windows 徽标键 + Alt + 数字 -&gt; 打开桌面，并打开固定到任务栏的位于该数字所表示位置的应用的跳转列表<br>Windows 徽标键 + Ctrl + Shift + 数字 -&gt; 打开桌面，并以管理员身份打开位于任务栏上给定位置的应用的新实例<br>Windows 徽标键 + Tab -&gt; 打开“任务视图”</p><p>Windows 徽标键 + 向上键 -&gt; 最大化窗口<br>Windows 徽标键 + 向下键 -&gt; 从屏幕中删除当前应用或最小化桌面窗口<br>Windows 徽标键 + 向左键 -&gt; 将应用或桌面窗口最大化到屏幕左侧<br>Windows 徽标键 + 向右键 -&gt; 将应用或桌面窗口最大化到屏幕右侧<br>Windows 徽标键 + Home -&gt; 最小化除活动桌面窗口以外的所有窗口（在第二道笔划时还原所有窗口）<br>Windows 徽标键 + Shift + 向上键 -&gt; 将桌面窗口拉伸到屏幕的顶部和底部<br>Windows 徽标键 + Shift + 向下键 -&gt; 在垂直方向上还原/最小化活动桌面窗口，同时保持宽度不变<br>Windows 徽标键 + Shift + 向左键或向右键 -&gt; 将桌面中的应用或窗口从一个监视器移动到另一个监视器<br>Windows 徽标键 + 空格键 -&gt; 切换输入语言和键盘布局<br>Windows 徽标键 + Ctrl + 空格键 -&gt; 更改为以前选择的输入<br>Windows 徽标键 + Enter -&gt; 打开“讲述人”<br>Windows 徽标键 + 正斜杠 (/) -&gt; 启动 IME 重新转换<br>Windows 徽标键 + 加号 (+) 或减号 (-) -&gt; 使用“放大镜”放大或缩小<br>Windows 徽标键 + Esc -&gt; 退出“放大镜”</p><h1 id="命令提示符键盘快捷方式"><a href="#命令提示符键盘快捷方式" class="headerlink" title="命令提示符键盘快捷方式"></a>命令提示符键盘快捷方式</h1><p>Ctrl + C（或 Ctrl + Insert） -&gt; 复制选定文本<br>Ctrl + V（或 Shift + Insert） -&gt; 粘贴选定文本<br>Ctrl + M -&gt; 进入标记模式<br>Alt + 选择键 -&gt; 在阻止模式中开始选择<br>箭头键 -&gt; 按指定方向移动光标<br>Page Up -&gt; 将光标向上移动一页<br>Page Down -&gt; 将光标向下移动一页<br>Ctrl + Home（标记模式） -&gt; 将光标移动到缓冲区的起始处<br>Ctrl + End（标记模式） -&gt; 将光标移动到缓冲区的末尾<br>Ctrl + 向上键 -&gt; 在输出历史记录中向上移动一行<br>Ctrl + 向下键 -&gt; 在输出历史记录中向下移动一行<br>Ctrl + Home（历史记录导航） -&gt; 如果命令行为空，则将视口移动到缓冲区顶部。否则，删除命令行中光标左侧的所有字符。<br>Ctrl + End（历史记录导航） -&gt; 如果命令行为空，则将视口移动到命令行。否则，删除命令行中光标右侧的所有字符。</p><h1 id="对话框键盘快捷方式"><a href="#对话框键盘快捷方式" class="headerlink" title="对话框键盘快捷方式"></a>对话框键盘快捷方式</h1><p>F4 -&gt; 显示活动列表中的项目<br>Ctrl + Tab -&gt; 在选项卡上向前移动<br>Ctrl + Shift + Tab -&gt; 在选项卡上向后移动<br>Ctrl + 数字（数字 1 到 9） -&gt; 移动到第 n 个选项卡<br>Tab -&gt; 在选项上向前移动<br>Shift + Tab -&gt; 在选项上向后移动<br>Alt + 带下划线的字母 -&gt; 执行与该字母一起使用的命令（或选择相应的选项）<br>空格键 -&gt; 如果活动选项是复选框，则选中或清除该复选框<br>Backspace -&gt; 如果在“另存为”或“打开”对话框中选中某个文件夹，则打开上一级文件夹<br>箭头键 -&gt; 如果活动选项是一组选项按钮，则选择某个按钮</p><h1 id="文件资源管理器键盘快捷方式"><a href="#文件资源管理器键盘快捷方式" class="headerlink" title="文件资源管理器键盘快捷方式"></a>文件资源管理器键盘快捷方式</h1><p>Alt + D -&gt; 选择地址栏<br>Ctrl + E -&gt; 选择搜索框<br>Ctrl + F -&gt; 选择搜索框<br>Ctrl + N -&gt; 打开新窗口<br>Ctrl + W -&gt; 关闭活动窗口<br>Ctrl + 鼠标滚轮 -&gt; 更改文件和文件夹图标的大小及外观<br>Ctrl + Shift + E -&gt; 显示选定文件夹上的所有文件夹<br>Ctrl + Shift + N -&gt; 创建一个新文件夹<br>Num Lock + 星号 (*) -&gt; 显示选定文件夹下的所有子文件夹<br>Num Lock + 加号 (+) -&gt; 显示选定文件夹的内容<br>Num Lock + 减号 (-) -&gt; 折叠选定文件夹</p><p>Alt + P -&gt; 显示预览面板<br>Alt + Enter -&gt; 打开选定项的“属性”对话框<br>Alt + 向右键 -&gt; 查看下一个文件夹<br>Alt + 向上键 -&gt; 查看上一级文件夹<br>Alt + 向左键 -&gt; 查看上一个文件夹<br>Backspace -&gt; 查看上一个文件夹<br>向右键 -&gt; 显示当前选项（如果它处于折叠状态），或者选择第一个子文件夹<br>向左键 -&gt; 折叠当前选项（如果它处于展开状态），或者选择其父文件夹<br>End -&gt; 显示活动窗口的底端<br>Home -&gt; 显示活动窗口的顶端<br>F11 -&gt; 最大化或最小化活动窗口</p><h1 id="虚拟桌面键盘快捷方式"><a href="#虚拟桌面键盘快捷方式" class="headerlink" title="虚拟桌面键盘快捷方式"></a>虚拟桌面键盘快捷方式</h1><p>Windows 徽标键 + Tab -&gt; 打开任务视图<br>Windows 徽标键 + Ctrl + D -&gt; 添加虚拟桌面<br>Windows 徽标键 + Ctrl + 向右键 -&gt; 在你于右侧创建的虚拟桌面之间进行切换<br>Windows 徽标键 + Ctrl + 向左键 -&gt; 在你于左侧创建的虚拟桌面之间进行切换<br>Windows 徽标键 + Ctrl + F4 -&gt; 关闭你正在使用的虚拟桌面</p><h1 id="任务栏键盘快捷方式"><a href="#任务栏键盘快捷方式" class="headerlink" title="任务栏键盘快捷方式"></a>任务栏键盘快捷方式</h1><p>Shift + 单击某个任务栏按钮 -&gt; 打开某个应用，或快速打开应用的另一个实例<br>Ctrl + Shift + 单击某个任务栏按钮 -&gt; 以管理员身份打开应用<br>Shift + 右键单击某个任务栏按钮 -&gt; 显示该应用的窗口菜单<br>Shift + 右键单击某个已分组的任务栏按钮 -&gt; 显示该组的窗口菜单<br>Ctrl + 单击某个已分组的任务栏按钮 -&gt; 循环切换该组的窗口</p><h1 id="设置键盘快捷方式"><a href="#设置键盘快捷方式" class="headerlink" title="设置键盘快捷方式"></a>设置键盘快捷方式</h1><p>Windows 徽标键 + I -&gt; 打开设置<br>Windows 徽标键 +Backspace -&gt; 回退到“设置”主页<br>Windows 徽标键 +Q -&gt; 搜索<br>Windows   10 应用中的键盘快捷方式<br>在许多应用（如照片、Groove   和地图）中，当你将鼠标指针悬停在某个按钮上时，工具提示中就会显示快捷方式。在其他应用（如画图、写字板和 Office）中，按 Alt 键或 F10 即可显示标记了键盘快捷方式的命令。如果菜单中某个字母有下划线，请同时按下 Alt 键和带有下划线的键，而不是选择该菜单项。例如，按 Ctrl + N 可在“画图”中创建新图片。<br>温馨提示：<br>借助触摸键盘，按下 Ctrl 键即可看到一些快捷方式。<br>以下是   Windows 10 中内置的某些 Microsoft 应用中常见的键盘快捷方式。这包括 Microsoft   Edge、计算器、游戏栏、Groove、地图、画图、照片、音乐和电视以及写字板。</p><h1 id="Microsoft-Edge-键盘快捷方式"><a href="#Microsoft-Edge-键盘快捷方式" class="headerlink" title="Microsoft Edge 键盘快捷方式"></a>Microsoft Edge 键盘快捷方式</h1><p>Ctrl + D -&gt; 将当前站点添加到收藏夹或阅读列表<br>Ctrl + I -&gt; 打开“收藏夹”窗格<br>Ctrl + J -&gt; 打开“下载”窗格<br>Ctrl + H -&gt; 打开“历史记录”窗格<br>Ctrl + P -&gt; 打印当前页面<br>Ctrl + F -&gt; 在页面上查找<br>Ctrl + Shift + R -&gt; 进入阅读视图<br>Ctrl + T -&gt; 打开一个新选项卡<br>Ctrl + Shift + T -&gt; 重新打开最近关闭的选项卡<br>Ctrl + W 或 Ctrl + F4 -&gt; 关闭活动选项卡<br>Ctrl + K -&gt; 复制选项卡<br>Ctrl + N -&gt; 打开新窗口</p><p>Ctrl + Shift + P -&gt; 打开新的   InPrivate 浏览窗口<br>Ctrl + Tab -&gt; 切换到下一个选项卡<br>Ctrl + Shift + Tab -&gt; 切换到上一个选项卡<br>Ctrl + 1、2、3，依此类推 -&gt; 切换到特定选项卡号<br>Ctrl + 9 -&gt; 切换到最后一个选项卡<br>Ctrl + 加号 (+) -&gt; 放大 (25%)<br>Ctrl + 减号 (-) -&gt; 缩小 (25%)<br>Ctrl + 0 -&gt; 重置缩放级别<br>Backspace 或 Alt + 向左键 -&gt; 返回<br>Alt + 向右键 -&gt; 前进<br>F5 或 Ctrl + R -&gt; 刷新页面<br>Esc -&gt; 停止加载页面</p><p>Ctrl + L 或 F4 或 Alt + D -&gt; 选中地址栏<br>Ctrl + Shift + L -&gt; 在新选项卡中打开地址栏查询<br>Ctrl + E -&gt; 在地址栏中打开搜索查询<br>Ctrl + Enter -&gt; 在地址栏中将“www.”添加到所键入文本的开头，将“.com”添加到所键入文本的末尾<br>Ctrl + 单击 -&gt; 在新选项卡中打开链接<br>Ctrl + Shift + 单击 -&gt; 在新选项卡中打开链接并切换到该选项卡<br>Alt + Shift + 单击 -&gt; 在新窗口中打开链接<br>Ctrl + Shift + M -&gt;  开始创建   Web 笔记<br>Ctrl + Alt + M -&gt;  将所选内容复制到   Web 笔记中<br>F12 -&gt; 打开 F12   开发人员工具<br>Ctrl + U -&gt;  查看源<br>F6 -&gt;  在网页内容和地址栏之间切换焦点<br>F7 -&gt;  为活动选项卡打开“插入光标浏览”<br>Ctrl + Shift + Delete -&gt;  显示用于清除浏览数据的控件</p><h1 id="“计算器”键盘快捷方式"><a href="#“计算器”键盘快捷方式" class="headerlink" title="“计算器”键盘快捷方式"></a>“计算器”键盘快捷方式</h1><p>Alt + 1 -&gt; 切换到“标准型”模式<br>Alt + 2 -&gt; 切换到“科学型”模式<br>Alt + 3 -&gt; 切换到“程序员”模式<br>Ctrl + M -&gt; 存储在内存中<br>Ctrl + P -&gt; 添加到内存<br>Ctrl + Q -&gt; 从内存中减去<br>Ctrl + R -&gt; 从内存中重新调用<br>Ctrl + L -&gt; 清除内存<br>F9 -&gt; 选择 ±<br>R -&gt; 选择 1/x<br>@ -&gt; 求平方根<br>Delete -&gt; 选择 CE<br>Ctrl + H -&gt; 打开或关闭计算历史记录<br>向上键 -&gt; 在“历史记录”列表中上移<br>向下键 -&gt; 在“历史记录”列表中下移<br>Ctrl + Shift + D -&gt; 清除历史记录<br>F3 -&gt; 在“科学型”模式下选择 DEG<br>F4 -&gt; 在“科学型”模式下选择 RAD<br>F5 -&gt; 在“科学型”模式下选择 GRAD<br>Ctrl + G -&gt; 在“科学型”模式下选择 10x<br>Ctrl + O -&gt; 在“科学型”模式下选择 cosh<br>Ctrl + S -&gt; 在“科学型”模式下选择 sinh<br>Ctrl + T -&gt; 在“科学型”模式下选择 tanh<br>Shift + S -&gt; 在“科学型”模式下选择 sin-1<br>Shift + O -&gt; 在“科学型”模式下选择 cos-1<br>Shift + T -&gt; 在“科学型”模式下选择“tan-1”<br>Ctrl + Y -&gt; 在“科学型”模式下选择 y√x<br>D -&gt; 在“科学型”模式下选择 Mod<br>L -&gt; 在“科学型”模式下选择 log<br>M -&gt; 在“科学型”模式下选择 dms<br>N -&gt; 在“科学型”模式下选择 ln<br>Ctrl + N -&gt; 在“科学型”模式下选择 ex<br>O -&gt; 在“科学型”模式下选择 cos<br>P -&gt; 在“科学型”模式下选择 Pi<br>Q -&gt; 在“科学型”模式下选择 x2<br>S -&gt; 在“科学型”模式下选择 sin<br>T -&gt; 在“科学型”模式下选择 tan<br>V -&gt; 在“科学型”模式下选择 F-E<br>X -&gt; 在“科学型”模式下选择 Exp<br>    Y, ^ -&gt; 在“科学型”模式下选择 xy</p><h1 id="gt-在“科学型”模式下选择-x3"><a href="#gt-在“科学型”模式下选择-x3" class="headerlink" title="-&gt; 在“科学型”模式下选择 x3"></a>-&gt; 在“科学型”模式下选择 x3</h1><p>; -&gt; 在“科学型”模式下选择 Int<br>! -&gt; 在“科学型”模式下选择 n!<br>F2 -&gt; 在“程序员”模式下选择 DWORD<br>F3 -&gt; 在“程序员”模式下选择 WORD<br>F4 -&gt; 在“程序员”模式下选择 BYTE<br>F5 -&gt; 在“程序员”模式下选择 HEX<br>F6 -&gt; 在“程序员”模式下选择 DEC<br>F7 -&gt; 在“程序员”模式下选择 OCT<br>F8 -&gt; 在“程序员”模式下选择 BIN<br>F12 -&gt; 在“程序员”模式下选择 QWORD<br>A-F -&gt; 在“程序员”模式下选择 A-F<br>J -&gt; 在“程序员”模式下选择 RoL<br>K -&gt; 在“程序员”模式下选择 RoR<br>&lt; -&gt; 在“程序员”模式下选择 Lsh</p><blockquote><p>-&gt; 在“程序员”模式下选择 Rsh<br>% -&gt; 在“程序员”模式下选择 Mod<br>| -&gt; 在“程序员”模式下选择 Or<br>^ -&gt; 在“程序员”模式下选择 Xor<br>~ -&gt; 在“程序员”模式下选择 Not<br>&amp; -&gt; 在“程序员”模式下选择 And<br>空格键 -&gt; 在“程序员”模式下切换位值</p></blockquote><h1 id="游戏栏键盘快捷方式"><a href="#游戏栏键盘快捷方式" class="headerlink" title="游戏栏键盘快捷方式"></a>游戏栏键盘快捷方式</h1><p>Windows 徽标键 + G打开游戏栏（当游戏处于打开状态时）<br>Windows 徽标键 + Alt + G录制最后 30 秒<br>Windows 徽标键 + Alt + R开始或停止录制<br>Windows 徽标键 + Alt + Print Screen获取你的游戏的屏幕截图<br>Windows 徽标键 + Alt + T显示/隐藏录制计时器</p><h1 id="Groove-键盘快捷方式"><a href="#Groove-键盘快捷方式" class="headerlink" title="Groove 键盘快捷方式"></a>Groove 键盘快捷方式</h1><p> Ctrl + P 播放或暂停<br> Ctrl + F 跳到下一曲<br> Ctrl + B 重新播放当前歌曲/跳到上一曲<br> F9 调高音量<br> F8 调低音量<br> F7 静音<br> Ctrl + Enter 选择项目并进入选择模式<br> Ctrl + A 全选<br> Delete 删除选定项<br> Ctrl + Shift + P 播放选定项<br> Ctrl + T 打开或关闭“重复播放”<br> Ctrl + H 打开或关闭“无序播放”<br> Ctrl + Q 搜索</p><h1 id="“地图”键盘快捷方式"><a href="#“地图”键盘快捷方式" class="headerlink" title="“地图”键盘快捷方式"></a>“地图”键盘快捷方式</h1><p>Ctrl + 加号或减号键（+ 或 -）放大或缩小<br>Ctrl + 向左键或向右键旋转<br> Ctrl + 向上键或向下键倾斜</p><ul><li>或 – 键在 3D 城市视图中放大或缩小<br>Page Up 或 Page Down在 3D 城市视图中推远或拉近<br>Ctrl + Y在鸟瞰图和道路视图之间切换地图视图<br>Ctrl + Home在你的当前位置上居中放置地图<br>Ctrl + D获取路线<br>Ctrl + F搜索<br>Ctrl + M最小化活动选项卡<br>Ctrl + P打印<br>Ctrl + T显示或隐藏路况<br>Backspace返回<br>Ctrl + H共享<br>Ctrl + L将焦点移动到地图<br>Ctrl + W关闭活动选项卡<br>Ctrl + Tab转到下一个选项卡<br>Ctrl + Shift + Tab转到上一个选项卡<br>Ctrl + S显示或隐藏街道<br>Ctrl + C复制到剪贴板</li></ul><h1 id="“电影和电视”键盘快捷方式"><a href="#“电影和电视”键盘快捷方式" class="headerlink" title="“电影和电视”键盘快捷方式"></a>“电影和电视”键盘快捷方式</h1><p>Alt + Enter全屏播放<br> Esc退出全屏<br> Enter选择焦点中的内容<br>空格键或Ctrl + P播放或暂停（当视频处于焦点中时）<br>Alt + 向左键或Windows 徽标键 + Backspace返回<br>Ctrl + T打开或关闭“重复播放”<br>F7静音<br>F8调低音量<br>F9调高音量</p><h1 id="“画图”键盘快捷方式"><a href="#“画图”键盘快捷方式" class="headerlink" title="“画图”键盘快捷方式"></a>“画图”键盘快捷方式</h1><p>F11以全屏模式查看图片<br>F12将此图片另存为新文件<br>Ctrl + A选择整个图片<br>Ctrl + B将所选文本改为粗体<br>Ctrl + C将选择内容复制到剪贴板<br>Ctrl + E打开“属性”对话框<br>Ctrl + G显示或隐藏网格线<br>Ctrl + I将所选文本改为斜体<br>Ctrl + N创建新图片<br>Ctrl + O打开现有图片<br>Ctrl + P打印图片<br>Ctrl + R显示或隐藏标尺<br>Ctrl + S将更改保存到图片<br>Ctrl + U为所选文本添加下划线<br>Ctrl + V从剪贴板粘贴选择内容<br>Ctrl + W打开“调整大小和扭曲”对话框<br>Ctrl + X剪切选择内容<br>Ctrl + Y恢复更改<br>Ctrl + Z撤销更改<br>Ctrl + 加号 (+)将画笔、直线或形状轮廓的宽度增加一个像素<br>Ctrl + 减号 (-)将画笔、直线或形状轮廓的宽度减少一个像素<br>Ctrl + Page Up放大<br>Ctrl + Page Down缩小<br>Alt + F4关闭图片及其“画图”窗口<br>向右键将选择内容或活动形状向右移动一个像素<br>向左键将选择内容或活动形状向左移动一个像素<br>向下键将选择内容或活动形状向下移动一个像素<br>向上键将选择内容或活动形状向上移动一个像素<br>Shift + F10显示上下文菜单</p><h1 id="“照片”键盘快捷方式"><a href="#“照片”键盘快捷方式" class="headerlink" title="“照片”键盘快捷方式"></a>“照片”键盘快捷方式</h1><p>空格键（在“集锦”中）选择项目并进入选择模式<br>Enter（从选择模式）在处于选择模式下时选择项目<br>空格键（查看照片）显示或隐藏命令<br>空格键（查看视频）播放或暂停视频<br>箭头键（在集锦中）向上、向下、向左或向右滚动<br>左箭头或右箭头键（位于单个项目或幻灯片放映上）显示下一个或上一个项目<br>箭头键（位于缩放的照片上）在照片内移动<br>Ctrl + 加号或减号（+ 或 -）放大或缩小（查看照片时）<br>Ctrl + 0重置照片的缩放<br>Esc返回到上一个屏幕<br>Ctrl + S保存<br>Ctrl + P打印<br>Ctrl + C复制<br>Ctrl + R（查看或编辑）旋转照片<br>E（查看照片）增强照片效果<br>Ctrl + Z（编辑）撤销更改<br>Ctrl + Y（编辑）恢复更改<br>Ctrl + /（编辑）查看原件<br>Shift + 箭头键调整裁剪或选择性对焦区域的大小<br>Ctrl + 箭头键移动裁剪或选择性对焦区域<br>F5（查看项目）开始幻灯片放映<br>Alt + Enter查看文件信息<br>Ctrl + L设置为锁屏界面<br>Ctrl + N（在“相册”视图中） 创建新相册<br>Ctrl + R（在“相册”视图中） 删除相册<br>Ctrl + D 将选定项添加到相册<br>Ctrl + U 从相册中删除选定项</p><h1 id="“写字板”键盘快捷方式"><a href="#“写字板”键盘快捷方式" class="headerlink" title="“写字板”键盘快捷方式"></a>“写字板”键盘快捷方式</h1><p>F3在“查找”对话框中搜索文本的下一个实例<br>F12将此文档另存为新文件<br>Ctrl + 1设置单倍行距<br>Ctrl + 2设置双倍行距<br>Ctrl + 5将行距设置为 1.5<br>Ctrl + A全选<br>Ctrl + B将所选文本改为粗体<br>Ctrl + C将选择内容复制到剪贴板<br>Ctrl + D插入 Microsoft 绘图<br>Ctrl + E向中心对齐文本<br>Ctrl + F在文档中搜索文本<br>Ctrl + H在文档中替换文本<br>Ctrl + I将所选文本改为斜体<br>Ctrl + J两端对齐文本<br>Ctrl + L向左对齐文本<br>Ctrl + N创建新文档<br>Ctrl + O打开现有文档<br>Ctrl + P打印文档<br>Ctrl + R向右对齐文本<br>Ctrl + S将更改保存到文档<br>Ctrl + U为所选文本添加下划线<br>Ctrl + V从剪贴板粘贴选择内容<br>Ctrl + X剪切选择内容<br>Ctrl + Y恢复更改<br>Ctrl + Z撤销更改<br>Ctrl + 等于号 (=)使所选文本成为下标<br>Ctrl + Shift + 等于号 (=)使所选文本成为上标<br>Ctrl + Shift + 大于号 (&gt;)增加字体大小<br>Ctrl + Shift + 小于号 (&lt;)减小字体大小<br>Ctrl + Shift + A将字符更改为全部使用大写字母<br>Ctrl + Shift + L更改项目符号样式<br>Ctrl + 向左键将光标向左移动一个字<br>Ctrl + 向右键将光标向右移动一个字<br>Ctrl + 向上键将光标移动到上一行<br>Ctrl + 向下键将光标移动到下一行<br>Ctrl + Home移动到文档的开头<br>Ctrl + End移动到文档的末尾<br>Ctrl + Page Up向上移动一个页面<br>Ctrl + Page Down向下移动一个页面<br>Ctrl + Delete删除下一个字<br>Alt + F4关闭“写字板”<br>Shift + F10显示上下文菜单<br>Windows 10 用于辅助功能的 Windows 键盘快捷方式<br>辅助功能快捷方式可帮助你将电脑与键盘或辅助设备结合使用。下面是 Windows 10 中辅助技术的键盘快捷方式列表，包括“放大镜”、“高对比度”等。</p><h1 id="“放大镜”键盘快捷方式"><a href="#“放大镜”键盘快捷方式" class="headerlink" title="“放大镜”键盘快捷方式"></a>“放大镜”键盘快捷方式</h1><p>Windows 徽标键 + 加号 (+) 或减号 (-)放大或缩小<br>Ctrl + Alt + 空格键以全屏模式预览桌面<br>Ctrl + ALT + D切换到停靠模式<br>Ctrl + ALT + F切换到全屏模式<br>Ctrl + ALT + I反色<br>Ctrl + ALT + L切换到镜头模式<br>Ctrl + ALT + R调整镜头大小<br>Ctrl + Alt + 箭头键按箭头键的方向平移<br>Windows 徽标键 + Esc退出“放大镜”</p><h1 id="其他辅助功能键盘快捷方式"><a href="#其他辅助功能键盘快捷方式" class="headerlink" title="其他辅助功能键盘快捷方式"></a>其他辅助功能键盘快捷方式</h1><p>按右 Shift 八秒钟打开和关闭筛选键<br>左 Alt + 左 Shift + Print Screen打开或关闭高对比度<br>左 Alt + 左 Shift + Num Lock打开或关闭鼠标键<br>按 Shift 五次打开或关闭粘滞键<br>按 Num Lock 五秒钟打开或关闭切换键<br>Windows 徽标键 + U打开“轻松使用设置中心”</p>]]></content:encoded>
      
      <comments>https://guardianss.github.io/win10%E5%BF%AB%E6%8D%B7%E9%94%AE.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>白盒测试</title>
      <link>https://guardianss.github.io/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95.html</link>
      <guid>https://guardianss.github.io/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95.html</guid>
      <pubDate>Fri, 01 May 2020 15:47:52 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot;
          
        
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="什么是白盒测试"><a href="#什么是白盒测试" class="headerlink" title="什么是白盒测试"></a>什么是白盒测试</h1><p>定义：按照程序内部结构，逻辑驱动测试程序<br>目的：检测产品内部动作是否按照设计说明书的规范进行，检验程序的每条路径是否都能按照预定要求进行工作<br>对象：源程序<br>用代码内部的分支，路径，条件，使程序设计的控制结构导出测试用例</p><h1 id="白盒测试方法分类"><a href="#白盒测试方法分类" class="headerlink" title="白盒测试方法分类"></a>白盒测试方法分类</h1><p>①、静态测试<br>②、动态测试</p><h1 id="白盒测试的原则"><a href="#白盒测试的原则" class="headerlink" title="白盒测试的原则"></a>白盒测试的原则</h1><p>①、保证一个模块中所有路径至少被测试一次<br>②、所有逻辑值都要测试真和假两种情况<br>③、检查程序内部的数据结构是否有效<br>④、检查上下边界及可操作范围内运行所有循环</p><h1 id="白盒测试的类别"><a href="#白盒测试的类别" class="headerlink" title="白盒测试的类别"></a>白盒测试的类别</h1><p>①、软件共用问题的测试<br>②、语言测试<br>③、sql语句测试<br>④、数据类型测试<br>⑤、界面测试<br>⑥、数值队形测试<br>⑦、业务对象测试<br>⑧、数据管理对象测试</p><h1 id="白盒测试依据"><a href="#白盒测试依据" class="headerlink" title="白盒测试依据"></a>白盒测试依据</h1><p>①、软件需求报告<br>②、软件需求规格说明<br>③、程序设计文档<br>④、软件界面设计<br>⑤、编码规范<br>⑥、开发命名标准</p><h1 id="白盒测试流程"><a href="#白盒测试流程" class="headerlink" title="白盒测试流程"></a>白盒测试流程</h1><p>①、界面对象测试流程<br>界面对象（UI）→业务对象（BO）→数据管理对象（DMO）→DBserver端<br>②、业务对象测试流程<br>DBserver端→数据管理对象（DMO）→业务对象（BO）→界面对象（UI）</p><h1 id="白盒测试方法"><a href="#白盒测试方法" class="headerlink" title="白盒测试方法"></a>白盒测试方法</h1><p>①、尽量先用自动化工具来进行静态解析<br>②、建议先从静态测试开始（静态结构分析、代码走查、静态质量度量），然后进行动态测试（如覆盖率测试）<br>③、以静态分析结果作为依据，再使用代码检查和动态测试方法对静态分析结果进行进一步确认，提高测试效率及准确性<br>④、覆盖率测试是白盒测试的重要手段，在测试报告中可作为量化指标的依据，对于软件的重点模块，应使用多种覆盖率标准衡量代码的覆盖率</p><h1 id="代码检查"><a href="#代码检查" class="headerlink" title="代码检查"></a>代码检查</h1><p>概述：主要检查代码和流图设计的一致性、代码结构的合理性、代码编写的标准性、可读性、代码的逻辑表达的正确性等方面。包括变量检查、命名和类型审查、程序逻辑审查、<br>程序语法检查和程序结构检查等内容。</p><h2 id="目的："><a href="#目的：" class="headerlink" title="目的："></a>目的：</h2><p>①、检查代码是否按照某种标准或规范编写的代码<br>②、检查代码以发现程序缺陷<br>③、通过检查代码容易发现程序产生的错误<br>④、通过检查代码来发现代码是不是流程图要求的；<br>⑤、通过检查代码来发现有没有遗漏的项目；<br>⑥、要代码易于移植，代码经常需要在不同的硬件中运行，或者使用不同的编译器编译；<br>⑦、要代码易于阅读、理解和维护。</p><h2 id="方式："><a href="#方式：" class="headerlink" title="方式："></a>方式：</h2><p>①、桌面检查<br>②、走查<br>③、代码审查</p><h2 id="项目："><a href="#项目：" class="headerlink" title="项目："></a>项目：</h2><p>①、目录文件组织<br>②、检查函数<br>③、数据类型及变量<br>④、检查条件判断语句<br>⑤、检查循环体制<br>⑥、检查代码注释<br>⑦、桌面检查</p><h1 id="静态结构分析"><a href="#静态结构分析" class="headerlink" title="静态结构分析"></a>静态结构分析</h1><p>定义：主要以图形的方式表现程序的内部结构（例如函数调用关系图、函数内部控制流图）；通过应用程序各函数之间的调用关系展示了系统的结构，列出所有函数，用连线表示调用关系和作用。<br>主要分析：<br>①、可以检查函数的调用关系是否正确<br>②、是否存在孤立的函数而没有被调用<br>③、明确函数被调用的频繁度，对调用频繁的函数可以重点检查</p><h1 id="SQL语句测试"><a href="#SQL语句测试" class="headerlink" title="SQL语句测试"></a>SQL语句测试</h1><p>主要检查以下两点：<br>①、语句检查<br>②、类型转换</p><h1 id="代码检查的分析与评价"><a href="#代码检查的分析与评价" class="headerlink" title="代码检查的分析与评价"></a>代码检查的分析与评价</h1><p>主要注意以下两点：<br>①、能力（陈述经代码检查证实了的本软件的能力）<br>②、缺陷和限制</p><h1 id="白盒测试常用技术（7种）"><a href="#白盒测试常用技术（7种）" class="headerlink" title="白盒测试常用技术（7种）"></a>白盒测试常用技术（7种）</h1><h2 id="逻辑覆盖法"><a href="#逻辑覆盖法" class="headerlink" title="逻辑覆盖法"></a>逻辑覆盖法</h2><h3 id="测试覆盖率"><a href="#测试覆盖率" class="headerlink" title="测试覆盖率"></a>测试覆盖率</h3><p>用于确定测试所执行到的覆盖项的百分比；覆盖项指作为测试基础的一个入口或属性，比如语句、分支、条件等<br>测试覆盖率可表示出测试的充分性，在测试分析报告中可作为量化指标的依据，测试覆盖率越高效果越好。但覆盖率不是目标，只是一种手段。<br>测试覆盖率包括功能覆盖和结构覆盖：</p><h3 id="逻辑覆盖"><a href="#逻辑覆盖" class="headerlink" title="逻辑覆盖"></a>逻辑覆盖</h3><p>根据覆盖目标的不同和覆盖源程序语句的详尽程度，逻辑覆盖又可分为语句覆盖 、判定覆盖、条件覆盖、条件判定组合覆盖、多条件覆盖、修改条件判定覆盖、组合覆盖和路径覆盖。</p><h3 id="面向对象的覆盖"><a href="#面向对象的覆盖" class="headerlink" title="面向对象的覆盖"></a>面向对象的覆盖</h3><p>面向对象的覆盖主要讨论继承上下文覆盖和基于状态的上下文覆盖。</p><h3 id="测试覆盖准则"><a href="#测试覆盖准则" class="headerlink" title="测试覆盖准则"></a>测试覆盖准则</h3><p>测试覆盖准则主要讨论（ESTCA）错误敏感测试用例分析和(LCSAJ)线性代码序列与跳转。<br>（1）ESTCA覆盖准则<br>（2）现行代码序列与跳转LCSAJ线性代码序列与条状LCSAJ是指一组顺序执行的代码，以控制流跳转为结束点。可产生4层覆盖</p><h2 id="插桩技术"><a href="#插桩技术" class="headerlink" title="插桩技术"></a>插桩技术</h2><p>插桩测试是一个被广泛应用的测试方法。插桩测试就是向源程序中插入语句然后执行程序，通过打印语句，获得动态信息（我们最为关心的信息）</p><h2 id="基本路径测试法"><a href="#基本路径测试法" class="headerlink" title="基本路径测试法"></a>基本路径测试法</h2><p>基本路径测试法是在程序控制流图的基础上，通过分析控制构造的环路复杂性，导出基本可执行路径集合，从而设计测试用例的方法。设计出的测试用例要保证在测试中程序的<br>每个可执行语句至少执行一次。重点内容如下：<br>程序的控制流图：描述程序控制流的一种图示方法。<br>程序环形复杂度：McCabe复杂性度量。从程序的环路复杂性可导出程序基本路径集合中的独立路径条数，这是确定程序中每个可执行语句至少执行一次所必须的测试用例数目的上界。</p><h2 id="程序控制流图"><a href="#程序控制流图" class="headerlink" title="程序控制流图"></a>程序控制流图</h2><p>程序控制流图（可简称流图）是对程序流程图进行简化后得到的，它突出表示程序控<br>制流的结构。程序控制流图是描述程序控制流的一种方式。控制流图图形符号；<br>图形符号：圆圈代表一个结点， 表示一个或多个无分支的语句或源程序语句；<br>程序控制流边和点圈定的部分叫做区域。当对区域计数时，图形外的一个部分也应记为一个区域；<br>判断语句中的条件为复合条件时，即条件表达式由一个或多个逻辑运算符连接的逻辑表达式（a and b），则需要改变复合条件的判断为一系列只有单个条件的嵌套的判断。<br>基本路径测试方法是在控制流图的基础上，通过分析控制结构的环形复杂度，导出执行路径的基本集，再从该基本集设计测试用例。基本路径测试方法包括以下4个步骤：<br>3.1.1画出程序的控制流图。<br>3.1.2计算程序的环形复杂度，导出程序基本路径集中的独立路径条数，这是确定程序中每个可执行语句至少执行一次所必须的测试用例数目的上界。<br>3.1.3导出基本路径集，确定程序的独立路径。<br>3.1.4根据③中的独立路径，设计测试用例的输入数据和预期输出。<br>•    程序环路复杂性计算方法（三种）：<br>•    (1)流图中区域的数量对应于环形复杂度<br>•    (2)给定流图G的环形复杂度V(G),定义为V(G)=E-N+2, E是流图中边的数量，N是流图中节点的数量。<br>•    (3)  V(G)=P+1, P是流图G中的判定节点数。</p><h2 id="域测试法"><a href="#域测试法" class="headerlink" title="域测试法"></a>域测试法</h2><p>域测试是一种基于程序结构的测试方法，基于对程序输入空间（域）的分析，选择测试点进行测试。主要为：<br>4.1域错误：程序的控制流存在错误，对于某一特定的输入可能执行的是一条错误路径，这种错误称为路径错误，也叫做域错误；<br>4.2 计算型错误：对于特定输入执行的路径正确，但赋值语句的错误导致输出结果错误，称为计算型错误；<br>4.3丢失路径错误：由于程序中的某处少了一个判定谓词而引起的丢失路径错误</p><h2 id="符号测试"><a href="#符号测试" class="headerlink" title="符号测试"></a>符号测试</h2><p>符号测试基本思想是允许程序的输入不仅仅是具体的数值数据，而且包括符号值，符号值可以是基本的符号变量值，也可以是符号变量值的表达式<br>5.1符号测试执行的是代数运算，可以作为普通测试的一个扩充；<br>5.2符号测试可以看作是程序测试和程序验证的一个折衷办法；<br>5.3 符号测试程序中仅有有限的几条执行路径；</p><h2 id="Z路径覆盖法"><a href="#Z路径覆盖法" class="headerlink" title="Z路径覆盖法"></a>Z路径覆盖法</h2><p>分析程序中的路径是指检验程序从入口开始，执行过程中经历的各个语句，直到出口。<br>Z路径覆盖对循环机制进行简化，减少路径的数量，使得覆盖所有路径成为可能，简化循环意义下的路径覆盖称为Z路径覆盖；<br>循环简化：限制循环次数，只考虑循环一次或零次情况；<br>循环简化的目的是限制循环的次数，无论循环的形式和循环体实际执行的次数，简化后的循环测试只考虑执行循环体一次和零次（不执行）两种情况，即考虑执行时进入循环体<br>一次和跳过循环体这两种情况。</p><h2 id="程序变异测试法"><a href="#程序变异测试法" class="headerlink" title="程序变异测试法"></a>程序变异测试法</h2><p>程序变异是一种错误驱动测试。错误驱动测试是指该方法是针对某类特定程序错误的，要想找出程序中所有的错误几乎是不可能的，解决办法是将错误的搜索范围尽可能地缩小，<br>以利于专门测试某类错误是否存在。</p><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/05/02/PSB2qlRMjD8AY9H.png"  alt="白盒测试.png"></p><p><img src="/" class="lazyload" data-src="https://i.loli.net/2020/05/02/Vi1gpQTLqShwzRu.png"  alt="白盒测试1.png"><br>1或0（默认表达方式，Default）<br>  1代表真   0代表假<br>Y或N<br>  Y=Yes代表真  N=No代表假<br>T或F<br>  T=True代表真  F=False代表假<br>4种原因与结果的关系<br><img src="/" class="lazyload" data-src="https://i.loli.net/2020/05/02/lEu31pqiJzXsVnd.png"  alt="白盒测试2.png"></p><p>4种原因与原因的约束<br><img src="/" class="lazyload" data-src="https://i.loli.net/2020/05/02/Vi1gpQTLqShwzRu.png"  alt="白盒测试1.png"></p><p>E约束（排他性约束、Exclusive）：C1和C2中最多有一个可能为1，即C1和C2不能同时为1</p><p>I约束（包含性约束, Inclusive）：： C1、C2、C3中至少有一个必须是1，即： C1、C2、C3不能同时为0</p><p>O约束（唯一性约束, Only）：C1和C2必须有一个且仅有一个为1</p><p>R约束（必要性约束, Request）：： C1是1时，C2必须是1</p><p>M约束（强制约束，Masking）：：唯一的针对结果的约束；若结果E1是1，则结果E2强制为0<br>判定表法Decision Table Method：<br>判定表是分析和表达多种输入条件下系统执行不同动作的工具，它可以把复杂的逻辑关系和多种条件组合的情况表达得既准确又明确。<br>   一般情况下，我们在画出因果图后写出判定表，两者绑定使用。但是无论是因果图法也好，判定表法也好，它们两者都是可以单独使用的。<br>   根据个人喜好，熟练了以后，可以考虑直接使用判定表法，省去画图步骤（Normally）。<br>因果图+判定表的经验结论</p><h2 id="判定表法的优点："><a href="#判定表法的优点：" class="headerlink" title="判定表法的优点："></a>判定表法的优点：</h2><p>1、充分考虑了输入条件间的组合，对组合情况覆盖充分；<br>2、最终每个用例覆盖多种输入情况，有利于提高测试效率；<br>3、设计过程中，对输入条件间的约束关系做了考虑，避免了无效用例，用例的有效性高；<br>4、能同时得出每个测试项的预期输出。</p><h2 id="判定表法的缺点："><a href="#判定表法的缺点：" class="headerlink" title="判定表法的缺点："></a>判定表法的缺点：</h2><p>1、当被测试特性输入较多时，会造成判定表规格过于庞大；<br>2、输入之间的约束条件不能有效区分输入是否确实需要进行组合测试，会造成不需要组合测试的输入做了组合，从而产生用例冗余。</p><h2 id="场景法"><a href="#场景法" class="headerlink" title="场景法"></a>场景法</h2><p>软件几乎都是用事件触发来控制流程的，事件触发时的情景便形成了场景，而同一事件不同的触发顺序和处理结果就形成事件流<br>现在的场景法就是测试用例设计脑图，人称XMind</p><h2 id="错误推测法"><a href="#错误推测法" class="headerlink" title="错误推测法"></a>错误推测法</h2><p>任何有意义的错误推测都值得单独写一条测试用例，一般情况下，推测开发需求中没有明确指明的，错误推测法很随意，就是个头脑风暴</p><p>语句覆盖（每一可执行语句至少执行一次。即执行判定为真的语句）</p><p>判定覆盖（程序中每个判断的取真分支和取假分支至少经历一次。即全真和全假的情况都执行一次）</p><p>条件覆盖（每个判断的每个条件的可能取值至少执行一次。即至少执行一次判断为真的情况，但不要求将所有判定为真的情况都写出来）<br>条件覆盖不一定包含判定覆盖。条件覆盖只能保证每个条件至少有一次为真，而不考虑所有的判定结果</p><p>判定/条件覆盖（判断中每个条件的所有可能取值至少执行一次，同时每个判定的可能结果也至少出现一次。即全真和全假两种情况）</p><p>条件组合覆盖（每个判断的所有可能的条件取值组合至少执行一次。）</p><p>路径覆盖（覆盖程序中所有可能的路径）</p>]]></content:encoded>
      
      <comments>https://guardianss.github.io/%E7%99%BD%E7%9B%92%E6%B5%8B%E8%AF%95.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>黑盒测试</title>
      <link>https://guardianss.github.io/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95.html</link>
      <guid>https://guardianss.github.io/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95.html</guid>
      <pubDate>Fri, 01 May 2020 15:05:03 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot;
          
        
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>黑盒测试又叫功能测试、数据驱动测试或基于需求规格说明书的功能测试。该类测试注重于测试软件的功能性需求。<br>采用这种测试方法，完全不考虑程序内部的逻辑结构和内部特性，只依据程序的《需求规格说明书》，检查程序的功能是否符合它的功能说明。测试工程师无需了解程序代码的内部构造，完全模拟软件产品的最终用户使用该软件，检查软件产品是否达到了用户的需求。黑盒测试方法能更好、更真实地从用户角度来考察被测系统的功能性需求实现情况。</p><h1 id="黑盒测试的目的"><a href="#黑盒测试的目的" class="headerlink" title="黑盒测试的目的"></a>黑盒测试的目的</h1><p>①、是否有不正确或者遗漏的功能<br>②、界面是否有误<br>③、接口上，输入输出是否正确<br>④、是否有数据结构错误或者外部数据库访问错误<br>⑤、性能是否满足要求<br>⑥、初始化或者终止性错误</p><h1 id="黑盒测试的优点"><a href="#黑盒测试的优点" class="headerlink" title="黑盒测试的优点"></a>黑盒测试的优点</h1><p>①、最大程度满足用户需求<br>②、相同动作可重复执行，枯燥部分可由机器完成<br>③、根据测试用例针对性的寻找问题，定位更准确，容易生成测试数据<br>④、测试直接和程序/系统要完成的操作相关联</p><h1 id="黑盒测试的缺点"><a href="#黑盒测试的缺点" class="headerlink" title="黑盒测试的缺点"></a>黑盒测试的缺点</h1><p>①、代码得不到测试<br>②、如果规格设计错误，很难发现<br>③、测试不能充分进行<br>④、结果取决于测试用例的设计</p><h1 id="设计用例的策略"><a href="#设计用例的策略" class="headerlink" title="设计用例的策略"></a>设计用例的策略</h1><p>①、首先进行等价类划分，包括输入和输出条件，减少工作量提高效率<br>②、边界值分析，发现错误的能力最强<br>③、错误推断法，补充用例（这个凭经验）<br>④、对照需求和业务场景逻辑，检查用例<br>⑤、如果需求说明含有输入条件，设计开始就用到因果图和判定表驱动法<br>⑥、参数配置类的软件，要用正交实验法<br>⑦、功能图法，不同时期条件的有效性来设计数据<br>⑧、业务流清晰的系统，采用场景法</p><h1 id="黑盒测试的原则"><a href="#黑盒测试的原则" class="headerlink" title="黑盒测试的原则"></a>黑盒测试的原则</h1><p>1、根据需求和规格要求，明确产品要求的正确性<br>2、针对性的找问题，正确定位<br>3、根据需求重要性确定测试等级和重点，减少缺陷<br>4、接口处，输入是否能正确接收，输出是否正确<br>5、站在用户角度思考，测试</p><h1 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h1><p>黑盒测试方法着重测试软件的功能需求，是在程序接口上进行的测试，主要是为了发现以下错误。<br>(1)是否有功能错误，是否有功能遗漏。<br>(2)是否能够正确地接收输入数据并产生正确的输出结果。<br>(3)是否有数据结构错误或外部信息访问错误。<br>(4)是否有程序初始化和终止方面的错误。</p><h1 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h1><p>从理论上讲，黑盒测试只有采用穷举输入测试，把所有可能的输入都作为测试情况考虑，才能查出程序中所有的错误。实际上测试情况有无穷多个，人们不仅要测试所有合法的输入，而且还要对那些不合法但可能的输入进行测试。这样看来，完全测试是不可能的，所以我们要进行有针对性的测试，通过制定测试案例指导测试的实施，保证软件测试有组织、按步骤，以及有计划地进行。黑盒测试行为必须能够加以量化，才能真正保证软件质量，而测试用例就是将测试行为具体量化的方法之一。具体的黑盒测试用例设计方法包括等价类划分法、边界值分析法、错误推测法、因果图法、判定表驱动法、正交试验设计法、功能图法、场景法等。<br>等价类划分的办法是把程序的输入域划分成若干部分（子集），然后从每个部分中选取少数代表性数据作为测试用例。每一类的代表性数据在测试中的作用等价于这一类中的其他值。该方法是一种重要的，常用的黑盒测试用例设计方法。</p><h2 id="划分等价类"><a href="#划分等价类" class="headerlink" title="划分等价类"></a>划分等价类</h2><p>等价类是指某个输入域的子集合。在该子集合中，各个输入数据对于揭露程序中的错误都是等效的，并合理地假定：测试某等价类的代表值就等于对这一类其它值的测试.因此，可以把全部输入数据合理划分为若干等价类，在每一个等价类中取一个数据作为测试的输入条件，就可以用少量代表性的测试数据.取得较好的测试结果.等价类划分可有两种不同的情况：有效等价类和无效等价类。<br>有效等价类：是指对于程序的规格说明来说是合理的，有意义的输入数据构成的集合.利用有效等价类可检验程序是否实现了规格说明中所规定的功能和性能。<br>无效等价类：与有效等价类的定义恰巧相反。<br>设计测试用例时，要同时考虑这两种等价类.因为，软件不仅要能接收合理的数据，也要能经受意外的考验.这样的测试才能确保软件具有更高的可靠性。<br>划分等价类的方法：下面给出六条确定等价类的原则。<br>①在输入条件规定了取值范围或值的个数的情况下，则可以确立一个有效等价类和两个无效等价类。<br>②在输入条件规定了输入值的集合或者规定了“必须如何”的条件的情况下，可确立一个有效等价类和一个无效等价类。<br>③在输入条件是一个布尔量的情况下，可确定一个有效等价类和一个无效等价类。<br>④在规定了输入数据的一组值（假定n个），并且程序要对每一个输入值分别处理的情况下，可确立n个有效等价类和一个无效等价类。<br>⑤在规定了输入数据必须遵守的规则的情况下，可确立一个有效等价类（符合规则）和若干个无效等价类（从不同角度违反规则）。<br>⑥在确知已划分的等价类中各元素在程序处理中的方式不同的情况下，则应再将该等价类进一步的划分为更小的等价类。</p><h2 id="边界值分析法"><a href="#边界值分析法" class="headerlink" title="边界值分析法"></a>边界值分析法</h2><p>边界值分析是通过选择等价类边界的测试用例。边界值分析法不仅重视输入条件边界，而且也必须考虑输出域边界。它是对等价类划分方法的补充。<br>（1）边界值分析方法的考虑：<br>长期的测试工作经验告诉我们，大量的错误是发生在输入或输出范围的边界上，而不是发生在输入输出范围的内部.因此针对各种边界情况设计测试用例，可以查出更多的错误。<br>使用边界值分析方法设计测试用例，首先应确定边界情况.通常输入和输出等价类的边界，就是应着重测试的边界情况.应当选取正好等于，刚刚大于或刚刚小于边界的值作为测试数据，而不是选取等价类中的典型值或任意值作为测试数据。<br>（2）基于边界值分析方法选择测试用例的原则：<br>1）如果输入条件规定了值的范围，则应取刚达到这个范围的边界的值，以及刚刚超越这个范围边界的值作为测试输入数据。<br>2）如果输入条件规定了值的个数，则用最大个数，最小个数，比最小个数少一，比最大个数多一的数作为测试数据。<br>3）根据规格说明的每个输出条件，使用前面的原则1）。<br>4）根据规格说明的每个输出条件，应用前面的原则2）。<br>5）如果程序的规格说明给出的输入域或输出域是有序集合，则应选取集合的第一个元素和最后一个元素作为测试用例。<br>6）如果程序中使用了一个内部数据结构，则应当选择这个内部数据结构的边界上的值作为测试用例。<br>7）分析规格说明，找出其它可能的边界条件。</p><h2 id="错误推测法"><a href="#错误推测法" class="headerlink" title="错误推测法"></a>错误推测法</h2><p>错误推测法是基于经验和直觉推测程序中所有可能存在的各种错误，从而有针对性的设计测试用例的方法。<br>错误推测方法的基本思想： 列举出程序中所有可能有的错误和容易发生错误的特殊情况，根据他们选择测试用例。 例如，在单元测试时曾列出的许多在模块中常见的错误。以前产品测试中曾经发现的错误等，这些就是经验的总结。还有，输入数据和输出数据为0的情况。 输入表格为空格或输入表格只有一行. 这些都是容易发生错误的情况。可选择这些情况下的例子作为测试用例。</p><h2 id="因果图法"><a href="#因果图法" class="headerlink" title="因果图法"></a>因果图法</h2><p>前面介绍的等价类划分方法和边界值分析方法，都是着重考虑输入条件，但未考虑输入条件之间的联系，相互组合等。 考虑输入条件之间的相互组合，可能会产生一些新的情况。但要检查输入条件的组合不是一件容易的事情，即使把所有输入条件划分成等价类，他们之间的组合情况也相当多。因此必须考虑采用一种适合于描述对于多种条件的组合，相应产生多个动作的形式来考虑设计测试用例，这就需要利用因果图（逻辑模型）。<br>因果图方法最终生成的就是判定表。它适合于检查程序输入条件的各种组合情况。<br>生成测试用例：<br>(1) 分析软件规格说明描述中，哪些是原因（即输入条件或输入条件的等价类），哪些是结果（即输出条件），并给每个原因和结果赋予一个标识符。<br>(2) 分析软件规格说明描述中的语义。找出原因与结果之间，原因与原因之间对应的关系. 根据这些关系，画出因果图。<br>(3) 由于语法或环境限制，有些原因与原因之间，原因与结果之间的组合情况不可能出现. 为表明这些特殊情况，在因果图上用一些记号标明约束或限制条件。<br>(4) 把因果图转换为判定表。<br>(5) 把判定表的每一列拿出来作为依据，设计测试用例。<br>从因果图生成的测试用例（局部，组合关系下的）包括了所有输入数据的取TRUE与取FALSE的情况，构成的测试用例数目达到最少，且测试用例数目随输入数据数目的增加而线性地增加。<br>前面因果图方法中已经用到了判定表。判定表（Decision Table）是分析和表达多逻辑条件下执行不同操作的情况下的工具.在程序设计发展的初期，判定表就已被当作编写程序的辅助工具了.由于它可以把复杂的逻辑关系和多种条件组合的情况表达得既具体又明确。 [2] </p><h2 id="判定表组成法"><a href="#判定表组成法" class="headerlink" title="判定表组成法"></a>判定表组成法</h2><p>条件桩（Condition Stub）：列出了问题的所有条件.通常认为列出的条件的次序无关紧要。<br>动作桩（Action Stub）：列出了问题规定可能采取的操作.这些操作的排列顺序没有约束。<br>条件项（Condition Entry）：列出针对它左列条件的取值.在所有可能情况下的真假值。 [2]<br>动作项（Action Entry）：列出在条件项的各种取值情况下应该采取的动作。 [2]<br>规则：任何一个条件组合的特定取值及其相应要执行的操作.在判定表中贯穿条件项和动作项的一列就是一条规则.显然，判定表中列出多少组条件取值，也就有多少条规则，既条件项和动作项有多少列。<br>判定表的建立步骤：<br>①确定规则的个数。假如有n个条件.每个条件有两个取值（0，1），故有2n种规则。<br>②列出所有的条件桩和动作桩。<br>③填入条件项。<br>④填入动作项.等到初始判定表。<br>⑤简化.合并相似规则（相同动作）。<br>B. Beizer 指出了适合使用判定表设计测试用例的条件：<br>①规格说明以判定表形式给出，或很容易转换成判定表。<br>②条件的排列顺序不会也不影响执行哪些操作。<br>③规则的排列顺序不会也不影响执行哪些操作。<br>④每当某一规则的条件已经满足，并确定要执行的操作后，不必检验别的规则。<br>⑤如果某一规则得到满足要执行多个操作，这些操作的执行顺序无关紧要。</p><h2 id="正交试验设计"><a href="#正交试验设计" class="headerlink" title="正交试验设计"></a>正交试验设计</h2><p>就是使用已经造好了的正交表格来安排试验并进行数据分析的一种方法，目的是用最少的测试用例达到最高的测试覆盖率。</p><h2 id="场景法"><a href="#场景法" class="headerlink" title="场景法"></a>场景法</h2><p>软件几乎都是用事件触发来控制流程的，事件触发的情景<br> <img src="/" class="lazyload" data-src="https://i.loli.net/2020/05/01/jUcub3dlCFTpRZs.jpg"  alt="黑盒测试.jpg"><br>便形成了场景，而同一事件不同的触发顺序和处理结果就形成事件流。这种在软件设计方面的思想也可以引入到软件测试中，可以比较生动地描绘出事件触发时的情景，有利于测试设计者设计测试用例，同时使测试用例更容易理解和执行。<br>基本流和备选流：如下图所示，图中经过用例的每条路径都用基本流和备选流来表示，直黑线表示基本流，是经过用例的最简单的路径。备选流用不同的色彩表示，一个备选流可能从基本流开始，在某个特定条件下执行，然后重新加入基本流中（如备选流1和3）；也可能起源于另一个备选流（如备选流2），或者终止用例而不再重新加入到某个流（如备选流2和4）。</p><h2 id="功能图法"><a href="#功能图法" class="headerlink" title="功能图法"></a>功能图法</h2><p>用功能图（流程图）形象的表达操作流（状态迁移图+布尔函数组成）<br>需要依靠判定表因果图表示逻辑，是黑盒+白盒混合用例的设计方法</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>1）准备工作<br>    用Java语言编写一个求一元二次方程的求解程序program1，一元二次方程的系数取整数。<br>    画出程序program1的控制流图<br>2）实验内容与步骤<br> 第一步：确定测试策略。在本例中，对被测程序的功能有明确的要求，即：<br>    （1）判断是否组成一元二次方程；<br>    （2）求解两个相等实根；<br>    （3）求解两个不相等实根；<br>    （4）求解虚根；<br>Public static float Function(int a,int b,int c){</p><p>}<br>写出源程序，并画出控制流图。<br>第二步：首先用黑盒法设计测试用例，然后用白盒法验证其覆盖性，必要时再进行补充。根据本例的实际情况，可用等价分类法划分输入的等价类，然后用错误推测法作补充。<br>等价分类法：有效等价类、无效等价类<br><img src="/" class="lazyload" data-src="https://i.loli.net/2020/05/01/d3BvEhwp2eZYk4g.png"  alt="Annotation 2020-05-01 232304.png"></p><p>测试用例<br><img src="/" class="lazyload" data-src="https://i.loli.net/2020/05/01/d1BlDLI2GJR3Qjw.png"  alt="Annotation 2020-05-01 232504.png"></p><p>第三步：用白盒法验证第二步产生的测试用例的充分性，看是否满足对被测程序图的完全覆盖。<br><img src="/" class="lazyload" data-src="https://i.loli.net/2020/05/01/Igt89Q3bEASeKHm.png"  alt="Annotation 2020-05-01 232621.png"></p><p>最后，结出结论。</p><h3 id="程序："><a href="#程序：" class="headerlink" title="程序："></a>程序：</h3><p>//求解一元二次方程 ax^2+bx+c=0 的实根和复根， Test类是主类<br>import java.lang.Math;           //math头文件<br>import java.util.Scanner;        //scanner头文件<br>class OnceBasicQuadraticEquation //求解一元二次方程 ax^2+bx+c 的实根和复根的类，其中 getRoot()方法求根和显 示根<br>{<br>private double a; //方程的二次项系数<br>private double b; //方程的一次项系数<br>private static double c; //方程的常数项 //以上三个成员变量分别是方程的系数<br>OnceBasicQuadraticEquation() //无参构造方法<br>{<br>a = 0;<br>b = 0;<br>c = 0;<br>}<br>OnceBasicQuadraticEquation(double a,double b,double c) //有参构造方法<br>{<br>this.a = a;<br>this.b = b;<br>this.c = c;<br>}<br>public void setA(double a)<br>{<br>this.a = a;<br>}<br>public double getA()<br>{<br>return a;<br>}<br>public void setB(double b)<br>{<br>this.b = b;<br>}<br>public double getB()<br>{<br>return b;<br>}<br>public void setC(double c)<br>{<br>this.c = c;<br>}<br>public double getC()<br>{<br>return c;<br>} //以上六个方法分别对应三个系数的置取方法<br>public double getDlt() //计算判别式 Δ=b^2-4ac 的值<br>{<br>double result = Math.pow(b,2) - 4 * a * c;<br>return result;<br>}<br>private double getRightRoot() //求解右侧较大实根的方法<br>{<br>double rightRoot = 0;<br>rightRoot = (-b + Math.sqrt(getDlt())) / (2 * a);<br>return rightRoot;<br>}<br>private double getLeftRoot() //求解左侧较小实根的方法<br>{<br>double leftRoot = 0;<br>leftRoot = (- b - Math.sqrt(getDlt())) / (2 * a);<br>return leftRoot;<br>}<br>public void getRoot() //求解并显示实根或复根的方法<br>{<br>if(a==0)<br>{<br>if(b==0)<br>{<br>if(c==0)<br>{<br>System.out.println(“ 一元二次方程： “ + getA() + “x^2+”+ getB() + “x+” + getC() + “\t 有无穷多解。 “);<br>//a、b、c 全为零时，定义方程有无穷多解。</p><p>}<br>else<br>{<br>//二次项和一次项系数为零，但常数项不为零，方程变为不等式，无解。<br>    System.out.println(“ 一元二次方程： “ + getA() + “x^2+” + getB() + “x+” + getC() + “\t 无解。 “);<br>}<br>}<br>else<br>{<br>//二次项系数为零，一次项系数不为零，方程是一次方程，有唯一解。<br>double result = 0;<br>result = -getC() / getB();<br>System.out.println(“ 一元二次方程： “ + getA() + “x^2+” + getB() + “x+” + getC() + “\t 有唯一解： “ + result);<br>}<br>} else //二次项系数不为零，方程有两个实根或复根。<br>    {<br>    if(getDlt()==0) //判别式 Δ=b^2-4ac=0，方程有两个相等实根。<br>{<br>double result = 0;<br>result = -getB() / (2 * getA());<br>System.out.println(“ 一元二次方程： “ + getA() + “x^2+” + getB() + “x+” + getC() + “\t 有唯一解： “ + result);<br>}<br>    else if(getDlt()&gt;0) //判别式 Δ=b^2-4ac&gt;0 ，方程有两个相异实根。<br>        {<br>        System.out.println(“ 一元二次方程： “ + getA() + “x^2+” + getB() + “x+” + getC() + “\t 有两个实根： “ + getLeftRoot() + “ 和” + getRightRoot());<br>} else //判别式 Δ=b^2-4ac&lt;0 ，方程有两个复根。<br>    {<br>//double imaginaryNumber1 = 0;<br>double imaginaryNumber = 0;<br>double realNumber = 0;<br>imaginaryNumber = Math.sqrt(-getDlt()) / (2 * a);<br>realNumber = -getB() / (2 * a); System.out.println(“ 一元二次方程： “ + getA() + “x^2+” + getB() + “x+” + getC() + “\t 有两个复根： “ + realNumber + “ ±” + imaginaryNumber + “i”);<br>}<br>}<br>}<br>}<br>public class Test<br>{<br>public static void main(String [] args)<br>{<br>    double a,b,c;<br>    System.out.println(“请输入参数a b c :”);<br>    Scanner sc = new Scanner(System.in);<br>        a = sc.nextInt();<br>    b = sc.nextInt();<br>    c = sc.nextInt();</p><p>OnceBasicQuadraticEquation e1 = new OnceBasicQuadraticEquation(a,b,c);<br>e1.getRoot();<br>}<br>}</p><p>流程图：</p>]]></content:encoded>
      
      <comments>https://guardianss.github.io/%E9%BB%91%E7%9B%92%E6%B5%8B%E8%AF%95.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>proxy</title>
      <link>https://guardianss.github.io/proxy.html</link>
      <guid>https://guardianss.github.io/proxy.html</guid>
      <pubDate>Sat, 11 Apr 2020 10:39:00 GMT</pubDate>
      <description>
      
        
        
          
          
            &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;\assets\css\APlayer.min.css&quot;&gt;&lt;script src=&quot;\assets\js\APlayer.min.js&quot;
          
        
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="代理相关"><a href="#代理相关" class="headerlink" title="代理相关"></a>代理相关</h1><ul><li><a href="#%e4%bb%a3%e7%90%86%e7%9b%b8%e5%85%b3">代理相关</a><ul><li><a href="#yarn-%e7%9a%84%e4%bb%a3%e7%90%86">yarn 的代理</a></li><li><a href="#git-%e7%9a%84%e4%bb%a3%e7%90%86">Git 的代理</a><ul><li><a href="#http-%e4%bb%a3%e7%90%86">HTTP 代理</a></li></ul></li><li><a href="#ssh-%e7%9a%84%e4%bb%a3%e7%90%86">SSH 的代理</a><ul><li><a href="#http-%e4%bb%a3%e7%90%86-1">HTTP 代理</a></li></ul></li><li><a href="#%e9%85%8d%e7%bd%ae%e5%ae%8c%e6%88%90">配置完成</a></li><li><a href="#%e5%8f%96%e6%b6%88%e4%bb%a3%e7%90%86">取消代理</a></li></ul></li></ul><h2 id="yarn-的代理"><a href="#yarn-的代理" class="headerlink" title="yarn 的代理"></a>yarn 的代理</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn config <span class="built_in">set</span> proxy http://127.0.0.1:7890</span><br><span class="line">yarn config <span class="built_in">set</span> https-proxy http://127.0.0.1:7890</span><br></pre></td></tr></table></figure><blockquote><p>解释：实际上修改的是 <code>~/.yarnrc</code> 文件</p></blockquote><h2 id="Git-的代理"><a href="#Git-的代理" class="headerlink" title="Git 的代理"></a>Git 的代理</h2><h3 id="HTTP-代理"><a href="#HTTP-代理" class="headerlink" title="HTTP 代理"></a>HTTP 代理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.https://github.com.proxy http://127.0.0.1:7890</span><br></pre></td></tr></table></figure><blockquote><p>解释：实际上修改的是 <code>~/.gitconfig</code> 文件</p></blockquote><h2 id="SSH-的代理"><a href="#SSH-的代理" class="headerlink" title="SSH 的代理"></a>SSH 的代理</h2><h3 id="HTTP-代理-1"><a href="#HTTP-代理-1" class="headerlink" title="HTTP 代理"></a>HTTP 代理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.ssh/config</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">    User git</span><br><span class="line">    ProxyCommand connect -H 127.0.0.1:7890 %h %p</span><br></pre></td></tr></table></figure><h2 id="配置完成"><a href="#配置完成" class="headerlink" title="配置完成"></a>配置完成</h2><p><strong>注意：要重启终端</strong></p><h2 id="取消代理"><a href="#取消代理" class="headerlink" title="取消代理"></a>取消代理</h2><p>当你没使用代理软件的时候如果直接使用 yarn、Git、ssh 会报错，所以最好的做法就是使用这些工具的时候<del>翻墙</del>，如果不翻墙的时候就把修改的文件内容注释掉即可（我没想错的话就是在相应行的开头加上 <code>#</code> 这个符号）</p>]]></content:encoded>
      
      <comments>https://guardianss.github.io/proxy.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>hexo命令总结</title>
      <link>https://guardianss.github.io/hexo-commands.html</link>
      <guid>https://guardianss.github.io/hexo-commands.html</guid>
      <pubDate>Fri, 10 Apr 2020 08:54:38 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;img src=&quot;hexo-commands/1.png&quot; alt=&quot;图片测试&quot;&gt;&lt;/p&gt;
&lt;p&gt;Test again&lt;/p&gt;
&lt;hr&gt;
&lt;pre&gt;&lt;code&gt;参数            描述        默认值

layout            布局    

title            标题    

date          建立日期          文件建立日期

updated      更新日期        文件更新日期

comments   开启文章的评论功能      true

tags       标签（不适用于分页）    

categories    分类（不适用于分页）    

permalink    覆盖文章网址&lt;/code&gt;&lt;/pre&gt;
      
      </description>
      
      
      <content:encoded><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p><img src="/" class="lazyload" data-src="hexo-commands/1.png"  alt="图片测试"></p><p>Test again</p><hr><pre><code>参数            描述        默认值layout            布局    title            标题    date          建立日期          文件建立日期updated      更新日期        文件更新日期comments   开启文章的评论功能      truetags       标签（不适用于分页）    categories    分类（不适用于分页）    permalink    覆盖文章网址</code></pre><a id="more"></a><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a><a href="https://guardianss.github.io/2019/04/17/hexo%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#Quick-Start" title="Quick Start"></a>Quick Start</h2><h3 id="version—–显示-Hexo-版本"><a href="#version—–显示-Hexo-版本" class="headerlink" title="version—–显示 Hexo 版本"></a><a href="https://guardianss.github.io/2019/04/17/hexo%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#version%E2%80%94%E2%80%93%E6%98%BE%E7%A4%BA-Hexo-%E7%89%88%E6%9C%AC" title="version—–显示 Hexo 版本"></a>version—–显示 Hexo 版本</h3><pre><code>$ hexo version</code></pre><h3 id="安全模式——在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行"><a href="#安全模式——在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行" class="headerlink" title="安全模式——在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行"></a><a href="https://guardianss.github.io/2019/04/17/hexo%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#%E5%AE%89%E5%85%A8%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%9C%A8%E5%AE%89%E5%85%A8%E6%A8%A1%E5%BC%8F%E4%B8%8B%EF%BC%8C%E4%B8%8D%E4%BC%9A%E8%BD%BD%E5%85%A5%E6%8F%92%E4%BB%B6%E5%92%8C%E8%84%9A%E6%9C%AC%E3%80%82%E5%BD%93%E6%82%A8%E5%9C%A8%E5%AE%89%E8%A3%85%E6%96%B0%E6%8F%92%E4%BB%B6%E9%81%AD%E9%81%87%E9%97%AE%E9%A2%98%E6%97%B6%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%B0%9D%E8%AF%95%E4%BB%A5%E5%AE%89%E5%85%A8%E6%A8%A1%E5%BC%8F%E9%87%8D%E6%96%B0%E6%89%A7%E8%A1%8C" title="安全模式——在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行"></a>安全模式——在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行</h3><pre><code>$ hexo --safe</code></pre><h3 id="Create-a-new-post———-创建新文章"><a href="#Create-a-new-post———-创建新文章" class="headerlink" title="Create a new post———-创建新文章"></a><a href="https://guardianss.github.io/2019/04/17/hexo%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#Create-a-new-post%E2%80%94%E2%80%94%E2%80%94-%E5%88%9B%E5%BB%BA%E6%96%B0%E6%96%87%E7%AB%A0" title="Create a new post———-创建新文章"></a>Create a new post———-创建新文章</h3><pre><code>$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server——————–运行服务器"><a href="#Run-server——————–运行服务器" class="headerlink" title="Run server——————–运行服务器"></a><a href="https://guardianss.github.io/2019/04/17/hexo%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#Run-server%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%93%E8%BF%90%E8%A1%8C%E6%9C%8D%E5%8A%A1%E5%99%A8" title="Run server——————–运行服务器"></a>Run server——————–运行服务器</h3><pre><code>$ hexo server 选项             描述 -p, --port    重设端口 -s, --static    只使用静态文件 -l, --log    启动日记记录，使用覆盖记录格式</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files———生成静态文件"><a href="#Generate-static-files———生成静态文件" class="headerlink" title="Generate static files———生成静态文件"></a><a href="https://guardianss.github.io/2019/04/17/hexo%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#Generate-static-files%E2%80%94%E2%80%94%E2%80%94%E7%94%9F%E6%88%90%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6" title="Generate static files———生成静态文件"></a>Generate static files———生成静态文件</h3><pre><code>$ hexo generate可以简写为  $ hexo g$ hexo -d-d, --deploy    文件生成后立即部署网站$ hexo -w-w, --watch    监视文件变动</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="clean——清除缓存文件-db-json-和已生成的静态文件-public-。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令"><a href="#clean——清除缓存文件-db-json-和已生成的静态文件-public-。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令" class="headerlink" title="clean——清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令"></a><a href="https://guardianss.github.io/2019/04/17/hexo%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#clean%E2%80%94%E2%80%94%E6%B8%85%E9%99%A4%E7%BC%93%E5%AD%98%E6%96%87%E4%BB%B6-db-json-%E5%92%8C%E5%B7%B2%E7%94%9F%E6%88%90%E7%9A%84%E9%9D%99%E6%80%81%E6%96%87%E4%BB%B6-public-%E3%80%82%E5%9C%A8%E6%9F%90%E4%BA%9B%E6%83%85%E5%86%B5%EF%BC%88%E5%B0%A4%E5%85%B6%E6%98%AF%E6%9B%B4%E6%8D%A2%E4%B8%BB%E9%A2%98%E5%90%8E%EF%BC%89%EF%BC%8C%E5%A6%82%E6%9E%9C%E5%8F%91%E7%8E%B0%E6%82%A8%E5%AF%B9%E7%AB%99%E7%82%B9%E7%9A%84%E6%9B%B4%E6%94%B9%E6%97%A0%E8%AE%BA%E5%A6%82%E4%BD%95%E4%B9%9F%E4%B8%8D%E7%94%9F%E6%95%88%EF%BC%8C%E6%82%A8%E5%8F%AF%E8%83%BD%E9%9C%80%E8%A6%81%E8%BF%90%E8%A1%8C%E8%AF%A5%E5%91%BD%E4%BB%A4" title="clean——清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令"></a>clean——清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令</h3><pre><code>$ hexo clean</code></pre><h3 id="Deploy-to-remote-sites——-部署到远程站点"><a href="#Deploy-to-remote-sites——-部署到远程站点" class="headerlink" title="Deploy to remote sites——-部署到远程站点"></a><a href="https://guardianss.github.io/2019/04/17/hexo%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#Deploy-to-remote-sites%E2%80%94%E2%80%94-%E9%83%A8%E7%BD%B2%E5%88%B0%E8%BF%9C%E7%A8%8B%E7%AB%99%E7%82%B9" title="Deploy to remote sites——-部署到远程站点"></a>Deploy to remote sites——-部署到远程站点</h3><pre><code>$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><h3 id="init————-新建一个网站"><a href="#init————-新建一个网站" class="headerlink" title="init————-新建一个网站"></a><a href="https://guardianss.github.io/2019/04/17/hexo%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#init%E2%80%94%E2%80%94%E2%80%94%E2%80%94-%E6%96%B0%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BD%91%E7%AB%99" title="init————-新建一个网站"></a>init————-新建一个网站</h3><pre><code>$ hexo init [folder]</code></pre><h3 id="list—–列出网站资料"><a href="#list—–列出网站资料" class="headerlink" title="list—–列出网站资料"></a><a href="https://guardianss.github.io/2019/04/17/hexo%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#list%E2%80%94%E2%80%93%E5%88%97%E5%87%BA%E7%BD%91%E7%AB%99%E8%B5%84%E6%96%99" title="list—–列出网站资料"></a>list—–列出网站资料</h3><pre><code>$ hexo list &lt;type&gt;</code></pre><h3 id="publish—————–发表草稿"><a href="#publish—————–发表草稿" class="headerlink" title="publish—————–发表草稿"></a><a href="https://guardianss.github.io/2019/04/17/hexo%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#publish%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%93%E5%8F%91%E8%A1%A8%E8%8D%89%E7%A8%BF" title="publish—————–发表草稿"></a>publish—————–发表草稿</h3><pre><code>$ hexo publish [layout] &lt;filename&gt;</code></pre><h3 id="自定义配置文件的路径—–自定义配置文件的路径，执行后将不再使用-config-yml"><a href="#自定义配置文件的路径—–自定义配置文件的路径，执行后将不再使用-config-yml" class="headerlink" title="自定义配置文件的路径—–自定义配置文件的路径，执行后将不再使用 _config.yml"></a><a href="https://guardianss.github.io/2019/04/17/hexo%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E8%B7%AF%E5%BE%84%E2%80%94%E2%80%93%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E8%B7%AF%E5%BE%84%EF%BC%8C%E6%89%A7%E8%A1%8C%E5%90%8E%E5%B0%86%E4%B8%8D%E5%86%8D%E4%BD%BF%E7%94%A8-config-yml" title="自定义配置文件的路径—–自定义配置文件的路径，执行后将不再使用 _config.yml"></a>自定义配置文件的路径—–自定义配置文件的路径，执行后将不再使用 _config.yml</h3><pre><code>$ hexo --config custom.yml</code></pre><h3 id="migrate——–从其他博客系统-迁移内容"><a href="#migrate——–从其他博客系统-迁移内容" class="headerlink" title="migrate——–从其他博客系统 迁移内容"></a><a href="https://guardianss.github.io/2019/04/17/hexo%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#migrate%E2%80%94%E2%80%94%E2%80%93%E4%BB%8E%E5%85%B6%E4%BB%96%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F-%E8%BF%81%E7%A7%BB%E5%86%85%E5%AE%B9" title="migrate——–从其他博客系统 迁移内容"></a>migrate——–从其他博客系统 迁移内容</h3><pre><code>$ hexo migrate &lt;type&gt;</code></pre><h3 id="分类和标签—–只有文章支持分类和标签，您可以在-Front-matter-中设置。在其他系统中，分类和标签听起来很接近，但是在-Hexo-中两者有着明显的差别：分类具有顺序性和层次性，也就是说-Foo-Bar-不等于-Bar-Foo；而标签没有顺序和层次。"><a href="#分类和标签—–只有文章支持分类和标签，您可以在-Front-matter-中设置。在其他系统中，分类和标签听起来很接近，但是在-Hexo-中两者有着明显的差别：分类具有顺序性和层次性，也就是说-Foo-Bar-不等于-Bar-Foo；而标签没有顺序和层次。" class="headerlink" title="分类和标签—–只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。"></a><a href="https://guardianss.github.io/2019/04/17/hexo%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#%E5%88%86%E7%B1%BB%E5%92%8C%E6%A0%87%E7%AD%BE%E2%80%94%E2%80%93%E5%8F%AA%E6%9C%89%E6%96%87%E7%AB%A0%E6%94%AF%E6%8C%81%E5%88%86%E7%B1%BB%E5%92%8C%E6%A0%87%E7%AD%BE%EF%BC%8C%E6%82%A8%E5%8F%AF%E4%BB%A5%E5%9C%A8-Front-matter-%E4%B8%AD%E8%AE%BE%E7%BD%AE%E3%80%82%E5%9C%A8%E5%85%B6%E4%BB%96%E7%B3%BB%E7%BB%9F%E4%B8%AD%EF%BC%8C%E5%88%86%E7%B1%BB%E5%92%8C%E6%A0%87%E7%AD%BE%E5%90%AC%E8%B5%B7%E6%9D%A5%E5%BE%88%E6%8E%A5%E8%BF%91%EF%BC%8C%E4%BD%86%E6%98%AF%E5%9C%A8-Hexo-%E4%B8%AD%E4%B8%A4%E8%80%85%E6%9C%89%E7%9D%80%E6%98%8E%E6%98%BE%E7%9A%84%E5%B7%AE%E5%88%AB%EF%BC%9A%E5%88%86%E7%B1%BB%E5%85%B7%E6%9C%89%E9%A1%BA%E5%BA%8F%E6%80%A7%E5%92%8C%E5%B1%82%E6%AC%A1%E6%80%A7%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4-Foo-Bar-%E4%B8%8D%E7%AD%89%E4%BA%8E-Bar-Foo%EF%BC%9B%E8%80%8C%E6%A0%87%E7%AD%BE%E6%B2%A1%E6%9C%89%E9%A1%BA%E5%BA%8F%E5%92%8C%E5%B1%82%E6%AC%A1%E3%80%82" title="分类和标签—–只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。"></a>分类和标签—–只有文章支持分类和标签，您可以在 Front-matter 中设置。在其他系统中，分类和标签听起来很接近，但是在 Hexo 中两者有着明显的差别：分类具有顺序性和层次性，也就是说 Foo, Bar 不等于 Bar, Foo；而标签没有顺序和层次。</h3><pre><code>categories:- Diarytags:- PS3- Games</code></pre><h3 id="引用块—–在文章中插入引言，可包含作者、来源和标题"><a href="#引用块—–在文章中插入引言，可包含作者、来源和标题" class="headerlink" title="引用块—–在文章中插入引言，可包含作者、来源和标题"></a><a href="https://guardianss.github.io/2019/04/17/hexo%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#%E5%BC%95%E7%94%A8%E5%9D%97%E2%80%94%E2%80%93%E5%9C%A8%E6%96%87%E7%AB%A0%E4%B8%AD%E6%8F%92%E5%85%A5%E5%BC%95%E8%A8%80%EF%BC%8C%E5%8F%AF%E5%8C%85%E5%90%AB%E4%BD%9C%E8%80%85%E3%80%81%E6%9D%A5%E6%BA%90%E5%92%8C%E6%A0%87%E9%A2%98" title="引用块—–在文章中插入引言，可包含作者、来源和标题"></a>引用块—–在文章中插入引言，可包含作者、来源和标题</h3><pre><code>{% blockquote [author[, source]] [link] [source_link_title] %}    content    {% endblockquote %}</code></pre><h3 id="插入链接"><a href="#插入链接" class="headerlink" title="插入链接"></a><a href="https://guardianss.github.io/2019/04/17/hexo%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#%E6%8F%92%E5%85%A5%E9%93%BE%E6%8E%A5" title="插入链接"></a>插入链接</h3><pre><code>&lt;%- link_to(path, [text], [options]) %&gt;  参数                 描述    默认值  external    在新视窗打开链接    false  class            Class            名称      id                  ID    </code></pre><h3 id="插入电子邮箱链接。"><a href="#插入电子邮箱链接。" class="headerlink" title="插入电子邮箱链接。"></a><a href="https://guardianss.github.io/2019/04/17/hexo%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#%E6%8F%92%E5%85%A5%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1%E9%93%BE%E6%8E%A5%E3%80%82" title="插入电子邮箱链接。"></a>插入电子邮箱链接。</h3><pre><code>&lt;%- mail_to(path, [text], [options]) %&gt;   参数    描述   class    Class 名称   id    ID   subject    邮件主题   cc    抄送（CC）   bcc    密送（BCC）   body    邮件内容</code></pre><h3 id="插入图片。"><a href="#插入图片。" class="headerlink" title="插入图片。"></a><a href="https://guardianss.github.io/2019/04/17/hexo%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E3%80%82" title="插入图片。"></a>插入图片。</h3><pre><code>&lt;%- image_tag(path, [options]) %&gt;   参数    描述   alt    图片的替代文字   class    Class 名称   id    ID   width    图片宽度   height    图片高度</code></pre><h3 id="插入分页链接。"><a href="#插入分页链接。" class="headerlink" title="插入分页链接。"></a><a href="https://guardianss.github.io/2019/04/17/hexo%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#%E6%8F%92%E5%85%A5%E5%88%86%E9%A1%B5%E9%93%BE%E6%8E%A5%E3%80%82" title="插入分页链接。"></a>插入分页链接。</h3><pre><code>&lt;%- paginator(options) %&gt;   参数    描述    默认值   base    基础网址    /   format    网址格式    page/%d/   total    分页总数    1   current    目前页数    0   prev_text    上一页链接的文字。仅在 prev_next 设定开启时才有用。    Prev   next_text    下一页链接的文字。仅在 prev_next 设定开启时才有用。    Next   space    空白文字    …   prev_next    显示上一页和下一页的链接    true   end_size    显示于两侧的页数    1   mid_size    显示于中间的页数    2   show_all    显示所有页数。如果开启此参数的话，end_size 和 mid_size 就没用了。    false   search_form</code></pre><h3 id="插入-Google-搜索框。"><a href="#插入-Google-搜索框。" class="headerlink" title="插入 Google 搜索框。"></a><a href="https://guardianss.github.io/2019/04/17/hexo%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/#%E6%8F%92%E5%85%A5-Google-%E6%90%9C%E7%B4%A2%E6%A1%86%E3%80%82" title="插入 Google 搜索框。"></a>插入 Google 搜索框。</h3><pre><code>&lt;%- search_form(options) %&gt;   参数    描述    默认值   class    表单的 class name    search-form   text    搜索提示文字    Search   button    显示搜索按钮。此参数可为布尔值（boolean）或字符串，当设定是字符串的时候，即为搜索按钮的文字。    false</code></pre><hr>]]></content:encoded>
      
      <comments>https://guardianss.github.io/hexo-commands.html#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
